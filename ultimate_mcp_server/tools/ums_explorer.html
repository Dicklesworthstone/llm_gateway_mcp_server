<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate UMS Explorer</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z'/><path d='M5 10a7 7 0 1 0 14 0'/><path d='M15 13a3 3 0 0 0-6 0 v6a3 3 0 0 0 6 0 v-6Z'/></svg>">
    
    <!-- TailwindCSS (CDN for development - warning is expected) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#f0f9ff',
                            500: '#3b82f6',
                            600: '#2563eb',
                            700: '#1d4ed8',
                            900: '#1e3a8a'
                        },
                        secondary: {
                            500: '#8b5cf6',
                            600: '#7c3aed'
                        }
                    },
                    animation: {
                        'slide-in': 'slideIn 0.5s ease-out',
                        'fade-in': 'fadeIn 0.3s ease-out',
                        'scale-in': 'scaleIn 0.2s ease-out',
                        'pulse-ring': 'pulseRing 2s infinite',
                        'shimmer': 'shimmer 2s infinite',
                        'bounce-subtle': 'bounceSubtle 1s ease-in-out infinite'
                    },
                    backdropBlur: {
                        xs: '2px'
                    }
                }
            }
        }
    </script>
    
    <!-- DaisyUI -->
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.10.1/dist/full.min.css" rel="stylesheet" type="text/css" />
    
    <!-- Alpine.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.8/dist/cdn.min.js"></script>
    
    <!-- SQL.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    
    <!-- D3.js for graph visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Mermaid.js for flowcharts -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.0/dist/mermaid.min.js"></script>
    
    <!-- Toastify -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
    
    <!-- Sortable.js for drag & drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    
    <!-- Virtual Scroll for performance -->
    <script src="https://unpkg.com/@tanstack/virtual-core@3.0.0/build/lib/index.umd.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        :root {
            --color-primary: #3b82f6;
            --color-secondary: #8b5cf6;
            --color-success: #10b981;
            --color-warning: #f59e0b;
            --color-error: #ef4444;
        }
        
        /* Light theme variables */
        [data-theme="light"] {
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-tertiary: #64748b;
            --border-color: #e2e8f0;
            --glass-bg: rgba(255, 255, 255, 0.8);
            --card-bg: rgba(255, 255, 255, 0.9);
        }
        
        /* Dark theme variables */
        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #e2e8f0;
            --text-tertiary: #cbd5e1;
            --border-color: rgba(255, 255, 255, 0.1);
            --glass-bg: rgba(15, 23, 42, 0.8);
            --card-bg: rgba(15, 23, 42, 0.9);
        }
        
        * {
            font-family: 'Inter', sans-serif;
        }
        
        [x-cloak] { display: none !important; }
        
        /* Custom Animations */
        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes scaleIn {
            from { transform: scale(0.95); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        @keyframes pulseRing {
            0% { transform: scale(0.8); opacity: 1; }
            80%, 100% { transform: scale(1.2); opacity: 0; }
        }
        
        @keyframes shimmer {
            0% { background-position: -200px 0; }
            100% { background-position: calc(200px + 100%) 0; }
        }
        
        @keyframes bounceSubtle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }
        
        /* Glass morphism effects */
        [data-theme="dark"] .glass {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        [data-theme="light"] .glass {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        [data-theme="dark"] .glass-dark {
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        [data-theme="light"] .glass-dark {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        /* Enhanced cards */
        [data-theme="dark"] .enhanced-card {
            background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        [data-theme="light"] .enhanced-card {
            background: linear-gradient(145deg, rgba(255,255,255,0.9), rgba(255,255,255,0.7));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0,0,0,0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        [data-theme="dark"] .enhanced-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.15);
            border-color: rgba(59, 130, 246, 0.3);
        }
        
        [data-theme="light"] .enhanced-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.1);
            border-color: rgba(59, 130, 246, 0.4);
        }
        
        /* Memory level colors */
        .memory-working { border-left: 4px solid #f59e0b; background: linear-gradient(90deg, rgba(245, 158, 11, 0.1), transparent); }
        .memory-episodic { border-left: 4px solid #3b82f6; background: linear-gradient(90deg, rgba(59, 130, 246, 0.1), transparent); }
        .memory-semantic { border-left: 4px solid #10b981; background: linear-gradient(90deg, rgba(16, 185, 129, 0.1), transparent); }
        .memory-procedural { border-left: 4px solid #8b5cf6; background: linear-gradient(90deg, rgba(139, 92, 246, 0.1), transparent); }
        
        /* Advanced search */
        .search-container {
            position: relative;
        }
        
        .search-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            z-index: 50;
            max-height: 300px;
            overflow-y: auto;
        }
        
        /* Loading skeletons */
        .skeleton {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200px 100%;
            animation: shimmer 1.5s infinite;
        }
        
        /* Dark mode adjustments */
        [data-theme="dark"] .skeleton {
            background: linear-gradient(90deg, #2a2a2a 25%, #1a1a1a 50%, #2a2a2a 75%);
        }
        
        /* Enhanced scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.1);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(59, 130, 246, 0.3);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(59, 130, 246, 0.5);
        }
        
        /* Status indicators */
        .status-indicator {
            position: relative;
            display: inline-block;
        }
        
        .status-indicator::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: inherit;
            animation: pulse-ring 2s infinite;
        }
        
        .status-active::before { background: var(--color-success); }
        .status-completed::before { background: var(--color-primary); }
        .status-failed::before { background: var(--color-error); }
        .status-paused::before { background: var(--color-warning); }
        
        /* Data table enhancements */
        .data-table {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            overflow: hidden;
        }
        
        .data-table th {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .data-table tr:hover {
            background: rgba(59, 130, 246, 0.1);
        }
        
        /* Floating action button */
        .fab {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--color-primary), var(--color-secondary));
            color: white;
            border: none;
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .fab:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.4);
        }
        
        /* Command palette */
        .command-palette {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            backdrop-filter: blur(20px);
            border-radius: 16px;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        [data-theme="dark"] .command-palette {
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e5e7eb;
        }
        
        [data-theme="light"] .command-palette {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: #1e293b;
        }
        
        [data-theme="dark"] .command-palette input {
            color: #e5e7eb;
        }
        
        [data-theme="light"] .command-palette input {
            color: #1e293b;
        }
        
        [data-theme="dark"] .command-palette input::placeholder {
            color: #9ca3af;
        }
        
        [data-theme="light"] .command-palette input::placeholder {
            color: #64748b;
        }
        
        /* Toast customization */
        .toastify {
            background: rgba(255, 255, 255, 0.95) !important;
            backdrop-filter: blur(10px) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            border-radius: 12px !important;
            color: #1f2937 !important;
        }
        
        .toastify.success {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.9), rgba(5, 150, 105, 0.9)) !important;
            color: white !important;
        }
        
        .toastify.error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.9), rgba(220, 38, 38, 0.9)) !important;
            color: white !important;
        }
        
        /* Charts enhancements */
        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 1.5rem;
        }
        
        /* Responsive improvements */
        @media (max-width: 768px) {
            .fab {
                bottom: 1rem;
                right: 1rem;
                width: 48px;
                height: 48px;
            }
            
            .command-palette {
                width: 95%;
            }
        }
        
        /* Performance optimizations */
        .will-change-transform {
            will-change: transform;
        }
        
        .gpu-accelerated {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000;
        }
        
        /* Thought Chain Flow Diagram Styles */
        .thought-chain-container {
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            position: relative;
            overflow: hidden;
            min-height: 70vh;
        }
        
        .mermaid-container {
            width: 100%;
            height: 100%;
            overflow: auto;
            padding: 2rem;
        }
        
        .timeline-scrubber {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .timeline-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg, #374151, #6b7280);
            outline: none;
            opacity: 0.8;
            transition: opacity 0.3s ease;
            cursor: pointer;
        }
        
        .timeline-slider:hover {
            opacity: 1;
        }
        
        .timeline-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
            transition: all 0.2s ease;
        }
        
        .timeline-slider::-webkit-slider-thumb:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(59, 130, 246, 0.6);
        }
        
        .timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
        }
        
        .playback-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .playback-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .playback-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
        }
        
        .playback-btn:active {
            transform: scale(0.95);
        }
        
        .playback-btn.secondary {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            box-shadow: 0 4px 12px rgba(107, 114, 128, 0.3);
        }
        
        .timeline-markers {
            position: relative;
            height: 20px;
            margin: 0.5rem 0;
        }
        
        .timeline-marker {
            position: absolute;
            width: 2px;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            top: 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .timeline-marker:hover {
            background: rgba(59, 130, 246, 0.8);
            width: 4px;
            margin-left: -1px;
        }
        
        .timeline-marker.major {
            background: rgba(255, 255, 255, 0.5);
            height: 100%;
        }
        
        .timeline-marker.current {
            background: #3b82f6;
            width: 4px;
            margin-left: -1px;
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.6);
        }
        
        .thought-node {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .thought-node.active {
            filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.8));
            transform: scale(1.02);
        }
        
        .thought-node.dimmed {
            opacity: 0.3;
        }
        
        .thought-node.highlighted {
            filter: drop-shadow(0 0 12px rgba(34, 197, 94, 0.8));
        }
        
        .chain-sidebar {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 1.5rem;
            height: fit-content;
            max-height: calc(100vh - 16rem);
            overflow-y: auto;
        }
        
        .chain-metadata {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 12px;
            margin-bottom: 1rem;
        }
        
        .thought-details {
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 12px;
            border-left: 4px solid #3b82f6;
        }
        
        .branch-indicator {
            position: relative;
            margin: 0.5rem 0;
        }
        
        .branch-indicator::before {
            content: '';
            position: absolute;
            left: -1rem;
            top: 50%;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #8b5cf6;
            transform: translateY(-50%);
        }
        
        .chain-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .chain-stat {
            text-align: center;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }
        
        .chain-stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #3b82f6;
        }
        
        .chain-stat-label {
            font-size: 0.75rem;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        /* Mermaid diagram customization */
        .mermaid .node rect {
            stroke: rgba(59, 130, 246, 0.5) !important;
            stroke-width: 2px !important;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }
        
        .mermaid .node.active rect {
            stroke: #3b82f6 !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 4px 8px rgba(59,130,246,0.5));
        }
        
        .mermaid .edgePath path {
            stroke: rgba(255, 255, 255, 0.4) !important;
            stroke-width: 2px !important;
        }
        
        .mermaid .edgePath.active path {
            stroke: #3b82f6 !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 2px 4px rgba(59,130,246,0.5));
        }
        
        .mermaid .nodeLabel {
            color: #e5e7eb !important;
            font-family: 'Inter', sans-serif !important;
            font-size: 12px !important;
            font-weight: 500 !important;
        }
        
        /* Speed control styling */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: 1rem;
        }
        
        .speed-btn {
            padding: 0.25rem 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #e5e7eb;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .speed-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .speed-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
        
        /* Graph visualization styles */
        .graph-container {
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            position: relative;
            overflow: hidden;
        }
        
        .graph-svg {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        .graph-svg:active {
            cursor: grabbing;
        }
        
        .graph-node {
            cursor: pointer;
            stroke-width: 2px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
            transition: all 0.2s ease;
        }
        
        .graph-node:hover {
            stroke-width: 3px;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.5));
        }
        
        .graph-node.selected {
            stroke-width: 4px;
            filter: drop-shadow(0 6px 12px rgba(59,130,246,0.5));
        }
        
        .graph-link {
            stroke-opacity: 0.6;
            transition: stroke-opacity 0.2s ease;
        }
        
        .graph-link.highlighted {
            stroke-opacity: 1;
            stroke-width: 3px;
        }
        
        .graph-text {
            font-family: 'Inter', sans-serif;
            font-size: 10px;
            font-weight: 500;
            fill: #e5e7eb;
            text-anchor: middle;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .graph-controls {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .graph-sidebar {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 1.5rem;
            height: fit-content;
            max-height: calc(100vh - 12rem);
            overflow-y: auto;
        }
        
        .graph-legend {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 10;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1rem;
            min-width: 200px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 0.5rem;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .cluster-outline {
            fill: none;
            stroke: rgba(255,255,255,0.2);
            stroke-width: 2;
            stroke-dasharray: 5,5;
            opacity: 0.7;
        }
        
        .graph-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            color: white;
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 0.875rem;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        /* Advanced micro-interactions */
        .interactive {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .interactive:active {
            transform: scale(0.98);
        }
        
        /* Loading states */
        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(59, 130, 246, 0.3);
            border-top: 3px solid var(--color-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="min-h-screen transition-colors duration-300" x-data="umsExplorer()" x-cloak 
      :class="theme === 'light' ? 'bg-gradient-to-br from-slate-50 via-blue-50 to-slate-50 text-slate-900' : 'bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 text-white'"
      :style="`background: ${theme === 'light' ? 'linear-gradient(135deg, #f8fafc, #eff6ff, #f8fafc)' : 'linear-gradient(135deg, #0f172a, #1e3a8a, #0f172a)'}`">

    <!-- Command Palette -->
    <div x-show="showCommandPalette" 
         x-transition:enter="transition ease-out duration-200" 
         x-transition:enter-start="opacity-0" 
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-150" 
         x-transition:leave-start="opacity-100" 
         x-transition:leave-end="opacity-0"
         class="fixed inset-0 bg-black/50 z-[1000]" 
         @click="showCommandPalette = false">
        <div class="command-palette" @click.stop="">
            <div class="p-4">
                <input type="text" 
                       x-model="commandQuery" 
                       @input="updateCommands"
                       @keydown.enter="executeCommand"
                       @keydown.escape="showCommandPalette = false"
                       placeholder="Type a command or search..."
                       class="w-full p-3 rounded-lg bg-transparent border border-white/20 text-lg focus:outline-none focus:border-blue-400">
                <div class="mt-4 max-h-80 overflow-y-auto">
                    <template x-for="cmd in filteredCommands" :key="cmd.id">
                        <div class="p-3 rounded-lg hover:bg-white/10 cursor-pointer transition-colors" 
                             @click="executeCommand(cmd)">
                            <div class="flex items-center">
                                <i :data-lucide="cmd.icon" class="w-5 h-5 mr-3"></i>
                                <div>
                                    <div class="font-medium" x-text="cmd.title"></div>
                                    <div class="text-sm text-gray-400" x-text="cmd.description"></div>
                                </div>
                                <div class="ml-auto text-sm text-gray-500" x-text="cmd.shortcut"></div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>
    </div>

    <!-- Header with enhanced navigation -->
    <header class="glass-dark border-b border-white/10 sticky top-0 z-40">
        <div class="container mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <!-- Logo and breadcrumbs -->
                <div class="flex items-center space-x-4">
                    <div class="flex items-center space-x-3">
                        <div class="relative">
                            <div class="w-10 h-10 rounded-xl bg-gradient-to-r from-blue-500 to-purple-600 flex items-center justify-center">
                                <i data-lucide="brain-circuit" class="w-6 h-6"></i>
                            </div>
                            <div x-show="isProcessing" class="absolute inset-0 rounded-xl border-2 border-blue-400 animate-pulse-ring"></div>
                        </div>
                        <div>
                            <h1 class="text-xl font-bold bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
                                UMS Explorer
                            </h1>
                            <p class="text-xs text-gray-400">Unified Memory System</p>
                        </div>
                    </div>
                    
                    <!-- Breadcrumbs -->
                    <nav x-show="dbLoaded" class="hidden md:flex">
                        <ol class="flex items-center space-x-2 text-sm">
                            <li><a href="#" @click="currentView = 'dashboard'" 
                                   class="text-gray-400 hover:text-white transition-colors"
                                   :class="{'text-blue-400': currentView === 'dashboard'}">Dashboard</a></li>
                            <template x-if="currentView !== 'dashboard'">
                                <li class="text-gray-600">/</li>
                                <li class="text-blue-400 capitalize" x-text="currentView"></li>
                            </template>
                        </ol>
                    </nav>
                </div>
                
                <!-- Right side controls -->
                <div class="flex items-center space-x-4">
                    <!-- Advanced search -->
                    <div x-show="dbLoaded" class="relative search-container">
                        <div class="relative">
                            <input type="text" 
                                   x-model="globalSearch" 
                                   @input.debounce.300ms="performGlobalSearch"
                                   @focus="showSearchSuggestions = true"
                                   @blur.delay.150ms="showSearchSuggestions = false"
                                   placeholder="Search everything..." 
                                   class="w-64 pl-10 pr-4 py-2 bg-white/10 backdrop-blur-md border border-white/20 rounded-xl text-white placeholder-gray-400 focus:outline-none focus:border-blue-400 focus:bg-white/20 transition-all">
                            <i data-lucide="search" class="absolute left-3 top-1/2 transform -translate-y-1/2 w-4 h-4 text-gray-400"></i>
                        </div>
                        
                        <!-- Search suggestions -->
                        <div x-show="showSearchSuggestions && searchSuggestions.length > 0" 
                             class="search-suggestions mt-2 p-2">
                            <template x-for="suggestion in searchSuggestions.slice(0, 5)" :key="suggestion.id">
                                <div class="p-2 hover:bg-white/10 rounded-lg cursor-pointer transition-colors" 
                                     @click="selectSearchSuggestion(suggestion)">
                                    <div class="flex items-center">
                                        <i :data-lucide="suggestion.icon" class="w-4 h-4 mr-2 text-gray-400"></i>
                                        <div>
                                            <div class="text-sm font-medium" x-text="suggestion.title"></div>
                                            <div class="text-xs text-gray-500" x-text="suggestion.type"></div>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                    
                    <!-- Database status -->
                    <div x-show="dbLoaded" class="hidden md:flex items-center space-x-2">
                        <div class="w-2 h-2 bg-green-400 rounded-full animate-pulse"></div>
                        <span class="text-sm text-gray-300">Connected</span>
                    </div>
                    
                    <!-- Theme toggle -->
                    <button @click="toggleTheme()" 
                            class="p-2 rounded-lg bg-white/10 backdrop-blur-md border border-white/20 hover:bg-white/20 transition-all interactive">
                        <i :data-lucide="theme === 'dark' ? 'sun' : 'moon'" class="w-4 h-4"></i>
                    </button>
                    
                    <!-- Command palette trigger -->
                    <button @click="showCommandPalette = true" 
                            class="p-2 rounded-lg bg-white/10 backdrop-blur-md border border-white/20 hover:bg-white/20 transition-all interactive">
                        <i data-lucide="command" class="w-4 h-4"></i>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main content area -->
    <main class="container mx-auto px-4 py-6">
        <!-- Database loading state -->
        <div x-show="!dbLoaded && !isLoading" class="min-h-[70vh] flex items-center justify-center">
            <div class="enhanced-card rounded-2xl p-8 max-w-md w-full text-center animate-scale-in">
                <div class="mb-6">
                    <div class="w-20 h-20 bg-gradient-to-r from-blue-500 to-purple-600 rounded-2xl flex items-center justify-center mx-auto mb-4 animate-bounce-subtle">
                        <i data-lucide="database" class="w-10 h-10"></i>
                    </div>
                    <h2 class="text-2xl font-bold mb-2">Load Your UMS Database</h2>
                    <p class="text-gray-400">Drag and drop your database file or click to browse</p>
                </div>
                
                <div class="drop-zone relative rounded-xl border-2 border-dashed border-gray-600 hover:border-blue-400 transition-colors p-8 cursor-pointer group"
                     @drop.prevent="handleFileDrop($event)"
                     @dragover.prevent="$event.currentTarget.classList.add('border-blue-400', 'bg-blue-400/10')"
                     @dragleave.prevent="$event.currentTarget.classList.remove('border-blue-400', 'bg-blue-400/10')"
                     @click="$refs.fileInput.click()">
                    <div class="text-center">
                        <i data-lucide="upload-cloud" class="w-12 h-12 mx-auto mb-4 text-gray-400 group-hover:text-blue-400 transition-colors"></i>
                        <p class="font-medium mb-2">Drop your database file here</p>
                        <p class="text-sm text-gray-500">Supports .db, .sqlite, .sqlite3 files</p>
                    </div>
                    <input type="file" 
                           x-ref="fileInput" 
                           @change="loadDatabase($event)" 
                           accept=".db,.sqlite,.sqlite3" 
                           class="hidden" />
                </div>
                
                <div class="mt-6 p-4 bg-blue-500/10 rounded-lg border border-blue-500/20">
                    <div class="flex items-center text-sm text-blue-300">
                        <i data-lucide="info" class="w-4 h-4 mr-2"></i>
                        <span>Default location: <code class="bg-black/20 px-2 py-1 rounded">./storage/unified_agent_memory.db</code></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Loading state -->
        <div x-show="isLoading" class="min-h-[70vh] flex items-center justify-center">
            <div class="text-center animate-fade-in">
                <div class="spinner mb-4 mx-auto"></div>
                <p class="text-xl font-medium mb-2" x-text="loadingMessage"></p>
                <p class="text-gray-400">Please wait while we process your data...</p>
            </div>
        </div>

        <!-- Dashboard -->
        <div x-show="dbLoaded && currentView === 'dashboard'" class="space-y-6 animate-slide-in">
            <!-- Quick stats -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                <div class="enhanced-card rounded-2xl p-6 group">
                    <div class="flex items-center justify-between mb-4">
                        <div class="w-12 h-12 bg-blue-500/20 rounded-xl flex items-center justify-center group-hover:scale-105 transition-transform">
                            <i data-lucide="brain" class="w-6 h-6 text-blue-400"></i>
                        </div>
                        <div class="text-right">
                            <div class="text-2xl font-bold" x-text="stats.totalMemories || 0"></div>
                            <div class="text-sm text-gray-400">Memories</div>
                        </div>
                    </div>
                    <div class="h-2 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-gradient-to-r from-blue-500 to-blue-400 rounded-full transition-all duration-1000" 
                             :style="`width: ${Math.min(100, (stats.totalMemories / 1000) * 100)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-2xl p-6 group">
                    <div class="flex items-center justify-between mb-4">
                        <div class="w-12 h-12 bg-purple-500/20 rounded-xl flex items-center justify-center group-hover:scale-105 transition-transform">
                            <i data-lucide="git-branch" class="w-6 h-6 text-purple-400"></i>
                        </div>
                        <div class="text-right">
                            <div class="text-2xl font-bold" x-text="stats.totalWorkflows || 0"></div>
                            <div class="text-sm text-gray-400">Workflows</div>
                        </div>
                    </div>
                    <div class="h-2 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-gradient-to-r from-purple-500 to-purple-400 rounded-full transition-all duration-1000" 
                             :style="`width: ${Math.min(100, (stats.totalWorkflows / 50) * 100)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-2xl p-6 group">
                    <div class="flex items-center justify-between mb-4">
                        <div class="w-12 h-12 bg-green-500/20 rounded-xl flex items-center justify-center group-hover:scale-105 transition-transform">
                            <i data-lucide="zap" class="w-6 h-6 text-green-400"></i>
                        </div>
                        <div class="text-right">
                            <div class="text-2xl font-bold" x-text="stats.totalActions || 0"></div>
                            <div class="text-sm text-gray-400">Actions</div>
                        </div>
                    </div>
                    <div class="h-2 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-gradient-to-r from-green-500 to-green-400 rounded-full transition-all duration-1000" 
                             :style="`width: ${Math.min(100, (stats.totalActions / 500) * 100)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-2xl p-6 group">
                    <div class="flex items-center justify-between mb-4">
                        <div class="w-12 h-12 bg-yellow-500/20 rounded-xl flex items-center justify-center group-hover:scale-105 transition-transform">
                            <i data-lucide="target" class="w-6 h-6 text-yellow-400"></i>
                        </div>
                        <div class="text-right">
                            <div class="text-2xl font-bold" x-text="stats.totalGoals || 0"></div>
                            <div class="text-sm text-gray-400">Goals</div>
                        </div>
                    </div>
                    <div class="h-2 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-gradient-to-r from-yellow-500 to-yellow-400 rounded-full transition-all duration-1000" 
                             :style="`width: ${Math.min(100, (stats.totalGoals / 100) * 100)}%`"></div>
                    </div>
                </div>
            </div>

                         <!-- Navigation cards -->
             <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="navigateTo('workflows')">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-purple-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="git-branch" class="w-6 h-6 text-purple-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Workflows</h3>
                             <p class="text-sm text-gray-400">Explore AI agent workflows</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">View all workflows</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-purple-400 transition-colors"></i>
                     </div>
                 </div>
                 
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="navigateTo('memories')">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-blue-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="brain" class="w-6 h-6 text-blue-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Memory System</h3>
                             <p class="text-sm text-gray-400">Dive into memory hierarchy</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Explore memories</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-blue-400 transition-colors"></i>
                     </div>
                 </div>
                 
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="navigateTo('actions')">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-orange-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="zap" class="w-6 h-6 text-orange-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Actions</h3>
                             <p class="text-sm text-gray-400">Review executed actions</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Browse actions</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-orange-400 transition-colors"></i>
                     </div>
                 </div>
                 
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="navigateTo('goals')">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-yellow-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="target" class="w-6 h-6 text-yellow-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Goal Hierarchy</h3>
                             <p class="text-sm text-gray-400">Interactive goal tree & dependencies</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Manage goals</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-yellow-400 transition-colors"></i>
                     </div>
                 </div>
                 
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="navigateTo('analytics')">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-green-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="bar-chart-3" class="w-6 h-6 text-green-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Analytics</h3>
                             <p class="text-sm text-gray-400">Visualize patterns & insights</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">View analytics</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-green-400 transition-colors"></i>
                     </div>
                 </div>
             </div>

             <!-- Second row of navigation cards -->
             <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="navigateTo('graph')">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-cyan-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="network" class="w-6 h-6 text-cyan-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Memory Graph</h3>
                             <p class="text-sm text-gray-400">Interactive network visualization</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Explore connections</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-cyan-400 transition-colors"></i>
                     </div>
                 </div>
                 
                 <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="navigateTo('thought-chains')">
                     <div class="flex items-center mb-4">
                         <div class="w-12 h-12 bg-indigo-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                             <i data-lucide="git-branch-plus" class="w-6 h-6 text-indigo-400"></i>
                         </div>
                         <div>
                             <h3 class="text-lg font-semibold">Thought Chains</h3>
                             <p class="text-sm text-gray-400">Reasoning flow diagrams</p>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <span class="text-sm text-gray-500">Trace reasoning paths</span>
                         <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-indigo-400 transition-colors"></i>
                     </div>
                 </div>
                 
                                     <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="navigateTo('semantic-search')">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 bg-rose-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                                <i data-lucide="search" class="w-6 h-6 text-rose-400"></i>
                            </div>
                            <div>
                                <h3 class="text-lg font-semibold">Semantic Search</h3>
                                <p class="text-sm text-gray-400">Vector similarity with clustering</p>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-sm text-gray-500">Advanced search intelligence</span>
                            <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-rose-400 transition-colors"></i>
                        </div>
                    </div>
                    
                    <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="navigateTo('working-memory')">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 bg-amber-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                                <i data-lucide="cpu" class="w-6 h-6 text-amber-400"></i>
                            </div>
                            <div>
                                <h3 class="text-lg font-semibold">Working Memory</h3>
                                <p class="text-sm text-gray-400">Real-time memory management</p>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-sm text-gray-500">Live optimization & controls</span>
                            <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-amber-400 transition-colors"></i>
                        </div>
                    </div>
                    
                    <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="navigateTo('cognitive-timeline')">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 bg-emerald-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                                <i data-lucide="activity" class="w-6 h-6 text-emerald-400"></i>
                            </div>
                            <div>
                                <h3 class="text-lg font-semibold">Cognitive Timeline</h3>
                                <p class="text-sm text-gray-400">State snapshots with diff views</p>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-sm text-gray-500">Pattern analysis & restoration</span>
                            <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-emerald-400 transition-colors"></i>
                        </div>
                    </div>
                    
                    <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="navigateTo('workflow-dependencies')">
                        <div class="flex items-center mb-4">
                            <div class="w-12 h-12 bg-violet-500/20 rounded-xl flex items-center justify-center mr-4 group-hover:scale-105 transition-transform">
                                <i data-lucide="git-merge" class="w-6 h-6 text-violet-400"></i>
                            </div>
                            <div>
                                <h3 class="text-lg font-semibold">Workflow Dependencies</h3>
                                <p class="text-sm text-gray-400">Gantt chart + network scheduling</p>
                            </div>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-sm text-gray-500">Critical path & resource optimization</span>
                            <i data-lucide="arrow-right" class="w-4 h-4 text-gray-400 group-hover:text-violet-400 transition-colors"></i>
                        </div>
                    </div>
             </div>

            <!-- Recent activity timeline -->
            <div class="enhanced-card rounded-2xl p-6">
                <div class="flex items-center justify-between mb-6">
                    <h3 class="text-xl font-semibold">Recent Activity</h3>
                    <button class="text-sm text-blue-400 hover:text-blue-300 transition-colors">View All</button>
                </div>
                <div class="space-y-4">
                    <template x-for="(item, index) in recentActivity.slice(0, 5)" :key="item.id">
                        <div class="flex items-center space-x-4 p-3 rounded-xl bg-white/5 hover:bg-white/10 transition-colors animate-fade-in"
                             :style="`animation-delay: ${index * 100}ms`">
                            <div class="w-10 h-10 rounded-xl bg-gradient-to-r from-blue-500 to-purple-600 flex items-center justify-center flex-shrink-0">
                                <i :data-lucide="item.icon" class="w-5 h-5"></i>
                            </div>
                            <div class="flex-1 min-w-0">
                                <p class="font-medium truncate" x-text="item.title"></p>
                                <p class="text-sm text-gray-400 truncate" x-text="item.description"></p>
                            </div>
                            <div class="text-sm text-gray-500" x-text="formatRelativeTime(item.timestamp)"></div>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- Workflows View -->
        <div x-show="dbLoaded && currentView === 'workflows'" class="animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Workflows</h2>
                    <p class="text-gray-400" x-text="`${filteredWorkflows.length} workflows found`"></p>
                </div>
                <div class="flex items-center space-x-3">
                    <select x-model="workflowFilter" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="">All Status</option>
                        <option value="active">Active</option>
                        <option value="completed">Completed</option>
                        <option value="paused">Paused</option>
                        <option value="failed">Failed</option>
                    </select>
                    <button class="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium transition-colors interactive">
                        <i data-lucide="plus" class="w-4 h-4 mr-2 inline"></i>
                        New Workflow
                    </button>
                </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <template x-for="workflow in filteredWorkflows" :key="workflow.workflow_id">
                    <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="selectWorkflow(workflow)">
                        <div class="flex items-start justify-between mb-4">
                            <h3 class="font-semibold text-lg group-hover:text-blue-400 transition-colors" x-text="workflow.title"></h3>
                            <div class="status-indicator">
                                <span class="px-2 py-1 text-xs rounded-full" 
                                      :class="getWorkflowStatusClass(workflow.status)" 
                                      x-text="workflow.status"></span>
                            </div>
                        </div>
                        <p class="text-gray-400 text-sm mb-4 line-clamp-2" x-text="workflow.description || workflow.goal"></p>
                        <div class="flex items-center justify-between text-sm text-gray-500">
                            <span x-text="formatRelativeTime(workflow.updated_at)"></span>
                            <div class="flex items-center space-x-4">
                                <span x-text="`${workflow.action_count || 0} actions`"></span>
                                <span x-text="`${workflow.memory_count || 0} memories`"></span>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Memories View -->
        <div x-show="dbLoaded && currentView === 'memories'" class="animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Memory System</h2>
                    <p class="text-gray-400" x-text="`${filteredMemories.length} memories found`"></p>
                </div>
                                 <div class="flex items-center space-x-3">
                     <select x-model="memoryLevelFilter" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                         <option value="">All Levels</option>
                         <option value="working">Working</option>
                         <option value="episodic">Episodic</option>
                         <option value="semantic">Semantic</option>
                         <option value="procedural">Procedural</option>
                     </select>
                     <select x-model="memorySortBy" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                         <option value="created_at">Created Date</option>
                         <option value="importance">Importance</option>
                         <option value="confidence">Confidence</option>
                         <option value="access_count">Access Count</option>
                         <option value="memory_type">Type</option>
                     </select>
                     <button @click="memorySortOrder = memorySortOrder === 'desc' ? 'asc' : 'desc'" 
                             class="p-2 bg-white/10 border border-white/20 rounded-lg hover:bg-white/20 transition-colors">
                         <i :data-lucide="memorySortOrder === 'desc' ? 'arrow-down' : 'arrow-up'" class="w-4 h-4"></i>
                     </button>
                     <input type="text" 
                            x-model="memorySearch" 
                            placeholder="Search memories..." 
                            class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm w-64">
                 </div>
            </div>
            
                         <!-- Group memories by workflow -->
             <template x-for="group in groupedMemories" :key="group.workflowId">
                 <div class="mb-8">
                     <div class="flex items-center justify-between mb-4">
                         <h3 class="text-lg font-semibold flex items-center">
                             <i data-lucide="folder" class="w-5 h-5 mr-2 text-purple-400"></i>
                             <span x-text="group.workflowTitle || 'Standalone Memories'"></span>
                             <span class="ml-2 px-2 py-1 text-xs bg-purple-500/20 text-purple-400 rounded-full" x-text="`${group.memories.length} memories`"></span>
                         </h3>
                         <button @click="group.collapsed = !group.collapsed" 
                                 class="p-1 hover:bg-white/10 rounded transition-colors">
                             <i :data-lucide="group.collapsed ? 'chevron-right' : 'chevron-down'" class="w-4 h-4"></i>
                         </button>
                     </div>
                     
                     <div x-show="!group.collapsed" 
                          x-transition:enter="transition ease-out duration-200" 
                          x-transition:enter-start="opacity-0 transform scale-95" 
                          x-transition:enter-end="opacity-100 transform scale-100">
                         <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                             <template x-for="memory in group.memories" :key="memory.memory_id">
                                 <div class="enhanced-card rounded-xl p-4 cursor-pointer group memory-card transition-all duration-300" 
                                      :class="`memory-${memory.memory_level}`"
                                      @click="selectMemory(memory)"
                                      style="transform: translateY(0); transition: transform 0.3s ease;">
                                     <div class="flex items-start justify-between mb-3">
                                         <div class="flex items-center space-x-2">
                                             <span class="px-2 py-1 text-xs rounded-full" 
                                                   :class="getMemoryLevelClass(memory.memory_level)" 
                                                   x-text="memory.memory_level"></span>
                                             <span class="text-xs text-gray-500" x-text="memory.memory_type"></span>
                                         </div>
                                         <div class="flex items-center space-x-2 text-xs text-gray-500">
                                             <span x-text="`I: ${memory.importance}/10`"></span>
                                             <span x-text="`C: ${Math.round((memory.confidence || 0) * 100)}%`"></span>
                                         </div>
                                     </div>
                                     <p class="text-gray-300 text-sm mb-3 line-clamp-3" x-text="memory.content"></p>
                                     <div class="flex items-center justify-between text-sm text-gray-500">
                                         <span x-text="formatRelativeTime(memory.created_at)"></span>
                                         <div class="flex items-center space-x-2">
                                             <i data-lucide="eye" class="w-4 h-4"></i>
                                             <span x-text="memory.access_count || 0"></span>
                                         </div>
                                     </div>
                                 </div>
                             </template>
                         </div>
                     </div>
                 </div>
             </template>
             
             <!-- Show ungrouped view if no grouping -->
             <div x-show="!groupedMemories.length" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                 <template x-for="memory in filteredMemories.slice(0, currentPage * pageSize)" :key="memory.memory_id">
                     <div class="enhanced-card rounded-2xl p-6 cursor-pointer group memory-card" 
                          :class="`memory-${memory.memory_level}`"
                          @click="selectMemory(memory)">
                         <div class="flex items-start justify-between mb-4">
                             <div class="flex items-center space-x-2">
                                 <span class="px-2 py-1 text-xs rounded-full" 
                                       :class="getMemoryLevelClass(memory.memory_level)" 
                                       x-text="memory.memory_level"></span>
                                 <span class="text-xs text-gray-500" x-text="memory.memory_type"></span>
                             </div>
                             <div class="flex items-center space-x-2 text-xs text-gray-500">
                                 <span x-text="`I: ${memory.importance}/10`"></span>
                                 <span x-text="`C: ${Math.round((memory.confidence || 0) * 100)}%`"></span>
                             </div>
                         </div>
                         <p class="text-gray-300 text-sm mb-4 line-clamp-3" x-text="memory.content"></p>
                         <div class="flex items-center justify-between text-sm text-gray-500">
                             <span x-text="formatRelativeTime(memory.created_at)"></span>
                             <div class="flex items-center space-x-2">
                                 <i data-lucide="eye" class="w-4 h-4"></i>
                                 <span x-text="memory.access_count || 0"></span>
                             </div>
                         </div>
                     </div>
                 </template>
             </div>
            
            <!-- Load more button -->
            <div x-show="filteredMemories.length > currentPage * pageSize" class="text-center mt-8">
                <button @click="loadMore()" 
                        class="px-6 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg font-medium transition-colors interactive">
                    Load More Memories
                </button>
            </div>
                 </div>

         <!-- Actions View -->
         <div x-show="dbLoaded && currentView === 'actions'" class="animate-slide-in">
             <div class="flex items-center justify-between mb-6">
                 <div>
                     <h2 class="text-2xl font-bold">Actions</h2>
                     <p class="text-gray-400" x-text="`${filteredActions.length} actions found`"></p>
                 </div>
                 <div class="flex items-center space-x-3">
                     <select x-model="actionStatusFilter" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                         <option value="">All Status</option>
                         <option value="completed">Completed</option>
                         <option value="in_progress">In Progress</option>
                         <option value="failed">Failed</option>
                         <option value="planned">Planned</option>
                     </select>
                     <select x-model="actionTypeFilter" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                         <option value="">All Types</option>
                         <option value="tool_use">Tool Use</option>
                         <option value="reasoning">Reasoning</option>
                         <option value="planning">Planning</option>
                         <option value="analysis">Analysis</option>
                         <option value="research">Research</option>
                     </select>
                     <input type="text" 
                            x-model="actionSearch" 
                            placeholder="Search actions..." 
                            class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm w-64">
                 </div>
             </div>
             
             <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                 <template x-for="action in filteredActions.slice(0, currentPage * pageSize)" :key="action.action_id">
                     <div class="enhanced-card rounded-2xl p-6 cursor-pointer group" @click="selectAction(action)">
                         <div class="flex items-start justify-between mb-4">
                             <div class="flex items-center space-x-2">
                                 <span class="px-2 py-1 text-xs rounded-full" 
                                       :class="getActionStatusClass(action.status)" 
                                       x-text="action.status"></span>
                                 <span class="text-xs text-gray-500" x-text="action.action_type"></span>
                             </div>
                             <div class="text-xs text-gray-500" x-text="formatDuration(action.started_at, action.completed_at)"></div>
                         </div>
                         <h3 class="font-medium mb-2 group-hover:text-orange-400 transition-colors" x-text="action.title || action.tool_name || action.action_type"></h3>
                         <p class="text-gray-400 text-sm mb-4 line-clamp-2" x-text="action.reasoning || action.summary || 'No description available'"></p>
                         <div class="flex items-center justify-between text-sm text-gray-500">
                             <span x-text="formatRelativeTime(action.started_at)"></span>
                             <div class="flex items-center space-x-2">
                                 <i :data-lucide="getActionIcon(action.action_type)" class="w-4 h-4"></i>
                                 <span x-text="action.workflow_id ? 'Workflow' : 'Standalone'"></span>
                             </div>
                         </div>
                     </div>
                 </template>
             </div>
             
             <!-- Load more button -->
             <div x-show="filteredActions.length > currentPage * pageSize" class="text-center mt-8">
                 <button @click="loadMore()" 
                         class="px-6 py-3 bg-orange-600 hover:bg-orange-700 rounded-lg font-medium transition-colors interactive">
                     Load More Actions
                 </button>
             </div>
         </div>

         <!-- Analytics View -->
        <div x-show="dbLoaded && currentView === 'analytics'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Analytics Dashboard</h2>
                    <p class="text-gray-400">Visualize your UMS data patterns</p>
                </div>
            </div>
            
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="chart-container">
                    <h3 class="text-lg font-semibold mb-4">Memory Level Distribution</h3>
                    <canvas x-ref="memoryLevelChart" class="w-full h-64"></canvas>
                </div>
                
                <div class="chart-container">
                    <h3 class="text-lg font-semibold mb-4">Memory Type Breakdown</h3>
                    <canvas x-ref="memoryTypeChart" class="w-full h-64"></canvas>
                </div>
                
                <div class="chart-container">
                    <h3 class="text-lg font-semibold mb-4">Workflow Status</h3>
                    <canvas x-ref="workflowStatusChart" class="w-full h-64"></canvas>
                </div>
                
                <div class="chart-container">
                    <h3 class="text-lg font-semibold mb-4">Activity Timeline</h3>
                    <canvas x-ref="activityChart" class="w-full h-64"></canvas>
                </div>
            </div>
        </div>

        <!-- Graph View -->
        <div x-show="dbLoaded && currentView === 'graph'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Memory Network Graph</h2>
                    <p class="text-gray-400" x-text="`${graphData.nodes?.length || 0} memories • ${graphData.links?.length || 0} connections`"></p>
                </div>
                <div class="flex items-center space-x-3">
                    <select x-model="graphSettings.layout" @change="updateGraphLayout()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="force">Force Layout</option>
                        <option value="hierarchical">Hierarchical</option>
                        <option value="circular">Circular</option>
                        <option value="cluster">Clustered</option>
                    </select>
                    <select x-model="graphSettings.colorBy" @change="updateGraphColors()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="memory_level">Memory Level</option>
                        <option value="memory_type">Memory Type</option>
                        <option value="workflow">Workflow</option>
                        <option value="importance">Importance</option>
                    </select>
                    <button @click="resetGraphView()" class="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded-lg text-sm font-medium transition-colors interactive">
                        <i data-lucide="refresh-cw" class="w-4 h-4 mr-2 inline"></i>
                        Reset View
                    </button>
                </div>
            </div>
            
            <div class="grid grid-cols-12 gap-6">
                <!-- Graph Container -->
                <div class="col-span-12 lg:col-span-9">
                    <div class="graph-container" style="height: 70vh;">
                        <!-- Graph Controls -->
                        <div class="graph-controls">
                            <div class="enhanced-card p-3 space-y-2">
                                <div class="text-xs text-gray-400 mb-2">Physics</div>
                                <div class="flex items-center space-x-2">
                                    <label class="text-xs text-gray-300">Strength:</label>
                                    <input type="range" x-model.number="graphSettings.forceStrength" @input="updatePhysics()" 
                                           min="-100" max="100" step="10" class="w-16 h-1 bg-gray-600 rounded-lg appearance-none slider">
                                </div>
                                <div class="flex items-center space-x-2">
                                    <label class="text-xs text-gray-300">Distance:</label>
                                    <input type="range" x-model.number="graphSettings.linkDistance" @input="updatePhysics()" 
                                           min="10" max="200" step="10" class="w-16 h-1 bg-gray-600 rounded-lg appearance-none slider">
                                </div>
                                <button @click="togglePhysics()" class="w-full px-2 py-1 text-xs rounded bg-blue-600 hover:bg-blue-700 transition-colors"
                                        :class="{'bg-red-600 hover:bg-red-700': !graphSettings.physicsEnabled}">
                                    <span x-text="graphSettings.physicsEnabled ? 'Pause' : 'Resume'"></span>
                                </button>
                            </div>
                            
                            <div class="enhanced-card p-3 space-y-2">
                                <div class="text-xs text-gray-400 mb-2">Filters</div>
                                <div class="space-y-1">
                                    <template x-for="level in ['working', 'episodic', 'semantic', 'procedural']" :key="level">
                                        <label class="flex items-center text-xs">
                                            <input type="checkbox" :checked="graphSettings.visibleLevels.includes(level)" 
                                                   @change="toggleMemoryLevel(level)" class="mr-1 rounded">
                                            <span class="capitalize" x-text="level"></span>
                                        </label>
                                    </template>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Graph Legend -->
                        <div x-show="graphSettings.showLegend" class="graph-legend">
                            <div class="text-sm font-semibold mb-3">Legend</div>
                            <template x-for="item in currentLegend" :key="item.key">
                                <div class="legend-item">
                                    <div class="legend-color" :style="`background-color: ${item.color}`"></div>
                                    <span x-text="item.label"></span>
                                </div>
                            </template>
                            <div class="mt-3 pt-3 border-t border-white/20">
                                <div class="text-xs text-gray-400 mb-2">Link Types</div>
                                <div class="text-xs space-y-1">
                                    <div class="flex items-center">
                                        <div class="w-4 h-0.5 bg-blue-400 mr-2"></div>
                                        <span>References</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-4 h-0.5 bg-green-400 mr-2"></div>
                                        <span>Causal</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-4 h-0.5 bg-purple-400 mr-2"></div>
                                        <span>Similarity</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Main Graph SVG -->
                        <svg x-ref="graphSvg" class="graph-svg"></svg>
                        
                        <!-- Graph Tooltip -->
                        <div x-show="graphTooltip.visible" 
                             x-transition:enter="transition ease-out duration-200" 
                             x-transition:enter-start="opacity-0 scale-95" 
                             x-transition:enter-end="opacity-100 scale-100"
                             class="graph-tooltip"
                             :style="`left: ${graphTooltip.x}px; top: ${graphTooltip.y}px;`">
                            <div class="font-semibold mb-1" x-text="graphTooltip.title"></div>
                            <div class="text-xs text-gray-300 mb-2" x-text="graphTooltip.subtitle"></div>
                            <div class="text-sm" x-text="graphTooltip.content"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Sidebar -->
                <div class="col-span-12 lg:col-span-3">
                    <div class="graph-sidebar">
                        <div x-show="!selectedGraphNode" class="text-center text-gray-400">
                            <i data-lucide="mouse-pointer-click" class="w-12 h-12 mx-auto mb-4 opacity-50"></i>
                            <p class="text-sm">Click on a memory node to view details and explore connections</p>
                            
                            <div class="mt-6 p-4 bg-white/5 rounded-lg">
                                <h4 class="font-semibold mb-3">Graph Stats</h4>
                                <div class="space-y-2 text-sm">
                                    <div class="flex justify-between">
                                        <span>Nodes:</span>
                                        <span x-text="graphData.nodes?.length || 0"></span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span>Links:</span>
                                        <span x-text="graphData.links?.length || 0"></span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span>Clusters:</span>
                                        <span x-text="graphClusters.length"></span>
                                    </div>
                                    <div class="flex justify-between">
                                        <span>Density:</span>
                                        <span x-text="calculateGraphDensity()"></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div x-show="selectedGraphNode" class="space-y-4">
                            <div class="flex items-center justify-between">
                                <h4 class="font-semibold">Memory Details</h4>
                                <button @click="selectedGraphNode = null" class="p-1 hover:bg-white/10 rounded transition-colors">
                                    <i data-lucide="x" class="w-4 h-4"></i>
                                </button>
                            </div>
                            
                            <div x-show="selectedGraphNode" class="space-y-3">
                                <div>
                                    <div class="text-xs text-gray-400 mb-1">Type & Level</div>
                                    <div class="flex items-center space-x-2">
                                        <span class="px-2 py-1 text-xs rounded-full" 
                                              :class="getMemoryLevelClass(selectedGraphNode?.memory_level)" 
                                              x-text="selectedGraphNode?.memory_level"></span>
                                        <span class="text-sm text-gray-300" x-text="selectedGraphNode?.memory_type"></span>
                                    </div>
                                </div>
                                
                                <div>
                                    <div class="text-xs text-gray-400 mb-1">Content</div>
                                    <div class="text-sm bg-white/5 p-3 rounded-lg max-h-32 overflow-y-auto">
                                        <p x-text="selectedGraphNode?.content"></p>
                                    </div>
                                </div>
                                
                                <div class="grid grid-cols-2 gap-3">
                                    <div>
                                        <div class="text-xs text-gray-400">Importance</div>
                                        <div class="text-lg font-semibold" x-text="selectedGraphNode?.importance + '/10'"></div>
                                    </div>
                                    <div>
                                        <div class="text-xs text-gray-400">Confidence</div>
                                        <div class="text-lg font-semibold" x-text="Math.round((selectedGraphNode?.confidence || 0) * 100) + '%'"></div>
                                    </div>
                                </div>
                                
                                <div>
                                    <div class="text-xs text-gray-400 mb-2">Connections</div>
                                    <div class="space-y-2 max-h-40 overflow-y-auto">
                                        <template x-for="connection in getNodeConnections(selectedGraphNode)" :key="connection.id">
                                            <div class="flex items-center justify-between p-2 bg-white/5 rounded-lg hover:bg-white/10 transition-colors cursor-pointer"
                                                 @click="focusOnNode(connection.target)">
                                                <div class="flex-1 min-w-0">
                                                    <div class="text-sm font-medium truncate" x-text="connection.target.memory_type"></div>
                                                    <div class="text-xs text-gray-400 truncate" x-text="connection.target.content.substring(0, 30) + '...'"></div>
                                                </div>
                                                <div class="text-xs text-gray-500" x-text="connection.link_type"></div>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                                
                                <div class="flex space-x-2">
                                    <button @click="selectMemory(selectedGraphNode); showMemoryModal = true" 
                                            class="flex-1 px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium transition-colors">
                                        View Details
                                    </button>
                                    <button @click="expandNeighborhood(selectedGraphNode)" 
                                            class="flex-1 px-3 py-2 bg-cyan-600 hover:bg-cyan-700 rounded-lg text-sm font-medium transition-colors">
                                        Expand
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Goals View -->
        <div x-show="dbLoaded && currentView === 'goals'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Goal Hierarchy</h2>
                    <p class="text-gray-400" x-text="`${goalStats.total} goals • ${goalStats.completionRate}% completion rate`"></p>
                </div>
                <div class="flex items-center space-x-3">
                    <select x-model="goalFilter" @change="filterGoals()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="">All Goals</option>
                        <option value="active">Active</option>
                        <option value="completed">Completed</option>
                        <option value="pending">Pending</option>
                        <option value="overdue">Overdue</option>
                    </select>
                    <select x-model="goalTreeSettings.groupBy" @change="rebuildGoalTree()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="none">No Grouping</option>
                        <option value="priority">By Priority</option>
                        <option value="status">By Status</option>
                        <option value="owner">By Owner</option>
                    </select>
                    <button @click="expandAllGoals()" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-lg text-sm font-medium transition-colors interactive">
                        <i data-lucide="expand" class="w-4 h-4 mr-2 inline"></i>
                        Expand All
                    </button>
                    <button @click="showNewGoalModal()" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-lg text-sm font-medium transition-colors interactive">
                        <i data-lucide="plus" class="w-4 h-4 mr-2 inline"></i>
                        New Goal
                    </button>
                </div>
            </div>
            
            <!-- Goal Statistics -->
            <div class="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-yellow-400" x-text="goalStats.total"></div>
                    <div class="text-xs text-gray-400">Total Goals</div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-green-400" x-text="goalStats.completed"></div>
                    <div class="text-xs text-gray-400">Completed</div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-blue-400" x-text="goalStats.inProgress"></div>
                    <div class="text-xs text-gray-400">In Progress</div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-gray-400" x-text="goalStats.pending"></div>
                    <div class="text-xs text-gray-400">Pending</div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-red-400" x-text="goalStats.overdue"></div>
                    <div class="text-xs text-gray-400">Overdue</div>
                </div>
            </div>
            
            <div class="grid grid-cols-12 gap-6">
                <!-- Goal Tree Container -->
                <div class="col-span-12 lg:col-span-9">
                    <div class="enhanced-card rounded-2xl p-6" style="min-height: 70vh;">
                        <!-- Tree Controls -->
                        <div class="flex items-center justify-between mb-6">
                            <div class="flex items-center space-x-4">
                                <div class="flex items-center space-x-2">
                                    <label class="text-sm text-gray-400">Show:</label>
                                    <label class="flex items-center text-sm">
                                        <input type="checkbox" x-model="goalTreeSettings.showCompleted" @change="rebuildGoalTree()" class="mr-1 rounded">
                                        <span>Completed</span>
                                    </label>
                                    <label class="flex items-center text-sm">
                                        <input type="checkbox" x-model="goalTreeSettings.showProgress" @change="rebuildGoalTree()" class="mr-1 rounded">
                                        <span>Progress</span>
                                    </label>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <label class="text-sm text-gray-400">Sort:</label>
                                    <select x-model="goalTreeSettings.sortBy" @change="rebuildGoalTree()" class="bg-white/10 border border-white/20 rounded px-2 py-1 text-sm">
                                        <option value="created">Created Date</option>
                                        <option value="priority">Priority</option>
                                        <option value="progress">Progress</option>
                                        <option value="title">Title</option>
                                    </select>
                                </div>
                            </div>
                            <div class="flex items-center space-x-2">
                                <input type="text" 
                                       x-model="goalSearch" 
                                       @input="filterGoals()"
                                       placeholder="Search goals..." 
                                       class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm w-48">
                                <button @click="collapseAllGoals()" class="p-2 hover:bg-white/10 rounded-lg transition-colors">
                                    <i data-lucide="minimize-2" class="w-4 h-4"></i>
                                </button>
                                <button @click="resetGoalTreeView()" class="p-2 hover:bg-white/10 rounded-lg transition-colors">
                                    <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Goal Tree SVG Container -->
                        <div class="relative" style="height: calc(70vh - 8rem);">
                            <svg x-ref="goalTreeSvg" class="w-full h-full cursor-grab" style="background: rgba(0,0,0,0.1); border-radius: 12px;"></svg>
                            
                            <!-- Tree Legend -->
                            <div class="absolute top-4 right-4 bg-black/80 backdrop-blur-lg rounded-lg p-3 min-w-[200px]">
                                <div class="text-sm font-semibold mb-3 text-white">Goal Status</div>
                                <div class="space-y-2 text-xs">
                                    <div class="flex items-center">
                                        <div class="w-3 h-3 rounded-full bg-green-400 mr-2"></div>
                                        <span class="text-white">Completed</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-3 h-3 rounded-full bg-blue-400 mr-2"></div>
                                        <span class="text-white">In Progress</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-3 h-3 rounded-full bg-gray-400 mr-2"></div>
                                        <span class="text-white">Pending</span>
                                    </div>
                                    <div class="flex items-center">
                                        <div class="w-3 h-3 rounded-full bg-red-400 mr-2"></div>
                                        <span class="text-white">Overdue</span>
                                    </div>
                                </div>
                                <div class="mt-3 pt-3 border-t border-white/20">
                                    <div class="text-sm font-semibold mb-2 text-white">Priority</div>
                                    <div class="space-y-1 text-xs">
                                        <div class="flex items-center">
                                            <div class="w-2 h-2 rounded-full bg-red-500 mr-2"></div>
                                            <span class="text-white">High</span>
                                        </div>
                                        <div class="flex items-center">
                                            <div class="w-2 h-2 rounded-full bg-yellow-500 mr-2"></div>
                                            <span class="text-white">Medium</span>
                                        </div>
                                        <div class="flex items-center">
                                            <div class="w-2 h-2 rounded-full bg-blue-500 mr-2"></div>
                                            <span class="text-white">Low</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Drop Zones for Drag & Drop -->
                            <div x-show="isDragging" class="absolute inset-0 pointer-events-none">
                                <div class="absolute top-4 left-4 w-48 h-16 border-2 border-dashed border-yellow-400 rounded-lg bg-yellow-400/10 flex items-center justify-center pointer-events-auto"
                                     @drop.prevent="handleGoalDrop($event, 'root')"
                                     @dragover.prevent="highlightDropZone($event, 'root')"
                                     @dragleave.prevent="unhighlightDropZone($event)">
                                    <span class="text-yellow-400 text-sm font-medium">Make Root Goal</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Goal Details Sidebar -->
                <div class="col-span-12 lg:col-span-3">
                    <div class="enhanced-card rounded-2xl p-6 sticky top-24" style="max-height: calc(100vh - 8rem); overflow-y: auto;">
                        <div x-show="!selectedGoal" class="text-center text-gray-400">
                            <i data-lucide="target" class="w-12 h-12 mx-auto mb-4 opacity-50"></i>
                            <h4 class="font-semibold mb-2">No Goal Selected</h4>
                            <p class="text-sm">Click on a goal in the tree to view details and manage dependencies</p>
                            
                            <div class="mt-6 space-y-3">
                                <button @click="showNewGoalModal()" class="w-full px-4 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-lg text-sm font-medium transition-colors">
                                    <i data-lucide="plus" class="w-4 h-4 mr-2 inline"></i>
                                    Create New Goal
                                </button>
                                <button @click="importGoalsFromMemories()" class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium transition-colors">
                                    <i data-lucide="download" class="w-4 h-4 mr-2 inline"></i>
                                    Import from Memories
                                </button>
                            </div>
                        </div>
                        
                        <div x-show="selectedGoal" class="space-y-4">
                            <div class="flex items-center justify-between">
                                <h4 class="font-semibold">Goal Details</h4>
                                <div class="flex items-center space-x-2">
                                    <button @click="editGoal(selectedGoal)" class="p-1 hover:bg-white/10 rounded transition-colors">
                                        <i data-lucide="edit-2" class="w-4 h-4"></i>
                                    </button>
                                    <button @click="selectedGoal = null" class="p-1 hover:bg-white/10 rounded transition-colors">
                                        <i data-lucide="x" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            
                            <div x-show="selectedGoal" class="space-y-4">
                                <div>
                                    <h5 class="font-medium mb-2" x-text="selectedGoal?.title"></h5>
                                    <p class="text-sm text-gray-300 mb-3" x-text="selectedGoal?.description"></p>
                                    
                                    <div class="grid grid-cols-2 gap-3 text-sm">
                                        <div>
                                            <span class="text-gray-400">Status:</span>
                                            <div class="mt-1">
                                                <span class="px-2 py-1 text-xs rounded-full" 
                                                      :class="getGoalStatusClass(selectedGoal?.status)" 
                                                      x-text="selectedGoal?.status"></span>
                                            </div>
                                        </div>
                                        <div>
                                            <span class="text-gray-400">Priority:</span>
                                            <div class="mt-1">
                                                <span class="px-2 py-1 text-xs rounded-full" 
                                                      :class="getGoalPriorityClass(selectedGoal?.priority)" 
                                                      x-text="selectedGoal?.priority"></span>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div x-show="selectedGoal?.progress !== undefined" class="mt-3">
                                        <div class="flex items-center justify-between text-sm mb-1">
                                            <span class="text-gray-400">Progress</span>
                                            <span x-text="`${selectedGoal?.progress || 0}%`"></span>
                                        </div>
                                        <div class="w-full bg-gray-700 rounded-full h-2">
                                            <div class="bg-yellow-400 h-2 rounded-full transition-all duration-300" 
                                                 :style="`width: ${selectedGoal?.progress || 0}%`"></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div x-show="selectedGoal?.due_date">
                                    <span class="text-gray-400 text-sm">Due Date:</span>
                                    <div class="text-sm" x-text="formatDate(selectedGoal?.due_date)"></div>
                                </div>
                                
                                <div x-show="selectedGoal?.dependencies?.length > 0">
                                    <h6 class="font-medium mb-2">Dependencies</h6>
                                    <div class="space-y-2 max-h-24 overflow-y-auto">
                                        <template x-for="dep in selectedGoal?.dependencies" :key="dep.id">
                                            <div class="flex items-center justify-between p-2 bg-white/5 rounded-lg text-sm">
                                                <span x-text="dep.title"></span>
                                                <span class="text-xs" :class="getGoalStatusClass(dep.status)" x-text="dep.status"></span>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                                
                                <div x-show="selectedGoal?.subgoals?.length > 0">
                                    <h6 class="font-medium mb-2">Subgoals</h6>
                                    <div class="space-y-2 max-h-32 overflow-y-auto">
                                        <template x-for="subgoal in selectedGoal?.subgoals" :key="subgoal.id">
                                            <div class="flex items-center justify-between p-2 bg-white/5 rounded-lg text-sm cursor-pointer hover:bg-white/10 transition-colors"
                                                 @click="selectGoal(subgoal)">
                                                <span x-text="subgoal.title"></span>
                                                <span class="text-xs" :class="getGoalStatusClass(subgoal.status)" x-text="subgoal.status"></span>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                                
                                <div class="space-y-2 pt-4 border-t border-white/10">
                                    <button @click="addSubgoal(selectedGoal)" class="w-full px-3 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-lg text-sm font-medium transition-colors">
                                        <i data-lucide="plus" class="w-4 h-4 mr-2 inline"></i>
                                        Add Subgoal
                                    </button>
                                    <button @click="markGoalComplete(selectedGoal)" 
                                            x-show="selectedGoal?.status !== 'completed'"
                                            class="w-full px-3 py-2 bg-green-600 hover:bg-green-700 rounded-lg text-sm font-medium transition-colors">
                                        <i data-lucide="check" class="w-4 h-4 mr-2 inline"></i>
                                        Mark Complete
                                    </button>
                                    <button @click="deleteGoal(selectedGoal)" class="w-full px-3 py-2 bg-red-600 hover:bg-red-700 rounded-lg text-sm font-medium transition-colors">
                                        <i data-lucide="trash-2" class="w-4 h-4 mr-2 inline"></i>
                                        Delete Goal
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Thought Chains View -->
        <div x-show="dbLoaded && currentView === 'thought-chains'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Thought Chain Flow Diagrams</h2>
                    <p class="text-gray-400" x-text="`${thoughtChainStats.totalChains} chains • ${thoughtChainStats.totalThoughts} thoughts • ${thoughtChainStats.branchingPoints} branches`"></p>
                </div>
                <div class="flex items-center space-x-3">
                    <select x-model="chainFilter" @change="filterThoughtChains()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="">All Chains</option>
                        <option value="workflow">By Workflow</option>
                        <option value="recent">Recent Only</option>
                        <option value="complex">Complex (5+ thoughts)</option>
                        <option value="branching">With Branches</option>
                    </select>
                    <button @click="resetThoughtChainView()" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-sm font-medium transition-colors interactive">
                        <i data-lucide="refresh-cw" class="w-4 h-4 mr-2 inline"></i>
                        Reset View
                    </button>
                    <button @click="exportThoughtChain()" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-sm font-medium transition-colors interactive">
                        <i data-lucide="download" class="w-4 h-4 mr-2 inline"></i>
                        Export
                    </button>
                </div>
            </div>
            
            <!-- Chain Statistics -->
            <div class="chain-stats">
                <div class="chain-stat">
                    <div class="chain-stat-value" x-text="thoughtChainStats.totalChains"></div>
                    <div class="chain-stat-label">Total Chains</div>
                </div>
                <div class="chain-stat">
                    <div class="chain-stat-value" x-text="thoughtChainStats.totalThoughts"></div>
                    <div class="chain-stat-label">Total Thoughts</div>
                </div>
                <div class="chain-stat">
                    <div class="chain-stat-value" x-text="thoughtChainStats.avgChainLength.toFixed(1)"></div>
                    <div class="chain-stat-label">Avg Chain Length</div>
                </div>
                <div class="chain-stat">
                    <div class="chain-stat-value" x-text="thoughtChainStats.branchingPoints"></div>
                    <div class="chain-stat-label">Branching Points</div>
                </div>
            </div>
            
            <div class="grid grid-cols-12 gap-6">
                <!-- Main Diagram Container -->
                <div class="col-span-12 lg:col-span-9">
                    <div class="thought-chain-container">
                        <!-- Diagram Area -->
                        <div x-show="currentChain" class="mermaid-container">
                            <div x-ref="mermaidContainer" class="w-full h-full"></div>
                        </div>
                        
                        <!-- Empty State -->
                        <div x-show="!currentChain" class="flex items-center justify-center h-full">
                            <div class="text-center text-gray-400">
                                <i data-lucide="git-branch-plus" class="w-16 h-16 mx-auto mb-4 opacity-50"></i>
                                <h3 class="text-xl font-semibold mb-2">No Thought Chain Selected</h3>
                                <p class="text-sm">Select a thought chain from the sidebar to view its flow diagram</p>
                            </div>
                        </div>
                        
                        <!-- Timeline Scrubber -->
                        <div x-show="currentChain" class="timeline-scrubber">
                            <!-- Playback Controls -->
                            <div class="playback-controls">
                                <button @click="stepBackward()" class="playback-btn secondary" title="Previous Step">
                                    <i data-lucide="skip-back" class="w-5 h-5"></i>
                                </button>
                                <button @click="togglePlayback()" class="playback-btn" :title="isPlaybackActive ? 'Pause' : 'Play'">
                                    <i :data-lucide="isPlaybackActive ? 'pause' : 'play'" class="w-6 h-6"></i>
                                </button>
                                <button @click="stepForward()" class="playback-btn secondary" title="Next Step">
                                    <i data-lucide="skip-forward" class="w-5 h-5"></i>
                                </button>
                                
                                <!-- Speed Control -->
                                <div class="speed-control">
                                    <span class="text-xs text-gray-400">Speed:</span>
                                    <button @click="setPlaybackSpeed(0.5)" 
                                            :class="{'active': playbackSpeed === 0.5}" 
                                            class="speed-btn">0.5x</button>
                                    <button @click="setPlaybackSpeed(1)" 
                                            :class="{'active': playbackSpeed === 1}" 
                                            class="speed-btn">1x</button>
                                    <button @click="setPlaybackSpeed(2)" 
                                            :class="{'active': playbackSpeed === 2}" 
                                            class="speed-btn">2x</button>
                                    <button @click="setPlaybackSpeed(3)" 
                                            :class="{'active': playbackSpeed === 3}" 
                                            class="speed-btn">3x</button>
                                </div>
                            </div>
                            
                            <!-- Timeline Markers -->
                            <div class="timeline-markers">
                                <template x-for="(thought, index) in thoughtsInCurrentChain" :key="thought.memory_id">
                                    <div class="timeline-marker" 
                                         :class="{
                                             'current': index === currentThoughtIndex,
                                             'major': thought.hasChildren || thought.isBranch
                                         }"
                                         :style="`left: ${(index / (thoughtsInCurrentChain.length - 1)) * 100}%`"
                                         @click="jumpToThought(index)"
                                         :title="`${thought.memory_type} - ${thought.content.substring(0, 50)}...`">
                                    </div>
                                </template>
                            </div>
                            
                            <!-- Timeline Slider -->
                            <input type="range" 
                                   x-model.number="thoughtTimelinePosition" 
                                   @input="seekToPosition($event.target.value)"
                                   :min="0" 
                                   :max="thoughtTimelineLength - 1" 
                                   :step="1"
                                   class="timeline-slider">
                            
                            <!-- Timeline Info -->
                            <div class="flex items-center justify-between mt-3 text-sm text-gray-400">
                                <div>
                                    <span x-text="`Step ${currentThoughtIndex + 1} of ${thoughtsInCurrentChain.length}`"></span>
                                    <span x-show="thoughtsInCurrentChain[currentThoughtIndex]" 
                                          class="ml-2" 
                                          x-text="`${thoughtsInCurrentChain[currentThoughtIndex]?.memory_type}`"></span>
                                </div>
                                <div x-show="thoughtsInCurrentChain[currentThoughtIndex]">
                                    <span x-text="formatDate(thoughtsInCurrentChain[currentThoughtIndex]?.created_at)"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Sidebar -->
                <div class="col-span-12 lg:col-span-3">
                    <div class="chain-sidebar">
                        <!-- Chain List -->
                        <div x-show="!currentChain" class="space-y-4">
                            <h4 class="font-semibold flex items-center">
                                <i data-lucide="list" class="w-4 h-4 mr-2"></i>
                                Available Chains
                            </h4>
                            
                            <div class="space-y-2 max-h-80 overflow-y-auto">
                                <template x-for="chain in thoughtChains" :key="chain.id">
                                    <div class="p-3 bg-white/5 rounded-lg hover:bg-white/10 transition-colors cursor-pointer group"
                                         @click="selectThoughtChain(chain)">
                                        <div class="flex items-center justify-between mb-2">
                                            <span class="text-sm font-medium text-indigo-400" x-text="chain.title"></span>
                                            <span class="text-xs text-gray-500" x-text="`${chain.thoughts.length} thoughts`"></span>
                                        </div>
                                        <p class="text-xs text-gray-400 line-clamp-2" x-text="chain.description"></p>
                                        <div class="flex items-center justify-between mt-2 text-xs text-gray-500">
                                            <span x-text="formatRelativeTime(chain.created_at)"></span>
                                            <div class="flex items-center space-x-2">
                                                <span x-show="chain.hasBranches" title="Has branches">
                                                    <i data-lucide="git-branch" class="w-3 h-3"></i>
                                                </span>
                                                <span x-text="chain.complexity" :class="{
                                                    'text-green-400': chain.complexity === 'Simple',
                                                    'text-yellow-400': chain.complexity === 'Medium',
                                                    'text-red-400': chain.complexity === 'Complex'
                                                }"></span>
                                            </div>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </div>
                        
                        <!-- Current Chain Details -->
                        <div x-show="currentChain" class="space-y-4">
                            <div class="flex items-center justify-between">
                                <h4 class="font-semibold">Chain Details</h4>
                                <button @click="currentChain = null; stopPlayback()" 
                                        class="p-1 hover:bg-white/10 rounded transition-colors">
                                    <i data-lucide="x" class="w-4 h-4"></i>
                                </button>
                            </div>
                            
                            <div class="chain-metadata">
                                <h5 class="font-medium mb-2" x-text="currentChain?.title"></h5>
                                <p class="text-sm text-gray-300 mb-3" x-text="currentChain?.description"></p>
                                
                                <div class="grid grid-cols-2 gap-2 text-xs">
                                    <div>
                                        <span class="text-gray-400">Thoughts:</span>
                                        <span x-text="currentChain?.thoughts.length"></span>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">Duration:</span>
                                        <span x-text="calculateChainDuration(currentChain)"></span>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">Branches:</span>
                                        <span x-text="currentChain?.branchCount || 0"></span>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">Complexity:</span>
                                        <span x-text="currentChain?.complexity" :class="{
                                            'text-green-400': currentChain?.complexity === 'Simple',
                                            'text-yellow-400': currentChain?.complexity === 'Medium',
                                            'text-red-400': currentChain?.complexity === 'Complex'
                                        }"></span>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Current Thought Details -->
                            <div x-show="thoughtsInCurrentChain[currentThoughtIndex]" class="thought-details">
                                <h6 class="font-medium mb-2">Current Thought</h6>
                                <div class="space-y-2">
                                    <div class="flex items-center space-x-2">
                                        <span class="px-2 py-1 text-xs rounded-full bg-indigo-500/20 text-indigo-400">
                                            <span x-text="thoughtsInCurrentChain[currentThoughtIndex]?.memory_type"></span>
                                        </span>
                                        <span class="text-xs text-gray-500" 
                                              x-text="`${currentThoughtIndex + 1}/${thoughtsInCurrentChain.length}`"></span>
                                    </div>
                                    <p class="text-sm" x-text="thoughtsInCurrentChain[currentThoughtIndex]?.content"></p>
                                    
                                    <div x-show="thoughtsInCurrentChain[currentThoughtIndex]?.hasChildren" 
                                         class="branch-indicator">
                                        <span class="text-xs text-purple-400">Branching Point</span>
                                    </div>
                                </div>
                                
                                <button @click="selectThought(thoughtsInCurrentChain[currentThoughtIndex]); showThoughtModal = true" 
                                        class="w-full mt-3 px-3 py-2 bg-indigo-600 hover:bg-indigo-700 rounded-lg text-sm font-medium transition-colors">
                                    View Full Details
                                </button>
                            </div>
                            
                            <!-- Chain Navigation -->
                            <div class="space-y-2">
                                <h6 class="font-medium text-sm">Quick Navigation</h6>
                                <div class="grid grid-cols-2 gap-2">
                                    <button @click="jumpToFirstBranch()" 
                                            class="px-2 py-1 text-xs bg-purple-600/20 text-purple-400 rounded hover:bg-purple-600/30 transition-colors">
                                        First Branch
                                    </button>
                                    <button @click="jumpToLastThought()" 
                                            class="px-2 py-1 text-xs bg-blue-600/20 text-blue-400 rounded hover:bg-blue-600/30 transition-colors">
                                        Last Thought
                                    </button>
                                    <button @click="jumpToKeyDecision()" 
                                            class="px-2 py-1 text-xs bg-green-600/20 text-green-400 rounded hover:bg-green-600/30 transition-colors">
                                        Key Decision
                                    </button>
                                    <button @click="jumpToConclusion()" 
                                            class="px-2 py-1 text-xs bg-orange-600/20 text-orange-400 rounded hover:bg-orange-600/30 transition-colors">
                                        Conclusion
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Semantic Search View -->
        <div x-show="dbLoaded && currentView === 'semantic-search'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold">Semantic Search</h2>
                    <p class="text-gray-400">Advanced UMS-powered search with vector similarity and intelligent clustering</p>
                </div>
                <div class="flex items-center space-x-3">
                    <button @click="clearSemanticSearch()" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="x" class="w-4 h-4 mr-2 inline"></i>
                        Clear
                    </button>
                    <button @click="saveCurrentSearch()" class="px-4 py-2 bg-rose-600 hover:bg-rose-700 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="bookmark" class="w-4 h-4 mr-2 inline"></i>
                        Save Search
                    </button>
                </div>
            </div>
            
            <!-- Search Interface -->
            <div class="enhanced-card rounded-2xl p-6">
                <div class="space-y-4">
                    <!-- Main Search Bar -->
                    <div class="relative">
                        <input type="text" 
                               x-model="semanticQuery" 
                               @input="debounceSemanticSearch()"
                               @keydown.enter="performSemanticSearch()"
                               placeholder="Ask a question or describe what you're looking for..." 
                               class="w-full pl-12 pr-20 py-4 bg-white/10 border border-white/20 rounded-xl text-lg focus:outline-none focus:border-rose-400 transition-colors">
                        <i data-lucide="search" class="absolute left-4 top-1/2 transform -translate-y-1/2 w-5 h-5 text-gray-400"></i>
                        <button @click="performSemanticSearch()" 
                                :disabled="!semanticQuery || isSearching"
                                class="absolute right-2 top-1/2 transform -translate-y-1/2 px-4 py-2 bg-rose-600 hover:bg-rose-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                            <span x-show="!isSearching">Search</span>
                            <span x-show="isSearching" class="flex items-center">
                                <div class="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin mr-2"></div>
                                Searching...
                            </span>
                        </button>
                    </div>
                    
                    <!-- Search Mode Tabs -->
                    <div class="flex space-x-2">
                        <button @click="searchMode = 'hybrid'" 
                                :class="{'bg-rose-600 text-white': searchMode === 'hybrid', 'bg-white/10 text-gray-300 hover:bg-white/20': searchMode !== 'hybrid'}"
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                            <i data-lucide="brain" class="w-4 h-4 mr-2 inline"></i>
                            Hybrid Search
                        </button>
                        <button @click="searchMode = 'semantic'" 
                                :class="{'bg-rose-600 text-white': searchMode === 'semantic', 'bg-white/10 text-gray-300 hover:bg-white/20': searchMode !== 'semantic'}"
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                            <i data-lucide="zap" class="w-4 h-4 mr-2 inline"></i>
                            Pure Semantic
                        </button>
                        <button @click="searchMode = 'structured'" 
                                :class="{'bg-rose-600 text-white': searchMode === 'structured', 'bg-white/10 text-gray-300 hover:bg-white/20': searchMode !== 'structured'}"
                                class="px-4 py-2 rounded-lg text-sm font-medium transition-colors">
                            <i data-lucide="filter" class="w-4 h-4 mr-2 inline"></i>
                            Structured Query
                        </button>
                    </div>
                    
                    <!-- Advanced Options -->
                    <div x-show="showAdvancedOptions" 
                         x-transition:enter="transition ease-out duration-200" 
                         x-transition:enter-start="opacity-0 max-h-0" 
                         x-transition:enter-end="opacity-100 max-h-96"
                         class="grid grid-cols-1 md:grid-cols-3 gap-4 p-4 bg-white/5 rounded-xl overflow-hidden">
                        <div>
                            <label class="block text-sm font-medium mb-2">Memory Level</label>
                            <select x-model="searchFilters.memoryLevel" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                                <option value="">All Levels</option>
                                <option value="working">Working</option>
                                <option value="episodic">Episodic</option>
                                <option value="semantic">Semantic</option>
                                <option value="procedural">Procedural</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm font-medium mb-2">Memory Type</label>
                            <select x-model="searchFilters.memoryType" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                                <option value="">All Types</option>
                                <option value="thought">Thought</option>
                                <option value="plan">Plan</option>
                                <option value="goal">Goal</option>
                                <option value="insight">Insight</option>
                                <option value="observation">Observation</option>
                            </select>
                        </div>
                        <div x-show="searchMode === 'hybrid'">
                            <label class="block text-sm font-medium mb-2">Search Balance</label>
                            <div class="space-y-2">
                                <div class="flex items-center justify-between text-sm">
                                    <span>Semantic: <span x-text="Math.round(searchFilters.semanticWeight * 100)">60</span>%</span>
                                    <span>Keyword: <span x-text="Math.round(searchFilters.keywordWeight * 100)">40</span>%</span>
                                </div>
                                <input type="range" 
                                       x-model.number="searchFilters.semanticWeight" 
                                       @input="searchFilters.keywordWeight = 1 - searchFilters.semanticWeight"
                                       min="0" max="1" step="0.1" 
                                       class="w-full">
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex items-center justify-between">
                        <button @click="showAdvancedOptions = !showAdvancedOptions" 
                                class="text-sm text-rose-400 hover:text-rose-300 transition-colors">
                            <i :data-lucide="showAdvancedOptions ? 'chevron-up' : 'chevron-down'" class="w-4 h-4 mr-1 inline"></i>
                            Advanced Options
                        </button>
                        
                        <div class="flex items-center space-x-4 text-sm text-gray-400">
                            <span>Results: <span x-text="searchResults.length">0</span></span>
                            <span x-show="searchStats.totalTime">Time: <span x-text="searchStats.totalTime">0</span>ms</span>
                            <span x-show="searchStats.semanticMatches">Semantic: <span x-text="searchStats.semanticMatches">0</span></span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Search Results -->
            <div class="space-y-6">
                <!-- Results Header -->
                <div class="flex items-center justify-between">
                    <div class="flex space-x-2">
                        <button @click="resultsView = 'list'" 
                                :class="{'bg-rose-600 text-white': resultsView === 'list', 'bg-white/10 text-gray-300 hover:bg-white/20': resultsView !== 'list'}"
                                class="px-3 py-2 rounded-lg text-sm font-medium transition-colors">
                            <i data-lucide="list" class="w-4 h-4 mr-1 inline"></i>
                            List
                        </button>
                        <button @click="resultsView = 'clusters'" 
                                :class="{'bg-rose-600 text-white': resultsView === 'clusters', 'bg-white/10 text-gray-300 hover:bg-white/20': resultsView !== 'clusters'}"
                                class="px-3 py-2 rounded-lg text-sm font-medium transition-colors">
                            <i data-lucide="git-branch" class="w-4 h-4 mr-1 inline"></i>
                            Clusters
                        </button>
                        <button @click="resultsView = 'context'" 
                                :class="{'bg-rose-600 text-white': resultsView === 'context', 'bg-white/10 text-gray-300 hover:bg-white/20': resultsView !== 'context'}"
                                class="px-3 py-2 rounded-lg text-sm font-medium transition-colors">
                            <i data-lucide="layers" class="w-4 h-4 mr-1 inline"></i>
                            Rich Context
                        </button>
                    </div>
                    
                    <div class="flex items-center space-x-2">
                        <label class="text-sm text-gray-400">Sort:</label>
                        <select x-model="sortBy" @change="sortSearchResults()" class="bg-white/10 border border-white/20 rounded px-2 py-1 text-sm">
                            <option value="similarity">Similarity</option>
                            <option value="importance">Importance</option>
                            <option value="created_at">Date</option>
                            <option value="hybrid">Hybrid Score</option>
                        </select>
                    </div>
                </div>
                
                <!-- Empty State -->
                <div x-show="!isSearching && !searchResults.length" class="text-center py-12 text-gray-400">
                    <i data-lucide="search" class="w-16 h-16 mx-auto mb-4 opacity-50"></i>
                    <h3 class="text-lg font-semibold mb-2">No Search Results</h3>
                    <p class="text-sm">
                        <span x-show="!semanticQuery">Enter a search query to explore your memory system</span>
                        <span x-show="semanticQuery">Try adjusting your search terms or filters</span>
                    </p>
                    <div class="mt-4 space-y-2 text-sm text-gray-500">
                        <p><strong>Tips:</strong></p>
                        <p>• Use natural language questions: "What did I learn about..."</p>
                        <p>• Try concept-based searches: "machine learning insights"</p>
                        <p>• Use hybrid mode for best results combining semantic + keyword</p>
                    </div>
                </div>
                
                <!-- Loading State -->
                <div x-show="isSearching" class="text-center py-12">
                    <div class="spinner mx-auto mb-4"></div>
                    <p class="text-gray-400">Searching through <span x-text="stats.totalMemories || 'your'"></span> memories...</p>
                    <p class="text-sm text-gray-500 mt-2" x-text="searchStatusMessage"></p>
                </div>
                
                <!-- List View -->
                <div x-show="resultsView === 'list' && searchResults.length" class="space-y-4">
                    <template x-for="(result, index) in sortedSearchResults" :key="result.memory_id">
                        <div class="enhanced-card rounded-xl p-6 cursor-pointer group" 
                             @click="selectSearchResult(result)"
                             :class="`memory-${result.memory_level}`">
                            <div class="flex items-start justify-between mb-4">
                                <div class="flex items-center space-x-3">
                                    <div class="text-lg font-bold text-rose-400" x-text="`#${index + 1}`"></div>
                                    <div class="flex items-center space-x-2">
                                        <span class="px-2 py-1 text-xs rounded-full" 
                                              :class="getMemoryLevelClass(result.memory_level)" 
                                              x-text="result.memory_level"></span>
                                        <span class="text-xs text-gray-500" x-text="result.memory_type"></span>
                                    </div>
                                </div>
                                <div class="flex items-center space-x-4 text-sm">
                                    <div class="text-right" x-show="result.similarity">
                                        <div class="text-rose-400 font-semibold" x-text="`${Math.round(result.similarity * 100)}%`"></div>
                                        <div class="text-xs text-gray-500">similarity</div>
                                    </div>
                                    <div class="text-right" x-show="result.hybrid_score">
                                        <div class="text-purple-400 font-semibold" x-text="`${Math.round(result.hybrid_score * 100)}%`"></div>
                                        <div class="text-xs text-gray-500">hybrid</div>
                                    </div>
                                    <div class="text-right">
                                        <div class="text-blue-400 font-semibold" x-text="`${result.importance}/10`"></div>
                                        <div class="text-xs text-gray-500">importance</div>
                                    </div>
                                </div>
                            </div>
                            
                            <p class="text-gray-300 mb-4 line-clamp-3" x-text="result.content"></p>
                            
                            <div class="flex items-center justify-between text-sm text-gray-500">
                                <span x-text="formatRelativeTime(result.created_at)"></span>
                                <div class="flex items-center space-x-4">
                                    <span x-show="result.access_count" x-text="`${result.access_count} accesses`"></span>
                                    <span x-show="result.confidence" x-text="`${Math.round(result.confidence * 100)}% confidence`"></span>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
                
                <!-- Cluster View -->
                <div x-show="resultsView === 'clusters' && searchClusters.length" class="space-y-6">
                    <template x-for="cluster in searchClusters" :key="cluster.id">
                        <div class="enhanced-card rounded-xl p-6">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-lg font-semibold flex items-center">
                                    <i data-lucide="git-branch" class="w-5 h-5 mr-2 text-rose-400"></i>
                                    <span x-text="cluster.label"></span>
                                    <span class="ml-2 px-2 py-1 text-xs bg-rose-500/20 text-rose-400 rounded-full" x-text="`${cluster.results.length} memories`"></span>
                                </h3>
                                <button @click="cluster.expanded = !cluster.expanded" 
                                        class="p-1 hover:bg-white/10 rounded transition-colors">
                                    <i :data-lucide="cluster.expanded ? 'chevron-up' : 'chevron-down'" class="w-4 h-4"></i>
                                </button>
                            </div>
                            
                            <div x-show="cluster.expanded" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <template x-for="result in cluster.results" :key="result.memory_id">
                                    <div class="p-4 bg-white/5 rounded-lg cursor-pointer hover:bg-white/10 transition-colors" 
                                         @click="selectSearchResult(result)">
                                        <div class="flex items-center justify-between mb-2">
                                            <span class="px-2 py-1 text-xs rounded-full" 
                                                  :class="getMemoryLevelClass(result.memory_level)" 
                                                  x-text="result.memory_level"></span>
                                            <span class="text-sm text-rose-400 font-semibold" x-text="`${Math.round((result.similarity || result.hybrid_score || 0) * 100)}%`"></span>
                                        </div>
                                        <p class="text-sm text-gray-300 line-clamp-2" x-text="result.content"></p>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </template>
                </div>
                
                <!-- Rich Context View -->
                <div x-show="resultsView === 'context' && searchResults.length" class="enhanced-card rounded-xl p-6">
                    <h3 class="text-lg font-semibold mb-4 flex items-center">
                        <i data-lucide="layers" class="w-5 h-5 mr-2 text-rose-400"></i>
                        Contextual Analysis
                    </h3>
                    
                    <div class="space-y-6">
                        <!-- Memory Distribution -->
                        <div>
                            <h4 class="font-medium mb-3">Memory Distribution</h4>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                                <template x-for="(count, level) in getMemoryDistribution()" :key="level">
                                    <div class="text-center p-3 bg-white/5 rounded-lg">
                                        <div class="text-lg font-bold" :class="getMemoryLevelClass(level)" x-text="count"></div>
                                        <div class="text-xs text-gray-400 capitalize" x-text="level"></div>
                                    </div>
                                </template>
                            </div>
                        </div>
                        
                        <!-- Key Insights -->
                        <div>
                            <h4 class="font-medium mb-3">Search Insights</h4>
                            <div class="space-y-2">
                                <template x-for="insight in getSearchInsights()" :key="insight.type">
                                    <div class="flex items-center space-x-2 text-sm">
                                        <i :data-lucide="insight.icon" class="w-4 h-4 text-blue-400"></i>
                                        <span x-text="insight.message"></span>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Workflow Dependencies View -->
        <div x-show="dbLoaded && currentView === 'workflow-dependencies'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold flex items-center">
                        <i data-lucide="git-merge" class="w-8 h-8 mr-3 text-violet-400"></i>
                        Workflow Dependencies
                    </h2>
                    <p class="text-gray-400" x-text="`${dependencyWorkflows.length} workflows • ${criticalPathStats.totalWorkflows} critical • ${resourceConflicts.length} conflicts`"></p>
                </div>
                <div class="flex items-center space-x-3">
                    <div class="flex items-center space-x-2">
                        <label class="text-sm text-gray-400">Mode:</label>
                        <div class="flex bg-white/10 rounded-lg p-1">
                            <button @click="dependencyViewMode = 'combined'" 
                                    :class="{'bg-violet-600 text-white': dependencyViewMode === 'combined', 'text-gray-400 hover:text-white': dependencyViewMode !== 'combined'}"
                                    class="px-3 py-1 rounded text-sm transition-colors">Combined</button>
                            <button @click="dependencyViewMode = 'network'" 
                                    :class="{'bg-violet-600 text-white': dependencyViewMode === 'network', 'text-gray-400 hover:text-white': dependencyViewMode !== 'network'}"
                                    class="px-3 py-1 rounded text-sm transition-colors">Network</button>
                            <button @click="dependencyViewMode = 'gantt'" 
                                    :class="{'bg-violet-600 text-white': dependencyViewMode === 'gantt', 'text-gray-400 hover:text-white': dependencyViewMode !== 'gantt'}"
                                    class="px-3 py-1 rounded text-sm transition-colors">Gantt</button>
                        </div>
                    </div>
                    <button @click="toggleSimulationMode()" 
                            :class="{'bg-blue-600 text-white': simulationMode, 'bg-white/10 text-gray-300 hover:bg-white/20': !simulationMode}"
                            class="px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center">
                        <i data-lucide="play-circle" class="w-4 h-4 mr-2"></i>
                        <span x-text="simulationMode ? 'Exit Simulation' : 'Enter Simulation'"></span>
                    </button>
                    <button @click="optimizeSchedule()" 
                            :disabled="isOptimizingSchedule"
                            class="px-4 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="zap" class="w-4 h-4 mr-2 inline" :class="{'animate-spin': isOptimizingSchedule}"></i>
                        <span x-text="isOptimizingSchedule ? 'Optimizing...' : 'Auto-Optimize'"></span>
                    </button>
                    <button @click="exportSchedule()" 
                            class="px-4 py-2 bg-violet-600 hover:bg-violet-700 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="download" class="w-4 h-4 mr-2 inline"></i>
                        Export
                    </button>
                </div>
            </div>

            <!-- Critical Path & Resource Stats -->
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-violet-400" x-text="dependencyWorkflows.length"></div>
                    <div class="text-xs text-gray-400">Total Workflows</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-violet-400 rounded-full transition-all duration-500" style="width: 100%"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-red-400" x-text="criticalPathStats.totalWorkflows"></div>
                    <div class="text-xs text-gray-400">Critical Path</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-red-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, (criticalPathStats.totalWorkflows / Math.max(1, dependencyWorkflows.length)) * 100)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-yellow-400" x-text="resourceConflicts.length"></div>
                    <div class="text-xs text-gray-400">Resource Conflicts</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-yellow-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, resourceConflicts.length * 10)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-blue-400" x-text="Math.round(criticalPathStats.totalDuration / 3600) + 'h'"></div>
                    <div class="text-xs text-gray-400">Total Duration</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-blue-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, (criticalPathStats.totalDuration / 86400) * 100)}%`"></div>
                    </div>
                </div>
            </div>

            <!-- Simulation Banner -->
            <div x-show="simulationMode" 
                 x-transition:enter="transition ease-out duration-300" 
                 x-transition:enter-start="opacity-0 transform -translate-y-2" 
                 x-transition:enter-end="opacity-100 transform translate-y-0"
                 class="enhanced-card rounded-xl p-4 bg-blue-500/10 border border-blue-500/30">
                <div class="flex items-center justify-between">
                    <div class="flex items-center">
                        <i data-lucide="play-circle" class="w-5 h-5 text-blue-400 mr-3"></i>
                        <div>
                            <div class="font-semibold text-blue-400">Simulation Mode Active</div>
                            <div class="text-sm text-gray-400">Changes are temporary and can be reverted</div>
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button @click="restoreFromSnapshot()" 
                                :disabled="!simulationSnapshot"
                                class="px-3 py-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded text-sm font-medium transition-colors">
                            Restore
                        </button>
                        <button @click="toggleSimulationMode()" 
                                class="px-3 py-1 bg-red-600 hover:bg-red-700 rounded text-sm font-medium transition-colors">
                            Exit
                        </button>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-12 gap-6">
                <!-- Main Visualization Area -->
                <div class="col-span-12 lg:col-span-9">
                    <!-- Combined View -->
                    <div x-show="dependencyViewMode === 'combined'" class="space-y-6">
                        <!-- Network View -->
                        <div class="enhanced-card rounded-2xl p-6">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-lg font-semibold">Workflow Network</h3>
                                <div class="flex items-center space-x-2">
                                    <button @click="resetDependencyView()" 
                                            class="p-2 hover:bg-white/10 rounded-lg transition-colors">
                                        <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="relative" style="height: 400px;">
                                <svg x-ref="dependencyNetworkSvg" class="w-full h-full" style="background: rgba(0,0,0,0.1); border-radius: 12px;"></svg>
                            </div>
                        </div>

                        <!-- Gantt Chart View -->
                        <div class="enhanced-card rounded-2xl p-6">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-lg font-semibold">Schedule Timeline</h3>
                                <div class="flex items-center space-x-2 text-sm text-gray-400">
                                    <i data-lucide="info" class="w-4 h-4"></i>
                                    <span>Drag workflow bars to reschedule</span>
                                </div>
                            </div>
                            <div x-ref="ganttContainer" class="relative overflow-auto" style="max-height: 500px;"></div>
                        </div>
                    </div>

                    <!-- Network Only View -->
                    <div x-show="dependencyViewMode === 'network'" class="enhanced-card rounded-2xl p-6" style="min-height: 70vh;">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold">Workflow Network</h3>
                            <div class="flex items-center space-x-2">
                                <button @click="resetDependencyView()" 
                                        class="p-2 hover:bg-white/10 rounded-lg transition-colors">
                                    <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                        <div class="relative" style="height: calc(70vh - 6rem);">
                            <svg x-ref="dependencyNetworkSvg" class="w-full h-full" style="background: rgba(0,0,0,0.1); border-radius: 12px;"></svg>
                        </div>
                    </div>

                    <!-- Gantt Only View -->
                    <div x-show="dependencyViewMode === 'gantt'" class="enhanced-card rounded-2xl p-6" style="min-height: 70vh;">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold">Schedule Timeline</h3>
                            <div class="flex items-center space-x-2 text-sm text-gray-400">
                                <i data-lucide="info" class="w-4 h-4"></i>
                                <span>Drag workflow bars to reschedule</span>
                            </div>
                        </div>
                        <div x-ref="ganttContainer" class="relative overflow-auto" style="height: calc(70vh - 8rem);"></div>
                    </div>
                </div>

                <!-- Sidebar -->
                <div class="col-span-12 lg:col-span-3 space-y-6">
                    <!-- Selected Workflow Details -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div x-show="!selectedDependencyWorkflow" class="text-center text-gray-400 py-8">
                            <i data-lucide="git-merge" class="w-12 h-12 mx-auto mb-4 opacity-50"></i>
                            <h4 class="font-semibold mb-2">No Workflow Selected</h4>
                            <p class="text-sm">Click on a workflow in the visualization to view details and dependencies</p>
                        </div>
                        
                        <div x-show="selectedDependencyWorkflow" class="space-y-4">
                            <div class="flex items-center justify-between">
                                <h4 class="font-semibold">Workflow Details</h4>
                                <button @click="selectedDependencyWorkflow = null" 
                                        class="p-1 hover:bg-white/10 rounded transition-colors">
                                    <i data-lucide="x" class="w-4 h-4"></i>
                                </button>
                            </div>
                            
                            <div x-show="selectedDependencyWorkflow" class="space-y-3">
                                <div>
                                    <h5 class="font-medium mb-2" x-text="selectedDependencyWorkflow?.title || selectedDependencyWorkflow?.workflow_id"></h5>
                                    <div class="flex items-center space-x-2 mb-2">
                                        <span class="px-2 py-1 text-xs rounded-full" 
                                              :class="getWorkflowStatusClass(selectedDependencyWorkflow?.status)" 
                                              x-text="selectedDependencyWorkflow?.status"></span>
                                        <span x-show="selectedDependencyWorkflow?.critical_path" 
                                              class="px-2 py-1 text-xs rounded-full bg-red-500/20 text-red-400">
                                            Critical Path
                                        </span>
                                    </div>
                                </div>
                                
                                <div class="grid grid-cols-2 gap-3 text-sm">
                                    <div>
                                        <span class="text-gray-400">Progress:</span>
                                        <div class="text-green-400 font-semibold" x-text="selectedDependencyWorkflow?.progress + '%'"></div>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">Actions:</span>
                                        <div class="font-semibold" x-text="selectedDependencyWorkflow?.actions?.length || 0"></div>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">Dependencies:</span>
                                        <div class="font-semibold" x-text="selectedDependencyWorkflow?.dependencies?.length || 0"></div>
                                    </div>
                                    <div>
                                        <span class="text-gray-400">Resources:</span>
                                        <div class="font-semibold" x-text="selectedDependencyWorkflow?.resources?.length || 0"></div>
                                    </div>
                                </div>
                                
                                <div>
                                    <span class="text-gray-400 text-sm">Timeline:</span>
                                    <div class="text-sm mt-1">
                                        <div x-text="`Start: ${new Date(selectedDependencyWorkflow?.start_time * 1000).toLocaleString()}`"></div>
                                        <div x-text="`End: ${new Date(selectedDependencyWorkflow?.end_time * 1000).toLocaleString()}`"></div>
                                        <div x-text="`Duration: ${formatDuration(selectedDependencyWorkflow?.start_time, selectedDependencyWorkflow?.end_time)}`"></div>
                                    </div>
                                </div>
                                
                                <div x-show="selectedDependencyWorkflow?.resource_conflicts?.length > 0">
                                    <span class="text-gray-400 text-sm">Resource Conflicts:</span>
                                    <div class="text-sm mt-1 text-yellow-400" x-text="`${selectedDependencyWorkflow?.resource_conflicts?.length} conflicts detected`"></div>
                                </div>
                                
                                <div x-show="selectedDependencyWorkflow?.dependencies?.length > 0">
                                    <span class="text-gray-400 text-sm">Dependencies:</span>
                                    <div class="space-y-1 mt-1 max-h-24 overflow-y-auto">
                                        <template x-for="dep in selectedDependencyWorkflow?.dependencies" :key="dep.workflow_id">
                                            <div class="text-xs p-2 bg-white/5 rounded">
                                                <span class="font-medium" x-text="dep.workflow_id.substring(0, 8) + '...'"></span>
                                                <span class="text-gray-500" x-text="`(${dep.type})`"></span>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Critical Path Analysis -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h4 class="font-semibold mb-4 flex items-center">
                            <i data-lucide="route" class="w-5 h-5 mr-2 text-red-400"></i>
                            Critical Path
                        </h4>
                        
                        <div x-show="criticalPathStats.totalWorkflows === 0" class="text-center text-gray-500 py-4">
                            <i data-lucide="check-circle" class="w-8 h-8 mx-auto mb-2 opacity-50"></i>
                            <div class="text-sm">No critical path detected</div>
                        </div>
                        
                        <div x-show="criticalPathStats.totalWorkflows > 0" class="space-y-3">
                            <div class="text-sm">
                                <div class="text-gray-400">Critical Workflows:</div>
                                <div class="font-semibold text-red-400" x-text="criticalPathStats.totalWorkflows"></div>
                            </div>
                            
                            <div class="text-sm">
                                <div class="text-gray-400">Project Duration:</div>
                                <div class="font-semibold" x-text="Math.round(criticalPathStats.totalDuration / 3600) + ' hours'"></div>
                            </div>
                            
                            <div x-show="criticalPathStats.bottlenecks?.length > 0">
                                <div class="text-gray-400 text-sm mb-2">Bottlenecks:</div>
                                <div class="space-y-1 max-h-24 overflow-y-auto">
                                    <template x-for="bottleneck in criticalPathStats.bottlenecks" :key="bottleneck">
                                        <div class="text-xs p-2 bg-red-500/10 rounded border border-red-500/20">
                                            <span x-text="bottleneck"></span>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Resource Conflicts -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h4 class="font-semibold mb-4 flex items-center">
                            <i data-lucide="alert-triangle" class="w-5 h-5 mr-2 text-yellow-400"></i>
                            Resource Conflicts
                        </h4>
                        
                        <div x-show="resourceConflicts.length === 0" class="text-center text-gray-500 py-4">
                            <i data-lucide="check-circle" class="w-8 h-8 mx-auto mb-2 opacity-50"></i>
                            <div class="text-sm">No resource conflicts</div>
                        </div>
                        
                        <div x-show="resourceConflicts.length > 0" class="space-y-3 max-h-48 overflow-y-auto">
                            <template x-for="conflict in resourceConflicts" :key="conflict.id">
                                <div class="p-3 rounded-lg border-l-4" :class="`border-l-${getConflictSeverityColor(conflict.severity).replace('#', '')} bg-${getConflictSeverityColor(conflict.severity).replace('#', '')}/10`">
                                    <div class="flex items-center justify-between mb-2">
                                        <span class="text-sm font-medium" x-text="conflict.resource"></span>
                                        <span class="text-xs px-2 py-1 rounded-full" 
                                              :style="`background: ${getConflictSeverityColor(conflict.severity)}20; color: ${getConflictSeverityColor(conflict.severity)}`"
                                              x-text="conflict.severity"></span>
                                    </div>
                                    <div class="text-xs text-gray-400 mb-2">
                                        <div x-text="`${conflict.workflows[0].title} vs ${conflict.workflows[1].title}`"></div>
                                        <div x-text="`Overlap: ${new Date(conflict.overlap_start * 1000).toLocaleTimeString()} - ${new Date(conflict.overlap_end * 1000).toLocaleTimeString()}`"></div>
                                    </div>
                                    <div x-show="conflict.suggestions?.length > 0" class="text-xs">
                                        <div class="text-gray-400 mb-1">Suggestion:</div>
                                        <div x-text="conflict.suggestions[0]?.description"></div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Cognitive State Timeline -->
        <div x-show="dbLoaded && currentView === 'cognitive-timeline'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold flex items-center">
                        <i data-lucide="activity" class="w-8 h-8 mr-3 text-emerald-400"></i>
                        Cognitive State Timeline
                    </h2>
                    <p class="text-gray-400" x-text="`${cognitiveTimelineData.length} states • ${patternAnalysis.summary?.pattern_count || 0} patterns detected`"></p>
                </div>
                <div class="flex items-center space-x-3">
                    <select x-model="cognitiveTimelineSettings.timeRange" @change="loadCognitiveTimeline()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="1">Last Hour</option>
                        <option value="6">Last 6 Hours</option>
                        <option value="24">Last 24 Hours</option>
                        <option value="72">Last 3 Days</option>
                        <option value="168">Last Week</option>
                    </select>
                    <select x-model="cognitiveTimelineSettings.granularity" @change="loadCognitiveTimeline()" class="bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                        <option value="minute">By Minute</option>
                        <option value="hour">By Hour</option>
                        <option value="second">By Second</option>
                    </select>
                    <button @click="refreshCognitiveTimeline()" 
                            :disabled="isLoadingTimeline"
                            class="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="refresh-cw" class="w-4 h-4 mr-2 inline" :class="{'animate-spin': isLoadingTimeline}"></i>
                        Refresh
                    </button>
                    <button @click="analyzePatterns()" 
                            :disabled="isAnalyzingPatterns"
                            class="px-4 py-2 bg-purple-600 hover:bg-purple-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="search" class="w-4 h-4 mr-2 inline"></i>
                        <span x-text="isAnalyzingPatterns ? 'Analyzing...' : 'Analyze Patterns'"></span>
                    </button>
                </div>
            </div>

            <!-- Timeline Statistics -->
            <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-6">
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-emerald-400" x-text="timelineStats.total_states || 0"></div>
                    <div class="text-xs text-gray-400">Total States</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-emerald-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, (timelineStats.total_states || 0) / 50 * 100)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-blue-400" x-text="(timelineStats.avg_complexity || 0).toFixed(1)"></div>
                    <div class="text-xs text-gray-400">Avg Complexity</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-blue-400 rounded-full transition-all duration-500" 
                             :style="`width: ${(timelineStats.avg_complexity || 0)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-orange-400" x-text="(timelineStats.max_change_magnitude || 0).toFixed(1) + '%'"></div>
                    <div class="text-xs text-gray-400">Max Change</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-orange-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, timelineStats.max_change_magnitude || 0)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-purple-400" x-text="patternAnalysis.summary?.pattern_count || 0"></div>
                    <div class="text-xs text-gray-400">Patterns</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-purple-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, (patternAnalysis.summary?.pattern_count || 0) * 20)}%`"></div>
                    </div>
                </div>
                
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-red-400" x-text="patternAnalysis.summary?.anomaly_count || 0"></div>
                    <div class="text-xs text-gray-400">Anomalies</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-red-400 rounded-full transition-all duration-500" 
                             :style="`width: ${Math.min(100, (patternAnalysis.summary?.anomaly_count || 0) * 33)}%`"></div>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-12 gap-6">
                <!-- Main Timeline Visualization -->
                <div class="col-span-12 lg:col-span-9">
                    <div class="enhanced-card rounded-2xl p-6" style="min-height: 60vh;">
                        <!-- Timeline Controls -->
                        <div class="flex items-center justify-between mb-6">
                            <div class="flex items-center space-x-4">
                                <h3 class="text-lg font-semibold">State Timeline</h3>
                                <div class="flex items-center space-x-2">
                                    <button @click="playTimelineAnimation()" 
                                            :disabled="!cognitiveTimelineData.length"
                                            class="p-2 bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 rounded-lg transition-colors">
                                        <i :data-lucide="isTimelineAnimating ? 'pause' : 'play'" class="w-4 h-4"></i>
                                    </button>
                                    <button @click="resetTimelineView()" 
                                            class="p-2 bg-gray-600 hover:bg-gray-700 rounded-lg transition-colors">
                                        <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            
                            <div class="flex items-center space-x-3">
                                <label class="text-sm text-gray-400">View:</label>
                                <div class="flex bg-white/10 rounded-lg p-1">
                                    <button @click="timelineViewMode = 'timeline'" 
                                            :class="{'bg-emerald-600 text-white': timelineViewMode === 'timeline', 'text-gray-400 hover:text-white': timelineViewMode !== 'timeline'}"
                                            class="px-3 py-1 rounded text-sm transition-colors">Timeline</button>
                                    <button @click="timelineViewMode = 'heatmap'" 
                                            :class="{'bg-emerald-600 text-white': timelineViewMode === 'heatmap', 'text-gray-400 hover:text-white': timelineViewMode !== 'heatmap'}"
                                            class="px-3 py-1 rounded text-sm transition-colors">Heatmap</button>
                                    <button @click="timelineViewMode = 'network'" 
                                            :class="{'bg-emerald-600 text-white': timelineViewMode === 'network', 'text-gray-400 hover:text-white': timelineViewMode !== 'network'}"
                                            class="px-3 py-1 rounded text-sm transition-colors">Network</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Timeline SVG Container -->
                        <div x-show="timelineViewMode === 'timeline'" class="relative" style="height: calc(60vh - 8rem);">
                            <svg x-ref="cognitiveTimelineSvg" class="w-full h-full" style="background: rgba(0,0,0,0.1); border-radius: 12px;"></svg>
                            
                            <!-- Timeline Scrubber -->
                            <div class="absolute bottom-0 left-0 right-0 bg-black/80 backdrop-blur-lg rounded-lg p-4">
                                <div class="flex items-center space-x-4 mb-3">
                                    <button @click="stepTimelineBackward()" 
                                            :disabled="currentTimelineIndex <= 0"
                                            class="p-2 bg-gray-600 hover:bg-gray-700 disabled:bg-gray-800 rounded-lg transition-colors">
                                        <i data-lucide="skip-back" class="w-4 h-4"></i>
                                    </button>
                                    <button @click="toggleTimelinePlayback()" 
                                            :disabled="!cognitiveTimelineData.length"
                                            class="p-2 bg-emerald-600 hover:bg-emerald-700 disabled:bg-gray-600 rounded-lg transition-colors">
                                        <i :data-lucide="isTimelineAnimating ? 'pause' : 'play'" class="w-5 h-5"></i>
                                    </button>
                                    <button @click="stepTimelineForward()" 
                                            :disabled="currentTimelineIndex >= cognitiveTimelineData.length - 1"
                                            class="p-2 bg-gray-600 hover:bg-gray-700 disabled:bg-gray-800 rounded-lg transition-colors">
                                        <i data-lucide="skip-forward" class="w-4 h-4"></i>
                                    </button>
                                    
                                    <div class="flex items-center space-x-2 ml-4">
                                        <span class="text-xs text-gray-400">Speed:</span>
                                        <select x-model.number="timelineAnimationSpeed" class="bg-gray-700 border border-gray-600 rounded px-2 py-1 text-xs">
                                            <option value="0.5">0.5x</option>
                                            <option value="1">1x</option>
                                            <option value="2">2x</option>
                                            <option value="4">4x</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <!-- Timeline Slider -->
                                <div class="relative">
                                    <input type="range" 
                                           x-model.number="currentTimelineIndex" 
                                           @input="seekToTimelinePosition($event.target.value)"
                                           :min="0" 
                                           :max="Math.max(0, cognitiveTimelineData.length - 1)" 
                                           :step="1"
                                           class="w-full h-2 bg-gray-700 rounded-lg appearance-none slider cursor-pointer">
                                    
                                    <!-- Timeline markers for significant events -->
                                    <div class="absolute top-0 left-0 w-full h-2 pointer-events-none">
                                        <template x-for="(state, index) in cognitiveTimelineData" :key="state.state_id">
                                            <div x-show="state.change_magnitude > 30" 
                                                 class="absolute w-1 h-2 bg-red-400 rounded-full"
                                                 :style="`left: ${(index / (cognitiveTimelineData.length - 1)) * 100}%`"
                                                 :title="`Major change: ${state.change_magnitude.toFixed(1)}%`"></div>
                                        </template>
                                    </div>
                                </div>
                                
                                <!-- Current state info -->
                                <div x-show="cognitiveTimelineData[currentTimelineIndex]" class="flex items-center justify-between mt-3 text-sm">
                                    <div>
                                        <span class="text-gray-400" x-text="`State ${currentTimelineIndex + 1} of ${cognitiveTimelineData.length}`"></span>
                                        <span class="ml-3" x-text="cognitiveTimelineData[currentTimelineIndex]?.state_type"></span>
                                    </div>
                                    <div x-text="formatDate(cognitiveTimelineData[currentTimelineIndex]?.timestamp)"></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Heatmap View -->
                        <div x-show="timelineViewMode === 'heatmap'" class="relative" style="height: calc(60vh - 8rem);">
                            <div x-ref="cognitiveHeatmap" class="w-full h-full bg-black/10 rounded-lg"></div>
                        </div>
                        
                        <!-- Network View -->
                        <div x-show="timelineViewMode === 'network'" class="relative" style="height: calc(60vh - 8rem);">
                            <svg x-ref="cognitiveNetworkSvg" class="w-full h-full" style="background: rgba(0,0,0,0.1); border-radius: 12px;"></svg>
                        </div>
                    </div>
                </div>
                
                <!-- Timeline Sidebar -->
                <div class="col-span-12 lg:col-span-3 space-y-6">
                    <!-- Current State Details -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h4 class="font-semibold">Current State</h4>
                            <button x-show="selectedTimelineState" 
                                    @click="showTimelineStateModal = true" 
                                    class="p-1 hover:bg-white/10 rounded transition-colors">
                                <i data-lucide="external-link" class="w-4 h-4"></i>
                            </button>
                        </div>
                        
                        <div x-show="!selectedTimelineState" class="text-center text-gray-400 py-8">
                            <i data-lucide="mouse-pointer-click" class="w-8 h-8 mx-auto mb-3 opacity-50"></i>
                            <p class="text-sm">Click on a state in the timeline to view details</p>
                        </div>
                        
                        <div x-show="selectedTimelineState" class="space-y-4">
                            <div>
                                <div class="text-xs text-gray-400 mb-1">State Type</div>
                                <div class="flex items-center space-x-2">
                                    <span class="px-2 py-1 text-xs rounded-full bg-emerald-500/20 text-emerald-400" 
                                          x-text="selectedTimelineState?.state_type"></span>
                                    <span class="text-sm text-gray-400" x-text="`#${selectedTimelineState?.sequence_number}`"></span>
                                </div>
                            </div>
                            
                            <div>
                                <div class="text-xs text-gray-400 mb-1">Complexity Score</div>
                                <div class="text-lg font-semibold" x-text="selectedTimelineState?.complexity_score?.toFixed(1) + '/100'"></div>
                                <div class="w-full bg-gray-700 rounded-full h-1 mt-1">
                                    <div class="bg-emerald-400 h-1 rounded-full transition-all duration-300" 
                                         :style="`width: ${selectedTimelineState?.complexity_score || 0}%`"></div>
                                </div>
                            </div>
                            
                            <div x-show="selectedTimelineState?.change_magnitude > 0">
                                <div class="text-xs text-gray-400 mb-1">Change Magnitude</div>
                                <div class="text-lg font-semibold" 
                                     :class="selectedTimelineState?.change_magnitude > 50 ? 'text-red-400' : selectedTimelineState?.change_magnitude > 25 ? 'text-yellow-400' : 'text-green-400'"
                                     x-text="selectedTimelineState?.change_magnitude?.toFixed(1) + '%'"></div>
                            </div>
                            
                            <div>
                                <div class="text-xs text-gray-400 mb-1">Key Components</div>
                                <div class="space-y-1 max-h-24 overflow-y-auto">
                                    <template x-for="component in selectedTimelineState?.key_components?.slice(0, 3)" :key="component.name">
                                        <div class="text-xs p-2 bg-white/5 rounded">
                                            <span class="font-medium" x-text="component.name"></span>
                                            <span class="text-gray-500" x-text="`(${component.type})`"></span>
                                        </div>
                                    </template>
                                </div>
                            </div>
                            
                            <div>
                                <div class="text-xs text-gray-400 mb-1">Tags</div>
                                <div class="flex flex-wrap gap-1">
                                    <template x-for="tag in selectedTimelineState?.tags?.slice(0, 4)" :key="tag">
                                        <span class="px-2 py-1 text-xs bg-gray-600/50 text-gray-300 rounded-full" x-text="tag"></span>
                                    </template>
                                </div>
                            </div>
                            
                            <div class="pt-3 border-t border-white/10">
                                <button @click="compareWithPreviousState()" 
                                        :disabled="!canCompareWithPrevious()"
                                        class="w-full px-3 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors mb-2">
                                    <i data-lucide="git-compare" class="w-4 h-4 mr-2 inline"></i>
                                    Compare with Previous
                                </button>
                                <button @click="restoreToState(selectedTimelineState)" 
                                        :disabled="!selectedTimelineState"
                                        class="w-full px-3 py-2 bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                                    <i data-lucide="undo" class="w-4 h-4 mr-2 inline"></i>
                                    Restore to State
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Pattern Analysis -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h4 class="font-semibold mb-4 flex items-center">
                            <i data-lucide="search" class="w-5 h-5 mr-2 text-purple-400"></i>
                            Pattern Analysis
                        </h4>
                        
                        <div x-show="!patternAnalysis.patterns?.length" class="text-center text-gray-400 py-4">
                            <i data-lucide="search" class="w-8 h-8 mx-auto mb-3 opacity-50"></i>
                            <p class="text-sm">No patterns detected</p>
                            <button @click="analyzePatterns()" 
                                    class="mt-2 px-3 py-1 bg-purple-600 hover:bg-purple-700 rounded text-xs transition-colors">
                                Analyze
                            </button>
                        </div>
                        
                        <div x-show="patternAnalysis.patterns?.length" class="space-y-3">
                            <template x-for="pattern in patternAnalysis.patterns?.slice(0, 3)" :key="pattern.type">
                                <div class="p-3 bg-white/5 rounded-lg border-l-4 border-purple-400">
                                    <div class="flex items-center justify-between mb-2">
                                        <span class="text-sm font-medium" x-text="pattern.pattern_description"></span>
                                        <span class="text-xs text-purple-400" x-text="`${(pattern.similarity * 100).toFixed(0)}%`"></span>
                                    </div>
                                    <div class="text-xs text-gray-400">
                                        <span x-text="`Length: ${pattern.length}`"></span>
                                        <span class="ml-2" x-text="`Occurrences: ${pattern.occurrences}`"></span>
                                    </div>
                                </div>
                            </template>
                            
                            <button @click="showPatternsModal = true" 
                                    class="w-full px-3 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-sm font-medium transition-colors">
                                View All Patterns
                            </button>
                        </div>
                    </div>
                    
                    <!-- State Transitions -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h4 class="font-semibold mb-4 flex items-center">
                            <i data-lucide="shuffle" class="w-5 h-5 mr-2 text-blue-400"></i>
                            Common Transitions
                        </h4>
                        
                        <div class="space-y-2 max-h-48 overflow-y-auto">
                            <template x-for="transition in patternAnalysis.transitions?.slice(0, 5)" :key="transition.transition">
                                <div class="flex items-center justify-between p-2 bg-white/5 rounded">
                                    <span class="text-sm" x-text="transition.transition"></span>
                                    <div class="text-right">
                                        <div class="text-xs text-blue-400" x-text="`${transition.percentage.toFixed(1)}%`"></div>
                                        <div class="text-xs text-gray-500" x-text="`${transition.count}x`"></div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                    
                    <!-- Anomalies -->
                    <div x-show="patternAnalysis.anomalies?.length" class="enhanced-card rounded-2xl p-6">
                        <h4 class="font-semibold mb-4 flex items-center">
                            <i data-lucide="alert-triangle" class="w-5 h-5 mr-2 text-red-400"></i>
                            Anomalies Detected
                        </h4>
                        
                        <div class="space-y-2 max-h-32 overflow-y-auto">
                            <template x-for="anomaly in patternAnalysis.anomalies?.slice(0, 3)" :key="anomaly.state_id">
                                <div class="p-2 bg-red-500/10 rounded-lg border border-red-500/20 cursor-pointer hover:bg-red-500/20 transition-colors"
                                     @click="jumpToTimelineState(anomaly.state_id)">
                                    <div class="flex items-center justify-between mb-1">
                                        <span class="text-sm font-medium text-red-400" x-text="anomaly.anomaly_type"></span>
                                        <span class="text-xs" :class="anomaly.severity === 'high' ? 'text-red-400' : 'text-yellow-400'" x-text="anomaly.severity"></span>
                                    </div>
                                    <div class="text-xs text-gray-400" x-text="anomaly.description"></div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Working Memory Dashboard -->
        <div x-show="dbLoaded && currentView === 'working-memory'" class="space-y-6 animate-slide-in">
            <div class="flex items-center justify-between mb-6">
                <div>
                    <h2 class="text-2xl font-bold flex items-center">
                        <i data-lucide="cpu" class="w-8 h-8 mr-3 text-amber-400"></i>
                        Working Memory Dashboard
                    </h2>
                    <p class="text-gray-400">Real-time memory management and optimization controls</p>
                </div>
                <div class="flex items-center space-x-3">
                    <div class="flex items-center space-x-2">
                        <div :class="{'bg-green-400': workingMemoryStatus.connected, 'bg-red-400': !workingMemoryStatus.connected}" 
                             class="w-2 h-2 rounded-full animate-pulse"></div>
                        <span class="text-sm text-gray-400" x-text="workingMemoryStatus.connected ? 'Live' : 'Disconnected'"></span>
                    </div>
                    <button @click="refreshWorkingMemory()" 
                            :disabled="isRefreshingWorkingMemory"
                            class="px-4 py-2 bg-amber-600 hover:bg-amber-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="refresh-cw" class="w-4 h-4 mr-2 inline" :class="{'animate-spin': isRefreshingWorkingMemory}"></i>
                        Refresh
                    </button>
                    <button @click="optimizeWorkingMemory()" 
                            :disabled="isOptimizing"
                            class="px-4 py-2 bg-green-600 hover:bg-green-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                        <i data-lucide="zap" class="w-4 h-4 mr-2 inline"></i>
                        <span x-text="isOptimizing ? 'Optimizing...' : 'Auto-Optimize'"></span>
                    </button>
                </div>
            </div>

            <!-- Memory Pressure & Temperature Overview -->
            <div class="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-4 mb-6">
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-amber-400" x-text="workingMemoryStats.activeCount"></div>
                    <div class="text-xs text-gray-400">Active Memories</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-amber-400 rounded-full transition-all duration-500" 
                             :style="`width: ${(workingMemoryStats.activeCount / workingMemoryStats.capacity) * 100}%`"></div>
                    </div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold" :class="getPressureColor(workingMemoryStats.pressure)" x-text="workingMemoryStats.pressure + '%'"></div>
                    <div class="text-xs text-gray-400">Memory Pressure</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full rounded-full transition-all duration-500" 
                             :class="getPressureGradient(workingMemoryStats.pressure)"
                             :style="`width: ${workingMemoryStats.pressure}%`"></div>
                    </div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold" :class="getTemperatureColor(workingMemoryStats.temperature)" x-text="workingMemoryStats.temperature + '°'"></div>
                    <div class="text-xs text-gray-400">Temperature</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full rounded-full transition-all duration-500" 
                             :class="getTemperatureGradient(workingMemoryStats.temperature)"
                             :style="`width: ${Math.min(workingMemoryStats.temperature, 100)}%`"></div>
                    </div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-blue-400" x-text="workingMemoryStats.focusScore.toFixed(1)"></div>
                    <div class="text-xs text-gray-400">Focus Score</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-blue-400 rounded-full transition-all duration-500" 
                             :style="`width: ${workingMemoryStats.focusScore}%`"></div>
                    </div>
                </div>
                <div class="enhanced-card rounded-xl p-4 text-center">
                    <div class="text-2xl font-bold text-purple-400" x-text="workingMemoryStats.efficiency + '%'"></div>
                    <div class="text-xs text-gray-400">Efficiency</div>
                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                        <div class="h-full bg-purple-400 rounded-full transition-all duration-500" 
                             :style="`width: ${workingMemoryStats.efficiency}%`"></div>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-12 gap-6">
                <!-- Main Memory Dashboard -->
                <div class="col-span-12 lg:col-span-8 space-y-6">
                    <!-- Memory Pressure Gauge -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold">Memory Pressure Monitor</h3>
                            <div class="flex items-center space-x-2">
                                <span class="text-sm text-gray-400">Auto-refresh:</span>
                                <label class="relative inline-flex items-center cursor-pointer">
                                    <input type="checkbox" x-model="workingMemorySettings.autoRefresh" class="sr-only peer">
                                    <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-amber-600"></div>
                                </label>
                            </div>
                        </div>
                        <div class="h-64">
                            <canvas x-ref="memoryPressureGauge" class="w-full h-full"></canvas>
                        </div>
                    </div>

                    <!-- Memory Temperature Heatmap -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold">Memory Activity Heatmap</h3>
                            <div class="flex items-center space-x-2">
                                <select x-model="heatmapSettings.timeframe" @change="updateHeatmap()" class="bg-white/10 border border-white/20 rounded px-2 py-1 text-sm">
                                    <option value="1h">Last Hour</option>
                                    <option value="6h">Last 6 Hours</option>
                                    <option value="24h">Last 24 Hours</option>
                                    <option value="7d">Last 7 Days</option>
                                </select>
                            </div>
                        </div>
                        <div class="h-48 relative" x-ref="memoryHeatmap">
                            <!-- Heatmap will be rendered here -->
                        </div>
                    </div>

                    <!-- Active Working Memory -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold">Active Working Memory</h3>
                            <div class="flex items-center space-x-2">
                                <span class="text-sm text-gray-400" x-text="`${activeWorkingMemories.length} / ${workingMemoryStats.capacity} slots`"></span>
                                <button @click="clearWorkingMemory()" 
                                        class="px-3 py-1 bg-red-600 hover:bg-red-700 rounded text-xs font-medium transition-colors">
                                    Clear All
                                </button>
                            </div>
                        </div>
                        
                        <!-- Memory Slots -->
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4" 
                             x-ref="workingMemoryContainer"
                             @drop.prevent="handleMemoryDrop($event)"
                             @dragover.prevent="handleMemoryDragOver($event)">
                            <template x-for="(memory, index) in activeWorkingMemories" :key="memory.memory_id">
                                <div class="working-memory-item p-4 bg-white/5 rounded-lg border-2 border-dashed border-transparent hover:border-amber-400/50 transition-all duration-300 cursor-move"
                                     :class="getMemoryActivityClass(memory)"
                                     :draggable="true"
                                     @dragstart="handleMemoryDragStart($event, memory)"
                                     @click="selectWorkingMemory(memory)">
                                    
                                    <!-- Memory Header -->
                                    <div class="flex items-center justify-between mb-2">
                                        <div class="flex items-center space-x-2">
                                            <div class="w-3 h-3 rounded-full" :class="getMemoryTypeColor(memory.memory_type)"></div>
                                            <span class="text-xs font-medium text-gray-300" x-text="memory.memory_type"></span>
                                        </div>
                                        <div class="flex items-center space-x-2">
                                            <!-- Temperature indicator -->
                                            <div class="w-2 h-2 rounded-full" :class="getTemperatureIndicator(memory.temperature)"></div>
                                            <!-- Priority indicator -->
                                            <div class="text-xs" :class="getPriorityColor(memory.priority)" x-text="memory.priority"></div>
                                            <!-- Remove button -->
                                            <button @click.stop="removeFromWorkingMemory(memory)" 
                                                    class="w-4 h-4 rounded-full bg-red-500/20 hover:bg-red-500/40 flex items-center justify-center transition-colors">
                                                <i data-lucide="x" class="w-3 h-3 text-red-400"></i>
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <!-- Memory Content -->
                                    <div class="text-sm text-gray-300 mb-2 line-clamp-2" x-text="memory.content"></div>
                                    
                                    <!-- Memory Metrics -->
                                    <div class="flex items-center justify-between text-xs text-gray-500">
                                        <span x-text="`Importance: ${memory.importance}/10`"></span>
                                        <span x-text="`Last: ${formatRelativeTime(memory.last_accessed_at)}`"></span>
                                    </div>
                                    
                                    <!-- Access frequency indicator -->
                                    <div class="mt-2 h-1 bg-gray-700 rounded-full overflow-hidden">
                                        <div class="h-full bg-amber-400 rounded-full transition-all duration-300" 
                                             :style="`width: ${Math.min(memory.access_frequency * 10, 100)}%`"></div>
                                    </div>
                                </div>
                            </template>
                            
                            <!-- Empty slots -->
                            <template x-for="i in Math.max(0, workingMemoryStats.capacity - activeWorkingMemories.length)" :key="`empty-${i}`">
                                <div class="working-memory-slot p-4 border-2 border-dashed border-gray-600 rounded-lg flex items-center justify-center text-gray-500 hover:border-amber-400/50 transition-colors min-h-[120px]"
                                     @drop.prevent="handleEmptySlotDrop($event, i)"
                                     @dragover.prevent="$event.dataTransfer.dropEffect = 'move'">
                                    <div class="text-center">
                                        <i data-lucide="plus" class="w-6 h-6 mx-auto mb-2 opacity-50"></i>
                                        <div class="text-sm">Empty Slot</div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>

                <!-- Sidebar Controls -->
                <div class="col-span-12 lg:col-span-4 space-y-6">
                    <!-- Optimization Recommendations -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h3 class="text-lg font-semibold mb-4 flex items-center">
                            <i data-lucide="lightbulb" class="w-5 h-5 mr-2 text-yellow-400"></i>
                            Optimization Suggestions
                        </h3>
                        
                        <div class="space-y-3">
                            <template x-for="suggestion in optimizationSuggestions" :key="suggestion.id">
                                <div class="p-3 bg-white/5 rounded-lg border-l-4" :class="getSuggestionBorderClass(suggestion.priority)">
                                    <div class="flex items-start justify-between mb-2">
                                        <div class="flex items-center space-x-2">
                                            <i :data-lucide="suggestion.icon" class="w-4 h-4" :class="getSuggestionIconClass(suggestion.priority)"></i>
                                            <span class="text-sm font-medium" x-text="suggestion.title"></span>
                                        </div>
                                        <div class="flex items-center space-x-1">
                                            <span class="text-xs px-2 py-1 rounded-full" 
                                                  :class="getSuggestionPriorityClass(suggestion.priority)" 
                                                  x-text="suggestion.priority"></span>
                                        </div>
                                    </div>
                                    <p class="text-xs text-gray-400 mb-3" x-text="suggestion.description"></p>
                                    <div class="flex items-center justify-between">
                                        <span class="text-xs text-green-400" x-text="`Impact: ${suggestion.impact}`"></span>
                                        <button @click="applyOptimization(suggestion)" 
                                                :disabled="suggestion.applying"
                                                class="px-3 py-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded text-xs font-medium transition-colors">
                                            <span x-text="suggestion.applying ? 'Applying...' : suggestion.action"></span>
                                        </button>
                                    </div>
                                </div>
                            </template>
                            
                            <div x-show="optimizationSuggestions.length === 0" class="text-center text-gray-500 py-4">
                                <i data-lucide="check-circle" class="w-8 h-8 mx-auto mb-2 opacity-50"></i>
                                <div class="text-sm">Memory is optimally configured</div>
                            </div>
                        </div>
                    </div>

                    <!-- Focus Management -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <h3 class="text-lg font-semibold mb-4 flex items-center">
                            <i data-lucide="target" class="w-5 h-5 mr-2 text-blue-400"></i>
                            Focus Management
                        </h3>
                        
                        <!-- Focus Score Chart -->
                        <div class="mb-4">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-sm text-gray-400">Current Focus Score</span>
                                <span class="text-lg font-bold text-blue-400" x-text="workingMemoryStats.focusScore.toFixed(1) + '%'"></span>
                            </div>
                            <canvas x-ref="focusScoreChart" class="w-full h-32"></canvas>
                        </div>
                        
                        <!-- Focus Controls -->
                        <div class="space-y-3">
                            <div>
                                <label class="block text-sm font-medium mb-2">Focus Mode</label>
                                <select x-model="focusSettings.mode" @change="applyFocusMode()" class="w-full bg-white/10 border border-white/20 rounded-lg px-3 py-2 text-sm">
                                    <option value="normal">Normal</option>
                                    <option value="deep">Deep Focus</option>
                                    <option value="creative">Creative Flow</option>
                                    <option value="analytical">Analytical</option>
                                    <option value="maintenance">Maintenance</option>
                                </select>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium mb-2">Memory Retention (minutes)</label>
                                <input type="range" 
                                       x-model.number="focusSettings.retentionTime" 
                                       @input="updateRetentionTime()"
                                       min="5" max="120" step="5" 
                                       class="w-full">
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>5m</span>
                                    <span x-text="focusSettings.retentionTime + 'm'"></span>
                                    <span>120m</span>
                                </div>
                            </div>
                            
                            <button @click="enterDeepFocus()" 
                                    :disabled="focusSettings.mode === 'deep'"
                                    class="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded-lg text-sm font-medium transition-colors">
                                <i data-lucide="focus" class="w-4 h-4 mr-2 inline"></i>
                                Enter Deep Focus
                            </button>
                        </div>
                    </div>

                    <!-- Memory Pool -->
                    <div class="enhanced-card rounded-2xl p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold flex items-center">
                                <i data-lucide="database" class="w-5 h-5 mr-2 text-gray-400"></i>
                                Memory Pool
                            </h3>
                            <div class="flex items-center space-x-2">
                                <input type="text" 
                                       x-model="memoryPoolSearch" 
                                       @input="filterMemoryPool()"
                                       placeholder="Search..." 
                                       class="w-24 px-2 py-1 bg-white/10 border border-white/20 rounded text-xs">
                                <select x-model="memoryPoolFilter" @change="filterMemoryPool()" class="bg-white/10 border border-white/20 rounded px-2 py-1 text-xs">
                                    <option value="">All</option>
                                    <option value="high">High Priority</option>
                                    <option value="recent">Recent</option>
                                    <option value="related">Related</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="max-h-96 overflow-y-auto space-y-2" x-ref="memoryPool">
                            <template x-for="memory in filteredMemoryPool" :key="memory.memory_id">
                                <div class="memory-pool-item p-3 bg-white/5 rounded-lg cursor-move hover:bg-white/10 transition-colors"
                                     :draggable="true"
                                     @dragstart="handleMemoryDragStart($event, memory)"
                                     @click="addToWorkingMemory(memory)">
                                    <div class="flex items-center justify-between mb-1">
                                        <span class="text-xs font-medium" :class="getMemoryTypeColor(memory.memory_type)" x-text="memory.memory_type"></span>
                                        <span class="text-xs text-gray-500" x-text="`${memory.importance}/10`"></span>
                                    </div>
                                    <div class="text-sm text-gray-300 line-clamp-2" x-text="memory.content"></div>
                                    <div class="flex items-center justify-between mt-2 text-xs text-gray-500">
                                        <span x-text="formatRelativeTime(memory.created_at)"></span>
                                        <div class="flex items-center space-x-1">
                                            <div class="w-2 h-2 rounded-full" :class="getAccessFrequencyColor(memory.access_count)"></div>
                                            <span x-text="`${memory.access_count || 0} acc`"></span>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Enhanced modals -->
         <div x-show="showWorkflowModal" 
          x-transition:enter="transition ease-out duration-300" 
          x-transition:enter-start="opacity-0" 
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-200" 
          x-transition:leave-start="opacity-100" 
          x-transition:leave-end="opacity-0"
          class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4"
          @click="showWorkflowModal = false">
        <div class="enhanced-card rounded-2xl max-w-4xl w-full max-h-[90vh] overflow-y-auto" 
             x-transition:enter="transition ease-out duration-300" 
             x-transition:enter-start="opacity-0 scale-95" 
             x-transition:enter-end="opacity-100 scale-100"
             x-transition:leave="transition ease-in duration-200" 
             x-transition:leave-start="opacity-100 scale-100" 
             x-transition:leave-end="opacity-0 scale-95"
             @click.stop="">
            <div class="p-6">
                <div class="flex items-center justify-between mb-6">
                    <h3 class="text-2xl font-bold">Workflow Details</h3>
                    <button @click="showWorkflowModal = false" 
                            class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                        <i data-lucide="x" class="w-5 h-5"></i>
                    </button>
                </div>
                
                <div x-show="selectedWorkflow" class="space-y-6">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="font-semibold mb-3">Basic Information</h4>
                            <div class="space-y-2 text-sm">
                                <div><span class="text-gray-400">Title:</span> <span x-text="selectedWorkflow?.title"></span></div>
                                <div><span class="text-gray-400">Status:</span> 
                                    <span class="px-2 py-1 text-xs rounded-full ml-2" 
                                          :class="getWorkflowStatusClass(selectedWorkflow?.status)" 
                                          x-text="selectedWorkflow?.status"></span>
                                </div>
                                <div><span class="text-gray-400">Created:</span> <span x-text="formatDate(selectedWorkflow?.created_at)"></span></div>
                                <div><span class="text-gray-400">Updated:</span> <span x-text="formatDate(selectedWorkflow?.updated_at)"></span></div>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold mb-3">Metrics</h4>
                            <div class="grid grid-cols-3 gap-4">
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-blue-400" x-text="selectedWorkflow?.action_count || 0"></div>
                                    <div class="text-xs text-gray-400">Actions</div>
                                </div>
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-green-400" x-text="selectedWorkflow?.memory_count || 0"></div>
                                    <div class="text-xs text-gray-400">Memories</div>
                                </div>
                                <div class="text-center">
                                    <div class="text-2xl font-bold text-purple-400" x-text="selectedWorkflow?.artifact_count || 0"></div>
                                    <div class="text-xs text-gray-400">Artifacts</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h4 class="font-semibold mb-3">Description</h4>
                        <p class="text-gray-300 bg-white/5 p-4 rounded-lg" x-text="selectedWorkflow?.description || selectedWorkflow?.goal || 'No description available'"></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

         <div x-show="showMemoryModal" 
          x-transition:enter="transition ease-out duration-300" 
          x-transition:enter-start="opacity-0" 
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-200" 
          x-transition:leave-start="opacity-100" 
          x-transition:leave-end="opacity-0"
          class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4"
          @click="showMemoryModal = false">
        <div class="enhanced-card rounded-2xl max-w-4xl w-full max-h-[90vh] overflow-y-auto" 
             x-transition:enter="transition ease-out duration-300" 
             x-transition:enter-start="opacity-0 scale-95" 
             x-transition:enter-end="opacity-100 scale-100"
             x-transition:leave="transition ease-in duration-200" 
             x-transition:leave-start="opacity-100 scale-100" 
             x-transition:leave-end="opacity-0 scale-95"
             @click.stop="">
            <div class="p-6">
                <div class="flex items-center justify-between mb-6">
                    <h3 class="text-2xl font-bold">Memory Details</h3>
                    <button @click="showMemoryModal = false" 
                            class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                        <i data-lucide="x" class="w-5 h-5"></i>
                    </button>
                </div>
                
                <div x-show="selectedMemory" class="space-y-6">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h4 class="font-semibold mb-3">Memory Information</h4>
                            <div class="space-y-2 text-sm">
                                <div><span class="text-gray-400">Level:</span> 
                                    <span class="px-2 py-1 text-xs rounded-full ml-2" 
                                          :class="getMemoryLevelClass(selectedMemory?.memory_level)" 
                                          x-text="selectedMemory?.memory_level"></span>
                                </div>
                                <div><span class="text-gray-400">Type:</span> <span x-text="selectedMemory?.memory_type"></span></div>
                                <div><span class="text-gray-400">Importance:</span> <span x-text="selectedMemory?.importance + '/10'"></span></div>
                                <div><span class="text-gray-400">Confidence:</span> <span x-text="Math.round((selectedMemory?.confidence || 0) * 100) + '%'"></span></div>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold mb-3">Access Information</h4>
                            <div class="space-y-2 text-sm">
                                <div><span class="text-gray-400">Created:</span> <span x-text="formatDate(selectedMemory?.created_at)"></span></div>
                                <div><span class="text-gray-400">Last Access:</span> <span x-text="formatDate(selectedMemory?.last_accessed_at)"></span></div>
                                <div><span class="text-gray-400">Access Count:</span> <span x-text="selectedMemory?.access_count || 0"></span></div>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <h4 class="font-semibold mb-3">Content</h4>
                        <div class="bg-white/5 p-4 rounded-lg max-h-64 overflow-y-auto">
                            <pre class="text-sm whitespace-pre-wrap" x-text="selectedMemory?.content"></pre>
                        </div>
                    </div>
                    
                    <div x-show="selectedMemory?.description">
                        <h4 class="font-semibold mb-3">Description</h4>
                        <p class="text-gray-300 bg-white/5 p-4 rounded-lg" x-text="selectedMemory?.description"></p>
                    </div>
                </div>
            </div>
                 </div>
     </div>

     <div x-show="showActionModal" 
          x-transition:enter="transition ease-out duration-300" 
          x-transition:enter-start="opacity-0" 
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-200" 
          x-transition:leave-start="opacity-100" 
          x-transition:leave-end="opacity-0"
          class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4"
          @click="showActionModal = false">
         <div class="enhanced-card rounded-2xl max-w-4xl w-full max-h-[90vh] overflow-y-auto" 
              x-transition:enter="transition ease-out duration-300" 
              x-transition:enter-start="opacity-0 scale-95" 
              x-transition:enter-end="opacity-100 scale-100"
              x-transition:leave="transition ease-in duration-200" 
              x-transition:leave-start="opacity-100 scale-100" 
              x-transition:leave-end="opacity-0 scale-95"
              @click.stop="">
             <div class="p-6">
                 <div class="flex items-center justify-between mb-6">
                     <h3 class="text-2xl font-bold">Action Details</h3>
                     <button @click="showActionModal = false" 
                             class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                         <i data-lucide="x" class="w-5 h-5"></i>
                     </button>
                 </div>
                 
                 <div x-show="selectedAction" class="space-y-6">
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                         <div>
                             <h4 class="font-semibold mb-3">Action Information</h4>
                             <div class="space-y-2 text-sm">
                                 <div><span class="text-gray-400">Type:</span> <span x-text="selectedAction?.action_type"></span></div>
                                 <div><span class="text-gray-400">Status:</span> 
                                     <span class="px-2 py-1 text-xs rounded-full ml-2" 
                                           :class="getActionStatusClass(selectedAction?.status)" 
                                           x-text="selectedAction?.status"></span>
                                 </div>
                                 <div x-show="selectedAction?.tool_name"><span class="text-gray-400">Tool:</span> <span x-text="selectedAction?.tool_name"></span></div>
                                 <div><span class="text-gray-400">Duration:</span> <span x-text="formatDuration(selectedAction?.started_at, selectedAction?.completed_at)"></span></div>
                             </div>
                         </div>
                         
                         <div>
                             <h4 class="font-semibold mb-3">Timing Information</h4>
                             <div class="space-y-2 text-sm">
                                 <div><span class="text-gray-400">Started:</span> <span x-text="formatDate(selectedAction?.started_at)"></span></div>
                                 <div x-show="selectedAction?.completed_at"><span class="text-gray-400">Completed:</span> <span x-text="formatDate(selectedAction?.completed_at)"></span></div>
                                 <div x-show="selectedAction?.workflow_id"><span class="text-gray-400">Workflow:</span> <span x-text="selectedAction?.workflow_id?.substring(0, 8) + '...'"></span></div>
                             </div>
                         </div>
                     </div>
                     
                     <div x-show="selectedAction?.reasoning">
                         <h4 class="font-semibold mb-3">Reasoning</h4>
                         <div class="bg-white/5 p-4 rounded-lg max-h-64 overflow-y-auto">
                             <p class="text-sm whitespace-pre-wrap" x-text="selectedAction?.reasoning"></p>
                         </div>
                     </div>
                     
                     <div x-show="selectedAction?.tool_args">
                         <h4 class="font-semibold mb-3">Tool Arguments</h4>
                         <div class="bg-white/5 p-4 rounded-lg max-h-64 overflow-y-auto">
                             <pre class="text-sm" x-text="JSON.stringify(JSON.parse(selectedAction?.tool_args || '{}'), null, 2)"></pre>
                         </div>
                     </div>
                     
                     <div x-show="selectedAction?.tool_result">
                         <h4 class="font-semibold mb-3">Tool Result</h4>
                         <div class="bg-white/5 p-4 rounded-lg max-h-64 overflow-y-auto">
                             <pre class="text-sm" x-text="JSON.stringify(JSON.parse(selectedAction?.tool_result || '{}'), null, 2)"></pre>
                         </div>
                     </div>
                     
                     <div x-show="selectedAction?.summary">
                         <h4 class="font-semibold mb-3">Summary</h4>
                         <p class="text-gray-300 bg-white/5 p-4 rounded-lg" x-text="selectedAction?.summary"></p>
                     </div>
                 </div>
             </div>
         </div>
     </div>

     <!-- Goal Modal -->
     <div x-show="showGoalModal" 
          x-transition:enter="transition ease-out duration-300" 
          x-transition:enter-start="opacity-0" 
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-200" 
          x-transition:leave-start="opacity-100" 
          x-transition:leave-end="opacity-0"
          class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4"
          @click="showGoalModal = false">
         <div class="enhanced-card rounded-2xl max-w-2xl w-full max-h-[90vh] overflow-y-auto" 
              x-transition:enter="transition ease-out duration-300" 
              x-transition:enter-start="opacity-0 scale-95" 
              x-transition:enter-end="opacity-100 scale-100"
              x-transition:leave="transition ease-in duration-200" 
              x-transition:leave-start="opacity-100 scale-100" 
              x-transition:leave-end="opacity-0 scale-95"
              @click.stop="">
             <div class="p-6">
                 <div class="flex items-center justify-between mb-6">
                     <h3 class="text-2xl font-bold" x-text="editingGoal ? 'Edit Goal' : 'Create New Goal'"></h3>
                     <button @click="showGoalModal = false; editingGoal = null" 
                             class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                         <i data-lucide="x" class="w-5 h-5"></i>
                     </button>
                 </div>
                 
                 <form @submit.prevent="saveGoal()" class="space-y-4">
                     <div>
                         <label class="block text-sm font-medium mb-2">Title *</label>
                         <input type="text" 
                                x-model="goalForm.title" 
                                required 
                                class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400 transition-colors"
                                placeholder="Enter goal title">
                     </div>
                     
                     <div>
                         <label class="block text-sm font-medium mb-2">Description</label>
                         <textarea x-model="goalForm.description" 
                                   rows="3"
                                   class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400 transition-colors"
                                   placeholder="Describe the goal in detail"></textarea>
                     </div>
                     
                     <div class="grid grid-cols-2 gap-4">
                         <div>
                             <label class="block text-sm font-medium mb-2">Priority</label>
                             <select x-model="goalForm.priority" 
                                     class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400">
                                 <option value="low">Low</option>
                                 <option value="medium">Medium</option>
                                 <option value="high">High</option>
                             </select>
                         </div>
                         
                         <div>
                             <label class="block text-sm font-medium mb-2">Status</label>
                             <select x-model="goalForm.status" 
                                     class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400">
                                 <option value="pending">Pending</option>
                                 <option value="active">Active</option>
                                 <option value="in_progress">In Progress</option>
                                 <option value="completed">Completed</option>
                                 <option value="cancelled">Cancelled</option>
                             </select>
                         </div>
                     </div>
                     
                     <div class="grid grid-cols-2 gap-4">
                         <div>
                             <label class="block text-sm font-medium mb-2">Progress (%)</label>
                             <input type="number" 
                                    x-model.number="goalForm.progress" 
                                    min="0" 
                                    max="100"
                                    class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400 transition-colors">
                         </div>
                         
                         <div>
                             <label class="block text-sm font-medium mb-2">Due Date</label>
                             <input type="date" 
                                    x-model="goalForm.due_date"
                                    class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400 transition-colors">
                         </div>
                     </div>
                     
                     <div x-show="!editingGoal">
                         <label class="block text-sm font-medium mb-2">Parent Goal</label>
                         <select x-model="goalForm.parent_goal_id" 
                                 class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400">
                             <option value="">None (Root Goal)</option>
                             <template x-for="goal in goals.filter(g => g.goal_id !== editingGoal?.goal_id)" :key="goal.goal_id">
                                 <option :value="goal.goal_id" x-text="goal.title"></option>
                             </template>
                         </select>
                     </div>
                     
                     <div x-show="editingGoal">
                         <label class="block text-sm font-medium mb-2">Notes</label>
                         <textarea x-model="goalForm.notes" 
                                   rows="2"
                                   class="w-full px-3 py-2 bg-white/10 border border-white/20 rounded-lg focus:outline-none focus:border-yellow-400 transition-colors"
                                   placeholder="Add any updates or notes"></textarea>
                     </div>
                     
                     <div class="flex items-center justify-end space-x-3 pt-4 border-t border-white/10">
                         <button type="button" 
                                 @click="showGoalModal = false; editingGoal = null"
                                 class="px-4 py-2 text-gray-400 hover:text-white transition-colors">
                             Cancel
                         </button>
                         <button type="submit" 
                                 class="px-6 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-lg font-medium transition-colors">
                             <span x-text="editingGoal ? 'Update Goal' : 'Create Goal'"></span>
                         </button>
                     </div>
                 </form>
             </div>
         </div>
     </div>

     <!-- Thought Modal -->
     <div x-show="showThoughtModal" 
          x-transition:enter="transition ease-out duration-300" 
          x-transition:enter-start="opacity-0" 
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-200" 
          x-transition:leave-start="opacity-100" 
          x-transition:leave-end="opacity-0"
          class="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4"
          @click="showThoughtModal = false">
         <div class="enhanced-card rounded-2xl max-w-4xl w-full max-h-[90vh] overflow-y-auto" 
              x-transition:enter="transition ease-out duration-300" 
              x-transition:enter-start="opacity-0 scale-95" 
              x-transition:enter-end="opacity-100 scale-100"
              x-transition:leave="transition ease-in duration-200" 
              x-transition:leave-start="opacity-100 scale-100" 
              x-transition:leave-end="opacity-0 scale-95"
              @click.stop="">
             <div class="p-6">
                 <div class="flex items-center justify-between mb-6">
                     <h3 class="text-2xl font-bold">Thought Details</h3>
                     <button @click="showThoughtModal = false" 
                             class="p-2 rounded-lg hover:bg-white/10 transition-colors">
                         <i data-lucide="x" class="w-5 h-5"></i>
                     </button>
                 </div>
                 
                 <div x-show="selectedThought" class="space-y-6">
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                         <div>
                             <h4 class="font-semibold mb-3">Thought Information</h4>
                             <div class="space-y-2 text-sm">
                                 <div><span class="text-gray-400">Type:</span> 
                                     <span class="px-2 py-1 text-xs rounded-full ml-2 bg-indigo-500/20 text-indigo-400" 
                                           x-text="selectedThought?.memory_type"></span>
                                 </div>
                                 <div><span class="text-gray-400">Level:</span> 
                                     <span class="px-2 py-1 text-xs rounded-full ml-2" 
                                           :class="getMemoryLevelClass(selectedThought?.memory_level)" 
                                           x-text="selectedThought?.memory_level"></span>
                                 </div>
                                 <div><span class="text-gray-400">Importance:</span> <span x-text="selectedThought?.importance + '/10'"></span></div>
                                 <div><span class="text-gray-400">Confidence:</span> <span x-text="Math.round((selectedThought?.confidence || 0) * 100) + '%'"></span></div>
                             </div>
                         </div>
                         
                         <div>
                             <h4 class="font-semibold mb-3">Chain Context</h4>
                             <div class="space-y-2 text-sm">
                                 <div><span class="text-gray-400">Position:</span> <span x-text="`${currentThoughtIndex + 1} of ${thoughtsInCurrentChain.length}`"></span></div>
                                 <div><span class="text-gray-400">Created:</span> <span x-text="formatDate(selectedThought?.created_at)"></span></div>
                                 <div x-show="selectedThought?.workflow_id"><span class="text-gray-400">Workflow:</span> <span x-text="selectedThought?.workflow_id?.substring(0, 8) + '...'"></span></div>
                                 <div x-show="selectedThought?.hasChildren">
                                     <span class="text-gray-400">Branches:</span> 
                                     <span class="text-purple-400">Yes</span>
                                 </div>
                             </div>
                         </div>
                     </div>
                     
                     <div>
                         <h4 class="font-semibold mb-3">Thought Content</h4>
                         <div class="bg-white/5 p-4 rounded-lg max-h-64 overflow-y-auto">
                             <p class="text-sm whitespace-pre-wrap" x-text="selectedThought?.content"></p>
                         </div>
                     </div>
                     
                     <div x-show="selectedThought?.description">
                         <h4 class="font-semibold mb-3">Description</h4>
                         <p class="text-gray-300 bg-white/5 p-4 rounded-lg" x-text="selectedThought?.description"></p>
                     </div>
                     
                     <!-- Chain Navigation in Modal -->
                     <div class="grid grid-cols-2 gap-4">
                         <button @click="navigateToPreviousThought()" 
                                 :disabled="currentThoughtIndex === 0"
                                 class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-600 disabled:opacity-50 rounded-lg text-sm font-medium transition-colors flex items-center justify-center">
                             <i data-lucide="chevron-left" class="w-4 h-4 mr-2"></i>
                             Previous Thought
                         </button>
                         <button @click="navigateToNextThought()" 
                                 :disabled="currentThoughtIndex === thoughtsInCurrentChain.length - 1"
                                 class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-600 disabled:opacity-50 rounded-lg text-sm font-medium transition-colors flex items-center justify-center">
                             Next Thought
                             <i data-lucide="chevron-right" class="w-4 h-4 ml-2"></i>
                         </button>
                     </div>
                 </div>
             </div>
         </div>
     </div>
 
     <!-- Floating Action Button -->
    <button class="fab" @click="showCommandPalette = true" title="Open Command Palette (Ctrl+K)">
        <i data-lucide="command" class="w-6 h-6"></i>
    </button>

    <script>
        // Initialize SQL.js
        let SQL;
        
        async function initializeSqlJs() {
            try {
                if (typeof initSqlJs === 'undefined') {
                    throw new Error('SQL.js library not loaded. Please check your internet connection.');
                }
                SQL = await initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
                });
                console.log('✅ SQL.js initialized successfully');
            } catch (error) {
                console.error('❌ Failed to initialize SQL.js:', error);
                throw error;
            }
        }

        function umsExplorer() {
            return {
                // Core state
                db: null,
                dbLoaded: false,
                isLoading: false,
                isProcessing: false,
                loadingMessage: '',
                currentView: 'dashboard',
                theme: 'dark',
                
                // Navigation and UI
                showCommandPalette: false,
                showSearchSuggestions: false,
                commandQuery: '',
                filteredCommands: [],
                
                // Search
                globalSearch: '',
                searchSuggestions: [],
                
                // Data
                workflows: [],
                memories: [],
                actions: [],
                artifacts: [],
                goals: [],
                
                // Filters
                workflowFilter: '',
                memoryLevelFilter: '',
                memorySearch: '',
                actionStatusFilter: '',
                actionTypeFilter: '',
                actionSearch: '',
                memorySortBy: 'created_at',
                memorySortOrder: 'desc',
                
                // Pagination
                currentPage: 1,
                pageSize: 12,
                
                // Stats
                stats: {
                    totalMemories: 0,
                    totalWorkflows: 0,
                    totalActions: 0,
                    totalGoals: 0,
                    totalLinks: 0
                },
                
                // Selected items
                selectedWorkflow: null,
                selectedMemory: null,
                selectedAction: null,
                showWorkflowModal: false,
                showMemoryModal: false,
                showActionModal: false,
                
                // Recent activity
                recentActivity: [],
                
                // Charts
                charts: {},
                
                // Commands
                commands: [
                    { id: 'search', title: 'Search Everything', description: 'Global search across all data', icon: 'search', shortcut: 'Ctrl+F' },
                    { id: 'workflows', title: 'View Workflows', description: 'Navigate to workflows view', icon: 'git-branch', shortcut: 'W' },
                    { id: 'memories', title: 'View Memories', description: 'Navigate to memories view', icon: 'brain', shortcut: 'M' },
                    { id: 'actions', title: 'View Actions', description: 'Navigate to actions view', icon: 'zap', shortcut: 'R' },
                    { id: 'goals', title: 'Goal Hierarchy', description: 'Interactive goal tree with dependencies', icon: 'target', shortcut: 'L' },
                    { id: 'analytics', title: 'View Analytics', description: 'Navigate to analytics view', icon: 'bar-chart-3', shortcut: 'A' },
                    { id: 'graph', title: 'Memory Graph', description: 'Interactive network visualization', icon: 'network', shortcut: 'G' },
                    { id: 'thought-chains', title: 'Thought Chains', description: 'Reasoning flow diagrams with timeline', icon: 'git-branch-plus', shortcut: 'C' },
                    { id: 'semantic-search', title: 'Semantic Search', description: 'Advanced vector similarity search with clustering', icon: 'search', shortcut: 'S' },
                    { id: 'working-memory', title: 'Working Memory', description: 'Real-time memory management dashboard', icon: 'cpu', shortcut: 'U' },
                    { id: 'workflow-dependencies', title: 'Workflow Dependencies', description: 'Gantt chart + network diagram for workflow scheduling', icon: 'git-merge', shortcut: 'Y' },
                    { id: 'dashboard', title: 'Dashboard', description: 'Go back to dashboard', icon: 'layout-dashboard', shortcut: 'D' },
                    { id: 'theme', title: 'Toggle Theme', description: 'Switch between light and dark mode', icon: 'palette', shortcut: 'T' },
                    { id: 'export', title: 'Export Data', description: 'Export current view as JSON/CSV', icon: 'download', shortcut: 'E' }
                ],
                
                // Graph-specific state
                graphData: { nodes: [], links: [] },
                graphSettings: {
                    layout: 'force',
                    colorBy: 'memory_level',
                    forceStrength: -30,
                    linkDistance: 80,
                    physicsEnabled: true,
                    showLegend: true,
                    visibleLevels: ['working', 'episodic', 'semantic', 'procedural']
                },
                selectedGraphNode: null,
                graphClusters: [],
                graphTooltip: { visible: false, x: 0, y: 0, title: '', subtitle: '', content: '' },
                currentLegend: [],
                
                // D3 objects
                svg: null,
                simulation: null,
                zoom: null,
                
                // Thought Chain state
                thoughtChains: [],
                currentChain: null,
                thoughtTimelinePosition: 0,
                thoughtTimelineLength: 0,
                thoughtsInCurrentChain: [],
                currentThoughtIndex: 0,
                isPlaybackActive: false,
                playbackSpeed: 1,
                playbackInterval: null,
                mermaidDiagram: '',
                chainFilter: '',
                selectedThought: null,
                showThoughtModal: false,
                thoughtChainStats: {
                    totalChains: 0,
                    totalThoughts: 0,
                    avgChainLength: 0,
                    branchingPoints: 0
                },

                // Goal Hierarchy state
                goalTreeData: { children: [] },
                goalTreeSettings: {
                    showCompleted: true,
                    showProgress: true,
                    groupBy: 'none', // 'none', 'priority', 'status', 'owner'
                    sortBy: 'created', // 'created', 'priority', 'progress', 'title'
                    expandLevel: 2 // Auto-expand to this level
                },
                selectedGoal: null,
                goalFilter: '',
                goalSearch: '',
                showGoalModal: false,
                editingGoal: null,
                goalForm: {
                    title: '',
                    description: '',
                    priority: 'medium',
                    status: 'pending',
                    progress: 0,
                    due_date: '',
                    parent_goal_id: '',
                    notes: ''
                },
                isDragging: false,
                draggedGoal: null,
                dropTarget: null,
                goalStats: {
                    total: 0,
                    completed: 0,
                    inProgress: 0,
                    pending: 0,
                    overdue: 0,
                    completionRate: 0
                },

                // Semantic Search state
                semanticQuery: '',
                searchMode: 'hybrid', // 'hybrid', 'semantic', 'structured'
                isSearching: false,
                searchResults: [],
                searchClusters: [],
                searchHistory: [],
                savedSearches: [],
                searchFilters: {
                    memoryLevel: '',
                    memoryType: '',
                    semanticWeight: 0.6,
                    keywordWeight: 0.4,
                    minImportance: null,
                    maxImportance: null,
                    dateRange: null
                },
                searchStats: {
                    totalTime: 0,
                    semanticMatches: 0,
                    keywordMatches: 0,
                    totalConsidered: 0
                },
                showAdvancedOptions: false,
                resultsView: 'list', // 'list', 'clusters', 'context'
                sortBy: 'similarity',
                searchStatusMessage: '',
                searchDebounceTimer: null,

                // Working Memory Dashboard state
                workingMemoryStatus: {
                    connected: false,
                    lastUpdate: null,
                    updateFrequency: 5000 // 5 seconds
                },
                isRefreshingWorkingMemory: false,
                isOptimizing: false,
                workingMemoryStats: {
                    activeCount: 0,
                    capacity: 7, // Working memory capacity (7±2 rule)
                    pressure: 0, // 0-100%
                    temperature: 0, // Activity level
                    focusScore: 0, // 0-100%
                    efficiency: 0, // 0-100%
                    avgRetentionTime: 0,
                    totalAccesses: 0
                },
                activeWorkingMemories: [],
                workingMemorySettings: {
                    autoRefresh: true,
                    notificationEnabled: true,
                    pressureThreshold: 80,
                    temperatureThreshold: 70
                },
                heatmapSettings: {
                    timeframe: '24h',
                    granularity: 'hour'
                },
                memoryHeatmapData: [],
                focusSettings: {
                    mode: 'normal', // 'normal', 'deep', 'creative', 'analytical', 'maintenance'
                    retentionTime: 30, // minutes
                    maxWorkingMemory: 7
                },
                focusHistory: [],
                optimizationSuggestions: [],
                memoryPoolSearch: '',
                memoryPoolFilter: '',
                filteredMemoryPool: [],
                workingMemoryCharts: {},
                workingMemoryInterval: null,
                draggedMemory: null,

                // Cognitive State Timeline state
                cognitiveTimelineData: [],
                cognitiveTimelineSettings: {
                    timeRange: 24, // hours
                    granularity: 'hour'
                },
                timelineStats: {},
                patternAnalysis: {
                    patterns: [],
                    transitions: [],
                    anomalies: [],
                    summary: {}
                },
                selectedTimelineState: null,
                currentTimelineIndex: 0,
                isLoadingTimeline: false,
                isAnalyzingPatterns: false,
                isTimelineAnimating: false,
                timelineAnimationSpeed: 1,
                timelineViewMode: 'timeline', // 'timeline', 'heatmap', 'network'
                timelineInterval: null,
                showTimelineStateModal: false,
                showPatternsModal: false,
                showComparisonModal: false,
                stateComparison: null,

                // Workflow Dependencies state
                dependencyWorkflows: [],
                selectedDependencyWorkflow: null,
                dependencyViewMode: 'combined', // 'combined', 'network', 'gantt'
                simulationMode: false,
                simulationSnapshot: null,
                isDraggingWorkflow: false,
                originalWorkflowTiming: null,
                isOptimizingSchedule: false,
                resourceConflicts: [],
                criticalPathStats: {
                    totalWorkflows: 0,
                    totalDuration: 0,
                    bottlenecks: []
                },
                dependencyFilter: '',
                dependencySimulation: null,
                ganttSvg: null,
                ganttXScale: null,
                ganttYScale: null,

                async init() {
                    console.log('🚀 UMS Explorer Pro initializing...');
                    
                    try {
                        // Initialize SQL.js
                        await initializeSqlJs();
                        
                        // Load theme
                        this.loadTheme();
                        
                        // Initialize commands
                        this.filteredCommands = this.commands;
                        
                        // Setup keyboard shortcuts
                        this.setupKeyboardShortcuts();
                        
                        // Initialize icons
                        this.$nextTick(() => {
                            if (window.lucide) {
                                lucide.createIcons();
                            }
                        });
                        
                        // Initialize Mermaid
                        if (window.mermaid) {
                            mermaid.initialize({
                                startOnLoad: false,
                                theme: 'dark'
                            });
                        }
                        
                        // Watch for view changes
                        this.$watch('currentView', (newView, oldView) => {
                            // Cleanup charts when leaving analytics or working-memory views
                            if (oldView === 'analytics' || oldView === 'working-memory') {
                                this.cleanupCharts();
                            }
                            
                            if (newView === 'analytics') {
                                this.$nextTick(() => this.renderCharts());
                            } else if (newView === 'graph') {
                                this.$nextTick(() => this.initializeGraph());
                            } else if (newView === 'thought-chains') {
                                this.$nextTick(() => this.initializeThoughtChains());
                            } else if (newView === 'goals') {
                                this.$nextTick(() => this.initializeGoalTree());
                            } else if (newView === 'working-memory') {
                                this.$nextTick(() => this.initializeWorkingMemory());
                            } else if (newView === 'workflow-dependencies') {
                                this.$nextTick(() => this.initializeWorkflowDependencies());
                            } else if (newView === 'cognitive-timeline') {
                                this.$nextTick(() => this.initializeCognitiveTimeline());
                            }
                            
                            this.$nextTick(() => {
                                if (window.lucide) {
                                    lucide.createIcons();
                                }
                            });
                        });
                        
                        // Watch for search
                        this.$watch('globalSearch', (query) => {
                            this.updateSearchSuggestions(query);
                        });
                        
                        console.log('✅ UMS Explorer Pro initialized successfully');
                        
                        // Try to auto-load database from default location
                        this.tryAutoLoadDatabase();
                        
                        // Load semantic search state
                        this.loadSemanticSearchState();
                        
                    } catch (error) {
                        console.error('❌ Failed to initialize UMS Explorer:', error);
                        // Show error state to user
                        this.isLoading = false;
                        this.loadingMessage = '';
                        if (window.Toastify) {
                            this.showToast('Failed to initialize application. Please refresh and try again.', 'error');
                        } else {
                            alert('Failed to initialize application. Please refresh and try again.');
                        }
                    }
                },

                async tryAutoLoadDatabase() {
                    try {
                        // Try to fetch the default database file from the server
                        const defaultPaths = [
                            '/storage/unified_agent_memory.db',       // Server route (FastAPI static mount)
                            '../../storage/unified_agent_memory.db',  // Fallback: relative path from tools/ directory
                            '../storage/unified_agent_memory.db',     // Fallback: one level up
                            './storage/unified_agent_memory.db',      // Fallback: same level
                            'storage/unified_agent_memory.db'         // Fallback: direct
                        ];
                        
                        for (const path of defaultPaths) {
                            try {
                                console.log(`🔍 Checking for database at: ${path}`);
                                const response = await fetch(path);
                                if (response.ok) {
                                    console.log(`✅ Found database at: ${path}`);
                                    const arrayBuffer = await response.arrayBuffer();
                                    const data = new Uint8Array(arrayBuffer);
                                    
                                    if (this.db) {
                                        this.db.close();
                                    }
                                    
                                    this.db = new SQL.Database(data);
                                    this.db.exec("PRAGMA foreign_keys = ON;");
                                    this.db.exec("PRAGMA journal_mode = MEMORY;");
                                    
                                    // Test the database
                                    const testResult = this.executeQuery("SELECT count(*) as count FROM sqlite_master WHERE type='table';");
                                    if (testResult && testResult.length > 0) {
                                        this.dbLoaded = true;
                                        await this.loadAllData();
                                        this.showToast(`Database auto-loaded from ${path} 🎉`, 'success');
                                        return; // Exit once we've successfully loaded
                                    }
                                }
                            } catch (pathError) {
                                // Silently continue to next path
                                console.log(`❌ Database not found at: ${path}`);
                            }
                        }
                        
                        console.log('ℹ️ No database found at default locations');
                    } catch (error) {
                        console.log('ℹ️ Auto-load failed, user will need to select database manually');
                    }
                },

                setupKeyboardShortcuts() {
                    document.addEventListener('keydown', (e) => {
                        // Command palette
                        if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                            e.preventDefault();
                            this.showCommandPalette = true;
                        }
                        
                        // Quick navigation (only when not in input)
                        if (!e.target.matches('input, textarea')) {
                            switch(e.key.toLowerCase()) {
                                case 'd':
                                    this.navigateTo('dashboard');
                                    break;
                                case 'w':
                                    this.navigateTo('workflows');
                                    break;
                                case 'm':
                                    this.navigateTo('memories');
                                    break;
                                case 'r':
                                    this.navigateTo('actions');
                                    break;
                                case 'l':
                                    this.navigateTo('goals');
                                    break;
                                case 'a':
                                    this.navigateTo('analytics');
                                    break;
                                case 'g':
                                    this.navigateTo('graph');
                                    break;
                                case 'c':
                                    this.navigateTo('thought-chains');
                                    break;
                                case 's':
                                    this.navigateTo('semantic-search');
                                    break;
                                case 'u':
                                    this.navigateTo('working-memory');
                                    break;
                                case 'y':
                                    this.navigateTo('workflow-dependencies');
                                    break;
                                case 't':
                                    this.toggleTheme();
                                    break;
                                case 'escape':
                                    this.showCommandPalette = false;
                                    this.showWorkflowModal = false;
                                    this.showMemoryModal = false;
                                    this.showActionModal = false;
                                    this.selectedGraphNode = null;
                                    break;
                            }
                        }
                    });
                },

                updateCommands() {
                    if (!this.commandQuery) {
                        this.filteredCommands = this.commands;
                        return;
                    }
                    
                    const query = this.commandQuery.toLowerCase();
                    this.filteredCommands = this.commands.filter(cmd => 
                        cmd.title.toLowerCase().includes(query) || 
                        cmd.description.toLowerCase().includes(query)
                    );
                },

                executeCommand(cmd = null) {
                    if (!cmd && this.filteredCommands.length > 0) {
                        cmd = this.filteredCommands[0];
                    }
                    
                    if (!cmd) return;
                    
                    this.showCommandPalette = false;
                    this.commandQuery = '';
                    
                    switch(cmd.id) {
                        case 'search':
                            document.querySelector('input[placeholder*="Search everything"]')?.focus();
                            break;
                        case 'workflows':
                        case 'memories':
                        case 'actions':
                        case 'goals':
                        case 'analytics':
                        case 'graph':
                        case 'thought-chains':
                        case 'semantic-search':
                        case 'working-memory':
                        case 'workflow-dependencies':
                        case 'dashboard':
                            this.navigateTo(cmd.id);
                            break;
                        case 'theme':
                            this.toggleTheme();
                            break;
                        case 'export':
                            this.exportCurrentView();
                            break;
                    }
                },

                handleFileDrop(event) {
                    event.currentTarget.classList.remove('border-blue-400', 'bg-blue-400/10');
                    const files = event.dataTransfer.files;
                    if (files.length > 0) {
                        this.loadDatabaseFromFile(files[0]);
                    }
                },

                loadDatabase(event) {
                    const file = event.target.files[0];
                    if (file) {
                        this.loadDatabaseFromFile(file);
                    }
                },

                async loadDatabaseFromFile(file) {
                    this.isLoading = true;
                    this.loadingMessage = `Loading ${file.name}...`;
                    
                    try {
                        if (!SQL) {
                            throw new Error('SQL.js not initialized. Please refresh the page and try again.');
                        }
                        
                        const arrayBuffer = await file.arrayBuffer();
                        const data = new Uint8Array(arrayBuffer);
                        
                        if (this.db) {
                            this.db.close();
                        }
                        
                        this.db = new SQL.Database(data);
                        
                        // Set pragmas
                        this.db.exec("PRAGMA foreign_keys = ON;");
                        this.db.exec("PRAGMA journal_mode = MEMORY;");
                        
                        // Test the database
                        const testResult = this.executeQuery("SELECT count(*) as count FROM sqlite_master WHERE type='table';");
                        if (testResult && testResult.length > 0) {
                            this.dbLoaded = true;
                            await this.loadAllData();
                            this.showToast('Database loaded successfully! 🎉', 'success');
                        } else {
                            throw new Error('Invalid database file');
                        }
                        
                    } catch (error) {
                        console.error('Database loading error:', error);
                        this.showToast(`Error loading database: ${error.message}`, 'error');
                        this.dbLoaded = false;
                        if (this.db) {
                            this.db.close();
                            this.db = null;
                        }
                    } finally {
                        this.isLoading = false;
                        this.loadingMessage = '';
                    }
                },

                executeQuery(sql, params = []) {
                    if (!this.db) return [];
                    
                    try {
                        const stmt = this.db.prepare(sql);
                        stmt.bind(params);
                        const results = [];
                        while (stmt.step()) {
                            results.push(stmt.getAsObject());
                        }
                        stmt.free();
                        return results;
                    } catch (error) {
                        console.error('SQL Error:', error, { sql, params });
                        return [];
                    }
                },

                async loadAllData() {
                    this.isProcessing = true;
                    this.loadingMessage = 'Processing data...';
                    
                    try {
                        // Load workflows with counts
                        this.workflows = this.executeQuery(`
                            SELECT w.*, 
                                   COUNT(DISTINCT a.action_id) as action_count,
                                   COUNT(DISTINCT m.memory_id) as memory_count,
                                   COUNT(DISTINCT ar.artifact_id) as artifact_count
                            FROM workflows w
                            LEFT JOIN actions a ON w.workflow_id = a.workflow_id
                            LEFT JOIN memories m ON w.workflow_id = m.workflow_id
                            LEFT JOIN artifacts ar ON w.workflow_id = ar.workflow_id
                            GROUP BY w.workflow_id
                            ORDER BY w.updated_at DESC
                        `);

                        // Load memories
                        this.memories = this.executeQuery(`
                            SELECT * FROM memories 
                            ORDER BY created_at DESC
                        `);

                        // Load actions
                        this.actions = this.executeQuery(`
                            SELECT * FROM actions 
                            ORDER BY started_at DESC
                        `);

                        // Load artifacts
                        this.artifacts = this.executeQuery(`
                            SELECT * FROM artifacts 
                            ORDER BY created_at DESC
                        `);

                        // Load goals
                        this.goals = this.executeQuery(`
                            SELECT * FROM goals 
                            ORDER BY created_at DESC
                        `);

                        // Calculate stats
                        this.stats = {
                            totalMemories: this.memories.length,
                            totalWorkflows: this.workflows.length,
                            totalActions: this.actions.length,
                            totalGoals: this.goals.length,
                            totalLinks: this.executeQuery("SELECT COUNT(*) as count FROM memory_links")[0]?.count || 0
                        };

                        // Generate recent activity
                        this.generateRecentActivity();
                        
                        // Load graph data
                        this.loadingMessage = 'Building graph data...';
                        await this.loadGraphData();
                        
                        // Load thought chain data
                        this.loadingMessage = 'Building thought chains...';
                        await this.loadThoughtChainData();
                        
                        // Load goal tree data
                        this.loadingMessage = 'Building goal hierarchy...';
                        await this.loadGoalTreeData();
                        
                        this.loadingMessage = 'Finalizing...';
                        await new Promise(resolve => setTimeout(resolve, 500)); // Small delay for better UX
                        
                    } catch (error) {
                        console.error('Error loading data:', error);
                        this.showToast('Error loading some data from database', 'warning');
                    } finally {
                        this.isProcessing = false;
                        this.loadingMessage = '';
                    }
                },

                parseActivityContent(content, type) {
                    if (!content) return 'No description available';
                    
                    // Parse thought content like "Thought [1] (Goal): Established new UMS sub-goal: Overall objectives for workflow a1981ba9"
                    if (type === 'thought') {
                        const thoughtMatch = content.match(/Thought \[(\d+)\] \(([^)]+)\): (.+)/);
                        if (thoughtMatch) {
                            const [, number, thoughtType, description] = thoughtMatch;
                            return `${thoughtType} #${number}: ${description}`;
                        }
                    }
                    
                    // Parse goal content 
                    if (type === 'goal') {
                        if (content.includes('Established new UMS sub-goal:')) {
                            return content.replace('Established new UMS sub-goal:', 'New goal:');
                        }
                    }
                    
                    // Parse action content
                    if (type === 'action') {
                        if (content.includes('tool_use:')) {
                            const tool = content.split('tool_use:')[1]?.split(' ')[0];
                            return `Used tool: ${tool}`;
                        }
                    }
                    
                    // Generic parsing - clean up common patterns
                    return content
                        .replace(/workflow [a-f0-9-]+/gi, 'workflow')
                        .replace(/memory [a-f0-9-]+/gi, 'memory')
                        .replace(/action [a-f0-9-]+/gi, 'action')
                        .substring(0, 80) + (content.length > 80 ? '...' : '');
                },

                generateRecentActivity() {
                    const activities = [];
                    
                    // Recent memories with better parsing
                    this.memories.slice(0, 3).forEach(memory => {
                        let title = 'Memory Created';
                        let description = this.parseActivityContent(memory.content, 'memory');
                        let icon = 'brain';
                        
                        // Determine memory type for better context
                        if (memory.memory_type === 'thought') {
                            title = 'Thought Recorded';
                            description = this.parseActivityContent(memory.content, 'thought');
                            icon = 'lightbulb';
                        } else if (memory.memory_type === 'goal') {
                            title = 'Goal Established';
                            description = this.parseActivityContent(memory.content, 'goal');
                            icon = 'target';
                        } else if (memory.memory_type === 'plan') {
                            title = 'Plan Created';
                            icon = 'map';
                        }
                        
                        activities.push({
                            id: memory.memory_id,
                            title,
                            description,
                            timestamp: memory.created_at,
                            icon,
                            type: 'memory'
                        });
                    });
                    
                    // Recent workflows
                    this.workflows.slice(0, 2).forEach(workflow => {
                        activities.push({
                            id: workflow.workflow_id,
                            title: 'Workflow Updated',
                            description: workflow.title || workflow.goal || 'Workflow activity',
                            timestamp: workflow.updated_at,
                            icon: 'git-branch',
                            type: 'workflow'
                        });
                    });
                    
                    // Recent actions with better descriptions
                    this.actions.slice(0, 2).forEach(action => {
                        let title = 'Action Executed';
                        let description = action.title || action.action_type || 'Action performed';
                        let icon = 'zap';
                        
                        if (action.action_type === 'tool_use') {
                            title = 'Tool Used';
                            description = action.tool_name ? `Used ${action.tool_name}` : description;
                            icon = 'wrench';
                        } else if (action.action_type === 'reasoning') {
                            title = 'Analysis Performed';
                            icon = 'brain';
                        } else if (action.action_type === 'planning') {
                            title = 'Planning Session';
                            icon = 'map';
                        }
                        
                        activities.push({
                            id: action.action_id,
                            title,
                            description: this.parseActivityContent(description, 'action'),
                            timestamp: action.started_at,
                            icon,
                            type: 'action'
                        });
                    });
                    
                    // Sort by timestamp
                    this.recentActivity = activities.sort((a, b) => b.timestamp - a.timestamp);
                },

                navigateTo(view) {
                    this.currentView = view;
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                },

                get filteredWorkflows() {
                    if (!this.workflowFilter) return this.workflows;
                    return this.workflows.filter(w => w.status === this.workflowFilter);
                },

                get filteredMemories() {
                    let filtered = this.memories;
                    
                    if (this.memoryLevelFilter) {
                        filtered = filtered.filter(m => m.memory_level === this.memoryLevelFilter);
                    }
                    
                    if (this.memorySearch) {
                        const search = this.memorySearch.toLowerCase();
                        filtered = filtered.filter(m => 
                            m.content?.toLowerCase().includes(search) ||
                            m.memory_type?.toLowerCase().includes(search) ||
                            m.description?.toLowerCase().includes(search)
                        );
                    }
                    
                    // Apply sorting
                    filtered.sort((a, b) => {
                        let aVal = a[this.memorySortBy];
                        let bVal = b[this.memorySortBy];
                        
                        if (this.memorySortBy === 'importance' || this.memorySortBy === 'confidence') {
                            aVal = parseFloat(aVal) || 0;
                            bVal = parseFloat(bVal) || 0;
                        }
                        
                        if (this.memorySortOrder === 'desc') {
                            return bVal > aVal ? 1 : -1;
                        } else {
                            return aVal > bVal ? 1 : -1;
                        }
                    });
                    
                    return filtered;
                },

                get groupedMemories() {
                    const groups = new Map();
                    const filtered = this.filteredMemories;
                    
                    // Group memories by workflow_id
                    filtered.forEach(memory => {
                        const workflowId = memory.workflow_id || 'standalone';
                        if (!groups.has(workflowId)) {
                            const workflow = this.workflows.find(w => w.workflow_id === workflowId);
                            groups.set(workflowId, {
                                workflowId,
                                workflowTitle: workflow?.title || workflow?.goal || (workflowId === 'standalone' ? 'Standalone Memories' : `Workflow ${workflowId.substring(0, 8)}`),
                                memories: [],
                                collapsed: false
                            });
                        }
                        groups.get(workflowId).memories.push(memory);
                    });
                    
                    // Convert to array and sort by memory count (descending)
                    return Array.from(groups.values()).sort((a, b) => b.memories.length - a.memories.length);
                },

                get filteredActions() {
                    let filtered = this.actions;
                    
                    if (this.actionStatusFilter) {
                        filtered = filtered.filter(a => a.status === this.actionStatusFilter);
                    }
                    
                    if (this.actionTypeFilter) {
                        filtered = filtered.filter(a => a.action_type === this.actionTypeFilter);
                    }
                    
                    if (this.actionSearch) {
                        const search = this.actionSearch.toLowerCase();
                        filtered = filtered.filter(a => 
                            a.title?.toLowerCase().includes(search) ||
                            a.action_type?.toLowerCase().includes(search) ||
                            a.tool_name?.toLowerCase().includes(search) ||
                            a.reasoning?.toLowerCase().includes(search) ||
                            a.summary?.toLowerCase().includes(search)
                        );
                    }
                    
                    return filtered;
                },

                get sortedSearchResults() {
                    if (!this.searchResults.length) return [];
                    
                    return [...this.searchResults].sort((a, b) => {
                        switch (this.sortBy) {
                            case 'similarity':
                                return (b.similarity || 0) - (a.similarity || 0);
                            case 'hybrid':
                                return (b.hybrid_score || 0) - (a.hybrid_score || 0);
                            case 'importance':
                                return b.importance - a.importance;
                            case 'created_at':
                                return b.created_at - a.created_at;
                            default:
                                return 0;
                        }
                    });
                },

                loadMore() {
                    this.currentPage++;
                },

                selectWorkflow(workflow) {
                    this.selectedWorkflow = workflow;
                    this.showWorkflowModal = true;
                },

                selectMemory(memory) {
                    this.selectedMemory = memory;
                    this.showMemoryModal = true;
                },

                selectAction(action) {
                    this.selectedAction = action;
                    this.showActionModal = true;
                },

                performGlobalSearch() {
                    // Implement global search logic
                    console.log('Performing global search:', this.globalSearch);
                },

                updateSearchSuggestions(query) {
                    if (!query || query.length < 2) {
                        this.searchSuggestions = [];
                        return;
                    }
                    
                    const suggestions = [];
                    const search = query.toLowerCase();
                    
                    // Search workflows
                    this.workflows.forEach(w => {
                        if (w.title?.toLowerCase().includes(search)) {
                            suggestions.push({
                                id: w.workflow_id,
                                title: w.title,
                                type: 'Workflow',
                                icon: 'git-branch'
                            });
                        }
                    });
                    
                    // Search memories
                    this.memories.forEach(m => {
                        if (m.content?.toLowerCase().includes(search)) {
                            suggestions.push({
                                id: m.memory_id,
                                title: m.content.substring(0, 50) + '...',
                                type: 'Memory',
                                icon: 'brain'
                            });
                        }
                    });
                    
                    this.searchSuggestions = suggestions.slice(0, 10);
                },

                selectSearchSuggestion(suggestion) {
                    this.showSearchSuggestions = false;
                    this.globalSearch = '';
                    
                    if (suggestion.type === 'Workflow') {
                        const workflow = this.workflows.find(w => w.workflow_id === suggestion.id);
                        if (workflow) this.selectWorkflow(workflow);
                    } else if (suggestion.type === 'Memory') {
                        const memory = this.memories.find(m => m.memory_id === suggestion.id);
                        if (memory) this.selectMemory(memory);
                    }
                },

                showToast(message, type = 'info') {
                    const colors = {
                        success: '#10b981',
                        error: '#ef4444',
                        warning: '#f59e0b',
                        info: '#3b82f6'
                    };
                    
                    Toastify({
                        text: message,
                        duration: 4000,
                        gravity: "top",
                        position: "right",
                        style: {
                            background: colors[type]
                        },
                        className: type,
                        close: true
                    }).showToast();
                },

                getWorkflowStatusClass(status) {
                    const classes = {
                        active: 'bg-green-500/20 text-green-400',
                        completed: 'bg-blue-500/20 text-blue-400',
                        paused: 'bg-yellow-500/20 text-yellow-400',
                        failed: 'bg-red-500/20 text-red-400',
                        abandoned: 'bg-gray-500/20 text-gray-400'
                    };
                    return classes[status] || 'bg-gray-500/20 text-gray-400';
                },

                getMemoryLevelClass(level) {
                    const classes = {
                        working: 'bg-yellow-500/20 text-yellow-400',
                        episodic: 'bg-blue-500/20 text-blue-400',
                        semantic: 'bg-green-500/20 text-green-400',
                        procedural: 'bg-purple-500/20 text-purple-400'
                    };
                    return classes[level] || 'bg-gray-500/20 text-gray-400';
                },

                getActionStatusClass(status) {
                    const classes = {
                        completed: 'bg-green-500/20 text-green-400',
                        in_progress: 'bg-blue-500/20 text-blue-400',
                        failed: 'bg-red-500/20 text-red-400',
                        planned: 'bg-yellow-500/20 text-yellow-400',
                        skipped: 'bg-gray-500/20 text-gray-400'
                    };
                    return classes[status] || 'bg-gray-500/20 text-gray-400';
                },

                getActionIcon(actionType) {
                    const icons = {
                        tool_use: 'wrench',
                        reasoning: 'brain',
                        planning: 'map',
                        analysis: 'search',
                        research: 'book-open',
                        decision: 'check-circle',
                        observation: 'eye',
                        reflection: 'mirror',
                        summary: 'file-text',
                        consolidation: 'layers',
                        memory_operation: 'database'
                    };
                    return icons[actionType] || 'zap';
                },

                formatDuration(startTime, endTime) {
                    if (!startTime) return 'N/A';
                    if (!endTime) return 'In progress';
                    
                    const duration = endTime - startTime;
                    if (duration < 60) return `${Math.round(duration)}s`;
                    if (duration < 3600) return `${Math.round(duration / 60)}m`;
                    return `${Math.round(duration / 3600)}h`;
                },

                formatDate(timestamp) {
                    if (!timestamp) return 'N/A';
                    return new Date(timestamp * 1000).toLocaleDateString();
                },

                formatRelativeTime(timestamp) {
                    if (!timestamp) return 'N/A';
                    const now = Date.now();
                    const time = timestamp * 1000;
                    const diff = now - time;
                    
                    const minute = 60 * 1000;
                    const hour = minute * 60;
                    const day = hour * 24;
                    
                    if (diff < minute) return 'Just now';
                    if (diff < hour) return Math.floor(diff / minute) + 'm ago';
                    if (diff < day) return Math.floor(diff / hour) + 'h ago';
                    return Math.floor(diff / day) + 'd ago';
                },

                loadTheme() {
                    const savedTheme = localStorage.getItem('ums-explorer-theme') || 'dark';
                    this.theme = savedTheme;
                    document.documentElement.setAttribute('data-theme', savedTheme);
                },

                toggleTheme() {
                    this.theme = this.theme === 'dark' ? 'light' : 'dark';
                    document.documentElement.setAttribute('data-theme', this.theme);
                    localStorage.setItem('ums-explorer-theme', this.theme);
                    this.showToast(`Switched to ${this.theme} mode`, 'info');
                },

                async renderCharts() {
                    if (!this.dbLoaded || !window.Chart) return;
                    
                    await this.$nextTick();
                    
                    try {
                        await this.renderMemoryLevelChart();
                        await this.renderMemoryTypeChart();
                        await this.renderWorkflowStatusChart();
                        await this.renderActivityChart();
                    } catch (error) {
                        console.error('Error rendering charts:', error);
                    }
                },

                async renderMemoryLevelChart() {
                    const canvas = this.$refs.memoryLevelChart;
                    if (!canvas) return;
                    
                    // Clear any existing chart first
                    if (this.charts.memoryLevel) {
                        this.charts.memoryLevel.destroy();
                        this.charts.memoryLevel = null;
                    }
                    
                    // Reset canvas dimensions
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 256;
                    canvas.style.width = '';
                    canvas.style.height = '256px';
                    
                    const levels = {};
                    this.memories.forEach(m => {
                        levels[m.memory_level] = (levels[m.memory_level] || 0) + 1;
                    });
                    
                    this.charts.memoryLevel = new Chart(canvas, {
                        type: 'doughnut',
                        data: {
                            labels: Object.keys(levels),
                            datasets: [{
                                data: Object.values(levels),
                                backgroundColor: ['#f59e0b', '#3b82f6', '#10b981', '#8b5cf6'],
                                borderWidth: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        color: '#e5e7eb',
                                        usePointStyle: true,
                                        padding: 20
                                    }
                                }
                            }
                        }
                    });
                },

                async renderMemoryTypeChart() {
                    const canvas = this.$refs.memoryTypeChart;
                    if (!canvas) return;
                    
                    // Clear any existing chart first
                    if (this.charts.memoryType) {
                        this.charts.memoryType.destroy();
                        this.charts.memoryType = null;
                    }
                    
                    // Reset canvas dimensions
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 256;
                    canvas.style.width = '';
                    canvas.style.height = '256px';
                    
                    const types = {};
                    this.memories.forEach(m => {
                        types[m.memory_type] = (types[m.memory_type] || 0) + 1;
                    });
                    
                    const sortedTypes = Object.entries(types)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 8);
                    
                    this.charts.memoryType = new Chart(canvas, {
                        type: 'bar',
                        data: {
                            labels: sortedTypes.map(([type]) => type),
                            datasets: [{
                                label: 'Count',
                                data: sortedTypes.map(([, count]) => count),
                                backgroundColor: '#3b82f6',
                                borderRadius: 8
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                x: {
                                    ticks: {
                                        color: '#9ca3af',
                                        maxRotation: 45
                                    },
                                    grid: {
                                        display: false
                                    }
                                },
                                y: {
                                    ticks: {
                                        color: '#9ca3af'
                                    },
                                    grid: {
                                        color: 'rgba(156, 163, 175, 0.1)'
                                    }
                                }
                            }
                        }
                    });
                },

                async renderWorkflowStatusChart() {
                    const canvas = this.$refs.workflowStatusChart;
                    if (!canvas) return;
                    
                    // Clear any existing chart first
                    if (this.charts.workflowStatus) {
                        this.charts.workflowStatus.destroy();
                        this.charts.workflowStatus = null;
                    }
                    
                    // Reset canvas dimensions
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 256;
                    canvas.style.width = '';
                    canvas.style.height = '256px';
                    
                    const statuses = {};
                    this.workflows.forEach(w => {
                        statuses[w.status] = (statuses[w.status] || 0) + 1;
                    });
                    
                    this.charts.workflowStatus = new Chart(canvas, {
                        type: 'pie',
                        data: {
                            labels: Object.keys(statuses),
                            datasets: [{
                                data: Object.values(statuses),
                                backgroundColor: ['#10b981', '#3b82f6', '#f59e0b', '#ef4444', '#6b7280'],
                                borderWidth: 0
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        color: '#e5e7eb',
                                        usePointStyle: true,
                                        padding: 20
                                    }
                                }
                            }
                        }
                    });
                },

                async renderActivityChart() {
                    const canvas = this.$refs.activityChart;
                    if (!canvas) return;
                    
                    // Clear any existing chart first
                    if (this.charts.activity) {
                        this.charts.activity.destroy();
                        this.charts.activity = null;
                    }
                    
                    // Reset canvas dimensions
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 256;
                    canvas.style.width = '';
                    canvas.style.height = '256px';
                    
                    // Create activity timeline
                    const now = new Date();
                    const days = [];
                    const activityCounts = [];
                    
                    for (let i = 6; i >= 0; i--) {
                        const date = new Date(now);
                        date.setDate(date.getDate() - i);
                        days.push(date.toLocaleDateString('en-US', { weekday: 'short' }));
                        
                        const dayStart = new Date(date);
                        dayStart.setHours(0, 0, 0, 0);
                        const dayEnd = new Date(date);
                        dayEnd.setHours(23, 59, 59, 999);
                        
                        const count = this.memories.filter(m => {
                            const memDate = new Date(m.created_at * 1000);
                            return memDate >= dayStart && memDate <= dayEnd;
                        }).length;
                        
                        activityCounts.push(count);
                    }
                    
                    this.charts.activity = new Chart(canvas, {
                        type: 'line',
                        data: {
                            labels: days,
                            datasets: [{
                                label: 'Memories Created',
                                data: activityCounts,
                                borderColor: '#10b981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                fill: true,
                                tension: 0.4,
                                pointBackgroundColor: '#10b981',
                                pointBorderColor: '#10b981',
                                pointRadius: 6,
                                pointHoverRadius: 8
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                x: {
                                    ticks: {
                                        color: '#9ca3af'
                                    },
                                    grid: {
                                        display: false
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        color: '#9ca3af',
                                        stepSize: 1
                                    },
                                    grid: {
                                        color: 'rgba(156, 163, 175, 0.1)'
                                    }
                                }
                            }
                        }
                    });
                },

                exportCurrentView() {
                    // Implement export functionality
                    this.showToast('Export functionality coming soon!', 'info');
                },

                cleanupCharts() {
                    // Cleanup all Chart.js instances to prevent memory leaks
                    if (this.charts) {
                        Object.values(this.charts).forEach(chart => {
                            if (chart && typeof chart.destroy === 'function') {
                                chart.destroy();
                            }
                        });
                        this.charts = {};
                    }
                    
                    if (this.workingMemoryCharts) {
                        Object.values(this.workingMemoryCharts).forEach(chart => {
                            if (chart && typeof chart.destroy === 'function') {
                                chart.destroy();
                            }
                        });
                        this.workingMemoryCharts = {};
                    }
                },

                // =================== GRAPH METHODS ===================

                async loadGraphData() {
                    try {
                        // Load memory links
                        const links = this.executeQuery(`
                            SELECT ml.*, 
                                   m1.memory_type as source_type,
                                   m1.memory_level as source_level,
                                   m1.content as source_content,
                                   m1.importance as source_importance,
                                   m2.memory_type as target_type,
                                   m2.memory_level as target_level,
                                   m2.content as target_content,
                                   m2.importance as target_importance
                            FROM memory_links ml
                            LEFT JOIN memories m1 ON ml.source_memory_id = m1.memory_id
                            LEFT JOIN memories m2 ON ml.target_memory_id = m2.memory_id
                            WHERE m1.memory_id IS NOT NULL AND m2.memory_id IS NOT NULL
                        `);

                        // Create nodes from memories
                        const nodeMap = new Map();
                        
                        // Add all memories as potential nodes
                        this.memories.forEach(memory => {
                            nodeMap.set(memory.memory_id, {
                                id: memory.memory_id,
                                ...memory,
                                x: Math.random() * 800,
                                y: Math.random() * 600,
                                connections: 0,
                                cluster: null
                            });
                        });
                        
                        // Process links and update connection counts
                        const processedLinks = [];
                        links.forEach(link => {
                            if (nodeMap.has(link.source_memory_id) && nodeMap.has(link.target_memory_id)) {
                                processedLinks.push({
                                    source: link.source_memory_id,
                                    target: link.target_memory_id,
                                    link_type: link.link_type,
                                    strength: link.strength || 1,
                                    created_at: link.created_at
                                });
                                
                                // Update connection counts
                                nodeMap.get(link.source_memory_id).connections++;
                                nodeMap.get(link.target_memory_id).connections++;
                            }
                        });
                        
                        // Only include nodes that have connections
                        const connectedNodes = Array.from(nodeMap.values()).filter(node => node.connections > 0);
                        
                        this.graphData = {
                            nodes: connectedNodes,
                            links: processedLinks
                        };
                        
                        // Generate clusters
                        this.generateClusters();
                        
                        console.log(`Graph loaded: ${this.graphData.nodes.length} nodes, ${this.graphData.links.length} links`);
                        
                    } catch (error) {
                        console.error('Error loading graph data:', error);
                        this.showToast('Error loading graph data', 'error');
                    }
                },

                generateClusters() {
                    // Simple clustering by memory level and type
                    const clusters = new Map();
                    
                    this.graphData.nodes.forEach(node => {
                        const clusterKey = `${node.memory_level}-${node.memory_type}`;
                        if (!clusters.has(clusterKey)) {
                            clusters.set(clusterKey, {
                                id: clusterKey,
                                label: `${node.memory_level} - ${node.memory_type}`,
                                nodes: [],
                                color: this.getNodeColor(node)
                            });
                        }
                        clusters.get(clusterKey).nodes.push(node);
                        node.cluster = clusterKey;
                    });
                    
                    this.graphClusters = Array.from(clusters.values());
                },

                async initializeGraph() {
                    if (!window.d3 || !this.graphData.nodes.length) {
                        console.log('D3 not available or no graph data');
                        return;
                    }
                    
                    try {
                        const svg = d3.select(this.$refs.graphSvg);
                        const container = this.$refs.graphSvg.parentElement;
                        const rect = container.getBoundingClientRect();
                        
                        const width = rect.width;
                        const height = rect.height;
                        
                        // Clear previous content
                        svg.selectAll("*").remove();
                        
                        // Set dimensions
                        svg.attr("width", width).attr("height", height);
                        
                        // Initialize zoom
                        this.zoom = d3.zoom()
                            .scaleExtent([0.1, 10])
                            .on("zoom", (event) => {
                                svg.select(".graph-content").attr("transform", event.transform);
                            });
                        
                        svg.call(this.zoom);
                        
                        // Create main group for all graph content
                        const g = svg.append("g").attr("class", "graph-content");
                        
                        // Initialize force simulation
                        this.simulation = d3.forceSimulation(this.graphData.nodes)
                            .force("link", d3.forceLink(this.graphData.links)
                                .id(d => d.id)
                                .distance(this.graphSettings.linkDistance))
                            .force("charge", d3.forceManyBody()
                                .strength(this.graphSettings.forceStrength))
                            .force("center", d3.forceCenter(width / 2, height / 2))
                            .force("collision", d3.forceCollide().radius(15));
                        
                        // Draw links
                        const link = g.append("g")
                            .attr("class", "links")
                            .selectAll("line")
                            .data(this.graphData.links)
                            .enter().append("line")
                            .attr("class", "graph-link")
                            .attr("stroke", d => this.getLinkColor(d.link_type))
                            .attr("stroke-width", d => Math.sqrt(d.strength || 1) * 2);
                        
                        // Draw nodes
                        const node = g.append("g")
                            .attr("class", "nodes")
                            .selectAll("circle")
                            .data(this.graphData.nodes)
                            .enter().append("circle")
                            .attr("class", "graph-node")
                            .attr("r", d => Math.max(5, Math.min(15, 5 + Math.sqrt(d.connections * 2))))
                            .attr("fill", d => this.getNodeColor(d))
                            .attr("stroke", d => d3.color(this.getNodeColor(d)).darker(1))
                            .call(this.createDrag());
                        
                        // Add labels
                        const labels = g.append("g")
                            .attr("class", "labels")
                            .selectAll("text")
                            .data(this.graphData.nodes)
                            .enter().append("text")
                            .attr("class", "graph-text")
                            .text(d => d.memory_type.substring(0, 8))
                            .attr("dy", "0.35em");
                        
                        // Add interactions
                        node
                            .on("mouseover", (event, d) => this.showGraphTooltip(event, d))
                            .on("mouseout", () => this.hideGraphTooltip())
                            .on("click", (event, d) => this.selectGraphNode(d));
                        
                        // Update positions on simulation tick
                        this.simulation.on("tick", () => {
                            link
                                .attr("x1", d => d.source.x)
                                .attr("y1", d => d.source.y)
                                .attr("x2", d => d.target.x)
                                .attr("y2", d => d.target.y);
                            
                            node
                                .attr("cx", d => d.x)
                                .attr("cy", d => d.y);
                            
                            labels
                                .attr("x", d => d.x)
                                .attr("y", d => d.y + 20);
                        });
                        
                        // Store references
                        this.svg = svg;
                        this.updateLegend();
                        
                        console.log('Graph initialized successfully');
                        
                    } catch (error) {
                        console.error('Error initializing graph:', error);
                        this.showToast('Error initializing graph', 'error');
                    }
                },

                createDrag() {
                    return d3.drag()
                        .on("start", (event, d) => {
                            if (!event.active) this.simulation.alphaTarget(0.3).restart();
                            d.fx = d.x;
                            d.fy = d.y;
                        })
                        .on("drag", (event, d) => {
                            d.fx = event.x;
                            d.fy = event.y;
                        })
                        .on("end", (event, d) => {
                            if (!event.active) this.simulation.alphaTarget(0);
                            d.fx = null;
                            d.fy = null;
                        });
                },

                getNodeColor(node) {
                    switch (this.graphSettings.colorBy) {
                        case 'memory_level':
                            const levelColors = {
                                working: '#f59e0b',
                                episodic: '#3b82f6',
                                semantic: '#10b981',
                                procedural: '#8b5cf6'
                            };
                            return levelColors[node.memory_level] || '#6b7280';
                        
                        case 'memory_type':
                            // Generate color based on memory type hash
                            const hash = node.memory_type.split('').reduce((a, b) => {
                                a = ((a << 5) - a) + b.charCodeAt(0);
                                return a & a;
                            }, 0);
                            const hue = Math.abs(hash) % 360;
                            return `hsl(${hue}, 70%, 60%)`;
                        
                        case 'workflow':
                            if (!node.workflow_id) return '#6b7280';
                            const workflowHash = node.workflow_id.split('').reduce((a, b) => {
                                a = ((a << 5) - a) + b.charCodeAt(0);
                                return a & a;
                            }, 0);
                            const workflowHue = Math.abs(workflowHash) % 360;
                            return `hsl(${workflowHue}, 60%, 50%)`;
                        
                        case 'importance':
                            const importance = node.importance || 0;
                            const intensity = importance / 10;
                            return d3.interpolateReds(intensity);
                        
                        default:
                            return '#3b82f6';
                    }
                },

                getLinkColor(linkType) {
                    const colors = {
                        'references': '#3b82f6',
                        'causal': '#10b981',
                        'similarity': '#8b5cf6',
                        'temporal': '#f59e0b',
                        'spatial': '#ef4444'
                    };
                    return colors[linkType] || '#6b7280';
                },

                updateLegend() {
                    const legend = [];
                    
                    switch (this.graphSettings.colorBy) {
                        case 'memory_level':
                            legend.push(
                                { key: 'working', label: 'Working', color: '#f59e0b' },
                                { key: 'episodic', label: 'Episodic', color: '#3b82f6' },
                                { key: 'semantic', label: 'Semantic', color: '#10b981' },
                                { key: 'procedural', label: 'Procedural', color: '#8b5cf6' }
                            );
                            break;
                        
                        case 'memory_type':
                            const types = [...new Set(this.graphData.nodes.map(n => n.memory_type))];
                            types.slice(0, 8).forEach(type => {
                                const hash = type.split('').reduce((a, b) => {
                                    a = ((a << 5) - a) + b.charCodeAt(0);
                                    return a & a;
                                }, 0);
                                const hue = Math.abs(hash) % 360;
                                legend.push({
                                    key: type,
                                    label: type,
                                    color: `hsl(${hue}, 70%, 60%)`
                                });
                            });
                            break;
                        
                        case 'importance':
                            legend.push(
                                { key: 'low', label: 'Low (1-3)', color: d3.interpolateReds(0.3) },
                                { key: 'medium', label: 'Medium (4-6)', color: d3.interpolateReds(0.6) },
                                { key: 'high', label: 'High (7-10)', color: d3.interpolateReds(0.9) }
                            );
                            break;
                    }
                    
                    this.currentLegend = legend;
                },

                showGraphTooltip(event, node) {
                    this.graphTooltip = {
                        visible: true,
                        x: event.pageX + 10,
                        y: event.pageY - 10,
                        title: node.memory_type,
                        subtitle: `${node.memory_level} • ${node.connections} connections`,
                        content: node.content.substring(0, 100) + (node.content.length > 100 ? '...' : '')
                    };
                },

                hideGraphTooltip() {
                    this.graphTooltip.visible = false;
                },

                selectGraphNode(node) {
                    this.selectedGraphNode = node;
                    
                    // Highlight connected nodes and links
                    if (this.svg) {
                        this.svg.selectAll('.graph-node')
                            .classed('selected', d => d.id === node.id);
                        
                        this.svg.selectAll('.graph-link')
                            .classed('highlighted', d => 
                                d.source.id === node.id || d.target.id === node.id
                            );
                    }
                },

                getNodeConnections(node) {
                    if (!node) return [];
                    
                    return this.graphData.links
                        .filter(link => link.source.id === node.id || link.target.id === node.id)
                        .map(link => ({
                            id: link.source.id === node.id ? link.target.id : link.source.id,
                            target: link.source.id === node.id ? link.target : link.source,
                            link_type: link.link_type,
                            strength: link.strength
                        }));
                },

                focusOnNode(node) {
                    this.selectGraphNode(node);
                    
                    if (this.svg && this.zoom) {
                        const scale = 2;
                        const translate = [
                            this.svg.node().clientWidth / 2 - node.x * scale,
                            this.svg.node().clientHeight / 2 - node.y * scale
                        ];
                        
                        this.svg.transition().duration(750).call(
                            this.zoom.transform,
                            d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale)
                        );
                    }
                },

                expandNeighborhood(node) {
                    // Find neighbors that aren't currently visible
                    const connectedIds = new Set(this.getNodeConnections(node).map(c => c.id));
                    const visibleIds = new Set(this.graphData.nodes.map(n => n.id));
                    
                    // Add any missing connected memories to the graph
                    const nodesToAdd = this.memories.filter(memory => 
                        connectedIds.has(memory.memory_id) && !visibleIds.has(memory.memory_id)
                    );
                    
                    if (nodesToAdd.length > 0) {
                        this.graphData.nodes.push(...nodesToAdd.map(memory => ({
                            id: memory.memory_id,
                            ...memory,
                            x: node.x + (Math.random() - 0.5) * 100,
                            y: node.y + (Math.random() - 0.5) * 100,
                            connections: 0,
                            cluster: null
                        })));
                        
                        this.initializeGraph();
                        this.showToast(`Expanded neighborhood: +${nodesToAdd.length} nodes`, 'success');
                    } else {
                        this.showToast('No additional connections to expand', 'info');
                    }
                },

                updateGraphLayout() {
                    if (!this.simulation) return;
                    
                    switch (this.graphSettings.layout) {
                        case 'force':
                            this.simulation
                                .force("charge", d3.forceManyBody().strength(this.graphSettings.forceStrength))
                                .force("center", d3.forceCenter(
                                    this.svg.node().clientWidth / 2, 
                                    this.svg.node().clientHeight / 2
                                ));
                            break;
                        
                        case 'hierarchical':
                            this.applyHierarchicalLayout();
                            break;
                        
                        case 'circular':
                            this.applyCircularLayout();
                            break;
                        
                        case 'cluster':
                            this.applyClusterLayout();
                            break;
                    }
                    
                    this.simulation.alpha(1).restart();
                },

                applyHierarchicalLayout() {
                    const levels = ['working', 'episodic', 'semantic', 'procedural'];
                    const width = this.svg.node().clientWidth;
                    const height = this.svg.node().clientHeight;
                    
                    this.graphData.nodes.forEach((node, i) => {
                        const levelIndex = levels.indexOf(node.memory_level);
                        node.fx = (levelIndex + 1) * (width / (levels.length + 1));
                        node.fy = (i % 10) * (height / 10) + height / 20;
                    });
                },

                applyCircularLayout() {
                    const width = this.svg.node().clientWidth;
                    const height = this.svg.node().clientHeight;
                    const radius = Math.min(width, height) / 3;
                    const centerX = width / 2;
                    const centerY = height / 2;
                    
                    this.graphData.nodes.forEach((node, i) => {
                        const angle = (i / this.graphData.nodes.length) * 2 * Math.PI;
                        node.fx = centerX + radius * Math.cos(angle);
                        node.fy = centerY + radius * Math.sin(angle);
                    });
                },

                applyClusterLayout() {
                    const width = this.svg.node().clientWidth;
                    const height = this.svg.node().clientHeight;
                    const clusters = this.graphClusters;
                    
                    clusters.forEach((cluster, clusterIndex) => {
                        const clusterCenterX = (clusterIndex % 3) * (width / 3) + width / 6;
                        const clusterCenterY = Math.floor(clusterIndex / 3) * (height / 3) + height / 6;
                        const clusterRadius = 80;
                        
                        cluster.nodes.forEach((node, nodeIndex) => {
                            const angle = (nodeIndex / cluster.nodes.length) * 2 * Math.PI;
                            node.fx = clusterCenterX + clusterRadius * Math.cos(angle);
                            node.fy = clusterCenterY + clusterRadius * Math.sin(angle);
                        });
                    });
                },

                updateGraphColors() {
                    if (!this.svg) return;
                    
                    this.svg.selectAll('.graph-node')
                        .attr('fill', d => this.getNodeColor(d))
                        .attr('stroke', d => d3.color(this.getNodeColor(d)).darker(1));
                    
                    this.updateLegend();
                },

                updatePhysics() {
                    if (!this.simulation) return;
                    
                    this.simulation
                        .force("charge", d3.forceManyBody().strength(this.graphSettings.forceStrength))
                        .force("link", d3.forceLink(this.graphData.links)
                            .id(d => d.id)
                            .distance(this.graphSettings.linkDistance));
                    
                    this.simulation.alpha(0.3).restart();
                },

                togglePhysics() {
                    this.graphSettings.physicsEnabled = !this.graphSettings.physicsEnabled;
                    
                    if (this.simulation) {
                        if (this.graphSettings.physicsEnabled) {
                            this.simulation.alpha(0.3).restart();
                        } else {
                            this.simulation.stop();
                        }
                    }
                },

                toggleMemoryLevel(level) {
                    const index = this.graphSettings.visibleLevels.indexOf(level);
                    if (index > -1) {
                        this.graphSettings.visibleLevels.splice(index, 1);
                    } else {
                        this.graphSettings.visibleLevels.push(level);
                    }
                    
                    this.filterGraphNodes();
                },

                filterGraphNodes() {
                    if (!this.svg) return;
                    
                    this.svg.selectAll('.graph-node')
                        .style('opacity', d => 
                            this.graphSettings.visibleLevels.includes(d.memory_level) ? 1 : 0.1
                        );
                    
                    this.svg.selectAll('.graph-link')
                        .style('opacity', d => 
                            this.graphSettings.visibleLevels.includes(d.source.memory_level) && 
                            this.graphSettings.visibleLevels.includes(d.target.memory_level) ? 0.6 : 0.1
                        );
                },

                resetGraphView() {
                    if (this.zoom && this.svg) {
                        this.svg.transition().duration(750).call(
                            this.zoom.transform,
                            d3.zoomIdentity
                        );
                    }
                    
                    this.selectedGraphNode = null;
                    
                    if (this.svg) {
                        this.svg.selectAll('.graph-node').classed('selected', false);
                        this.svg.selectAll('.graph-link').classed('highlighted', false);
                    }
                    
                    // Reset node positions
                    if (this.simulation) {
                        this.graphData.nodes.forEach(node => {
                            node.fx = null;
                            node.fy = null;
                        });
                        this.simulation.alpha(1).restart();
                    }
                },

                calculateGraphDensity() {
                    const nodeCount = this.graphData.nodes.length;
                    const linkCount = this.graphData.links.length;
                    const maxPossibleLinks = (nodeCount * (nodeCount - 1)) / 2;
                    
                    if (maxPossibleLinks === 0) return '0%';
                    
                    const density = (linkCount / maxPossibleLinks) * 100;
                    return density.toFixed(1) + '%';
                },
                
                // =================== THOUGHT CHAIN METHODS ===================

                async initializeThoughtChains() {
                    if (!this.dbLoaded || !window.mermaid) {
                        console.log('Database not loaded or Mermaid not available');
                        return;
                    }
                    
                    try {
                        // Initialize Mermaid with dark theme
                        mermaid.initialize({
                            theme: 'dark',
                            themeVariables: {
                                primaryColor: '#3b82f6',
                                primaryTextColor: '#e5e7eb',
                                primaryBorderColor: '#1d4ed8',
                                lineColor: 'rgba(255, 255, 255, 0.4)',
                                secondaryColor: '#1f2937',
                                tertiaryColor: '#374151',
                                background: 'transparent',
                                mainBkg: '#1f2937',
                                secondBkg: '#374151',
                                tertiaryBkg: '#4b5563'
                            },
                            flowchart: {
                                nodeSpacing: 50,
                                rankSpacing: 80,
                                curve: 'basis',
                                padding: 20
                            },
                            fontSize: 14,
                            fontFamily: 'Inter, sans-serif'
                        });
                        
                        // Load thought chain data
                        await this.loadThoughtChainData();
                        
                        console.log('✅ Thought Chains initialized successfully');
                        
                    } catch (error) {
                        console.error('❌ Error initializing thought chains:', error);
                        this.showToast('Error initializing thought chains', 'error');
                    }
                },

                async loadThoughtChainData() {
                    if (!this.dbLoaded) {
                        console.log('Database not loaded, skipping thought chain data');
                        return;
                    }
                    
                    this.isProcessing = true;
                    this.loadingMessage = 'Loading thought chains...';
                    
                    try {
                        // Load thoughts (memories with type = 'thought')
                        const thoughts = this.executeQuery(`
                            SELECT * FROM memories 
                            WHERE memory_type = 'thought' 
                            ORDER BY created_at ASC
                        `);
                        
                        // If no thoughts found, try to load any memories that might contain reasoning
                        let allThoughts = thoughts;
                        if (thoughts.length === 0) {
                            // Fallback: load memories that contain reasoning-like content
                            allThoughts = this.executeQuery(`
                                SELECT * FROM memories 
                                WHERE (content LIKE '%reasoning%' OR 
                                       content LIKE '%thinking%' OR 
                                       content LIKE '%decision%' OR
                                       content LIKE '%analysis%' OR
                                       memory_type IN ('goal', 'plan', 'observation'))
                                ORDER BY created_at ASC
                            `);
                        }
                        
                        // Load memory links to understand parent-child relationships
                        let thoughtLinks = [];
                        if (allThoughts.length > 0) {
                            const thoughtIds = allThoughts.map(t => `'${t.memory_id}'`).join(',');
                            thoughtLinks = this.executeQuery(`
                                SELECT ml.*, 
                                       m1.memory_type as source_type,
                                       m2.memory_type as target_type
                                FROM memory_links ml
                                LEFT JOIN memories m1 ON ml.source_memory_id = m1.memory_id
                                LEFT JOIN memories m2 ON ml.target_memory_id = m2.memory_id
                                WHERE (m1.memory_id IN (${thoughtIds}) OR 
                                       m2.memory_id IN (${thoughtIds}))
                                AND ml.link_type IN ('causal', 'temporal', 'references')
                                ORDER BY ml.created_at ASC
                            `);
                        }
                        
                        // Build thought chains
                        this.thoughtChains = this.buildThoughtChains(allThoughts, thoughtLinks);
                        
                        // Calculate statistics
                        this.calculateThoughtChainStats();
                        
                        console.log(`Loaded ${this.thoughtChains.length} thought chains from ${allThoughts.length} thoughts`);
                        
                    } catch (error) {
                        console.error('Error loading thought chain data:', error);
                        // Don't show error toast for missing thought data, just log it
                        console.log('No thought chain data available or error in processing');
                        this.thoughtChains = [];
                        this.calculateThoughtChainStats();
                    } finally {
                        this.isProcessing = false;
                        this.loadingMessage = '';
                    }
                },

                buildThoughtChains(thoughts, links) {
                    // Create a map of thought relationships
                    const thoughtMap = new Map();
                    const childrenMap = new Map();
                    const parentMap = new Map();
                    
                    // Index all thoughts
                    thoughts.forEach(thought => {
                        thoughtMap.set(thought.memory_id, {
                            ...thought,
                            children: [],
                            hasChildren: false,
                            isBranch: false
                        });
                        childrenMap.set(thought.memory_id, []);
                    });
                    
                    // Build parent-child relationships from links
                    links.forEach(link => {
                        const sourceId = link.source_memory_id;
                        const targetId = link.target_memory_id;
                        
                        if (thoughtMap.has(sourceId) && thoughtMap.has(targetId)) {
                            childrenMap.get(sourceId).push(targetId);
                            parentMap.set(targetId, sourceId);
                            
                            const sourceThought = thoughtMap.get(sourceId);
                            sourceThought.children.push(targetId);
                            sourceThought.hasChildren = true;
                            
                            // Mark as branch if more than one child
                            if (sourceThought.children.length > 1) {
                                sourceThought.isBranch = true;
                            }
                        }
                    });
                    
                    // Find root thoughts (thoughts with no parents or workflow starts)
                    const rootThoughts = thoughts.filter(thought => 
                        !parentMap.has(thought.memory_id) || 
                        this.isWorkflowStart(thought)
                    );
                    
                    // Build chains from each root
                    const chains = [];
                    const processedThoughts = new Set();
                    
                    rootThoughts.forEach(root => {
                        if (!processedThoughts.has(root.memory_id)) {
                            const chain = this.buildChainFromRoot(root, thoughtMap, childrenMap, processedThoughts);
                            if (chain.thoughts.length > 1) { // Only include chains with multiple thoughts
                                chains.push(chain);
                            }
                        }
                    });
                    
                    // Handle orphaned thoughts by creating simple chains
                    thoughts.forEach(thought => {
                        if (!processedThoughts.has(thought.memory_id)) {
                            const chain = {
                                id: `chain-${thought.memory_id}`,
                                title: `Single Thought: ${thought.memory_type}`,
                                description: thought.content.substring(0, 100) + '...',
                                thoughts: [thoughtMap.get(thought.memory_id)],
                                created_at: thought.created_at,
                                hasBranches: false,
                                branchCount: 0,
                                complexity: 'Simple',
                                workflow_id: thought.workflow_id
                            };
                            chains.push(chain);
                            processedThoughts.add(thought.memory_id);
                        }
                    });
                    
                    return chains.sort((a, b) => b.created_at - a.created_at);
                },

                buildChainFromRoot(root, thoughtMap, childrenMap, processedThoughts) {
                    const chainThoughts = [];
                    const visited = new Set();
                    let branchCount = 0;
                    
                    // Traverse the chain using DFS
                    const traverse = (thoughtId, depth = 0) => {
                        if (visited.has(thoughtId) || depth > 50) return; // Prevent infinite loops
                        
                        visited.add(thoughtId);
                        processedThoughts.add(thoughtId);
                        
                        const thought = thoughtMap.get(thoughtId);
                        if (thought) {
                            chainThoughts.push(thought);
                            
                            // Count branches
                            if (thought.children.length > 1) {
                                branchCount++;
                            }
                            
                            // Follow the main path (first child) and note branches
                            thought.children.forEach((childId, index) => {
                                if (index === 0) {
                                    // Main path
                                    traverse(childId, depth + 1);
                                } else {
                                    // Branch - for now, just note it exists
                                    // In a more complex implementation, we'd create sub-chains
                                    branchCount++;
                                }
                            });
                        }
                    };
                    
                    traverse(root.memory_id);
                    
                    // Determine complexity
                    let complexity = 'Simple';
                    if (chainThoughts.length > 10 || branchCount > 2) {
                        complexity = 'Complex';
                    } else if (chainThoughts.length > 5 || branchCount > 0) {
                        complexity = 'Medium';
                    }
                    
                    // Generate title and description
                    const title = this.generateChainTitle(chainThoughts, root);
                    const description = this.generateChainDescription(chainThoughts);
                    
                    return {
                        id: `chain-${root.memory_id}`,
                        title,
                        description,
                        thoughts: chainThoughts,
                        created_at: root.created_at,
                        hasBranches: branchCount > 0,
                        branchCount,
                        complexity,
                        workflow_id: root.workflow_id
                    };
                },

                generateChainTitle(thoughts, root) {
                    const workflow = this.workflows.find(w => w.workflow_id === root.workflow_id);
                    
                    if (workflow) {
                        return `${workflow.title || 'Workflow'} - Reasoning Chain`;
                    }
                    
                    // Generate title based on thought types
                    const types = [...new Set(thoughts.map(t => t.memory_type))];
                    if (types.length === 1) {
                        return `${types[0]} Chain (${thoughts.length} steps)`;
                    } else {
                        return `Mixed Reasoning Chain (${thoughts.length} steps)`;
                    }
                },

                generateChainDescription(thoughts) {
                    if (thoughts.length === 0) return 'Empty chain';
                    
                    const first = thoughts[0];
                    const last = thoughts[thoughts.length - 1];
                    
                    return `From: ${first.content.substring(0, 50)}... To: ${last.content.substring(0, 50)}...`;
                },

                isWorkflowStart(thought) {
                    // Check if this thought appears to be the start of a workflow
                    return thought.content.toLowerCase().includes('goal') || 
                           thought.content.toLowerCase().includes('objective') ||
                           thought.content.toLowerCase().includes('task');
                },

                calculateThoughtChainStats() {
                    const totalChains = this.thoughtChains.length;
                    const totalThoughts = this.thoughtChains.reduce((sum, chain) => sum + chain.thoughts.length, 0);
                    const totalBranches = this.thoughtChains.reduce((sum, chain) => sum + chain.branchCount, 0);
                    const avgChainLength = totalChains > 0 ? totalThoughts / totalChains : 0;
                    
                    this.thoughtChainStats = {
                        totalChains,
                        totalThoughts,
                        avgChainLength,
                        branchingPoints: totalBranches
                    };
                },

                selectThoughtChain(chain) {
                    this.currentChain = chain;
                    this.thoughtsInCurrentChain = [...chain.thoughts];
                    this.thoughtTimelineLength = chain.thoughts.length;
                    this.thoughtTimelinePosition = 0;
                    this.currentThoughtIndex = 0;
                    
                    // Generate and render the mermaid diagram
                    this.generateMermaidDiagram(chain);
                    this.renderMermaidDiagram();
                },

                generateMermaidDiagram(chain) {
                    let diagram = 'flowchart TD\n';
                    
                    chain.thoughts.forEach((thought, index) => {
                        const nodeId = `T${index}`;
                        const label = this.sanitizeForMermaid(thought.memory_type);
                        const nodeClass = this.getMermaidNodeClass(thought);
                        
                        // Add node
                        diagram += `    ${nodeId}[${label}]:::${nodeClass}\n`;
                        
                        // Add connections to next thoughts
                        if (index < chain.thoughts.length - 1) {
                            diagram += `    ${nodeId} --> T${index + 1}\n`;
                        }
                        
                        // Add branches if they exist
                        if (thought.children && thought.children.length > 1) {
                            thought.children.slice(1).forEach((childId, branchIndex) => {
                                const branchNodeId = `B${index}_${branchIndex}`;
                                diagram += `    ${branchNodeId}[Branch ${branchIndex + 1}]:::branch\n`;
                                diagram += `    ${nodeId} --> ${branchNodeId}\n`;
                            });
                        }
                    });
                    
                    // Add styling
                    diagram += `
    classDef default fill:#1f2937,stroke:#3b82f6,stroke-width:2px,color:#e5e7eb
    classDef active fill:#3b82f6,stroke:#1d4ed8,stroke-width:3px,color:#ffffff
    classDef branch fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#ffffff
    classDef decision fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#ffffff
    classDef conclusion fill:#10b981,stroke:#059669,stroke-width:2px,color:#ffffff
    `;
                    
                    this.mermaidDiagram = diagram;
                },

                sanitizeForMermaid(text) {
                    // Clean text for Mermaid diagram
                    return text.replace(/[^\w\s]/g, '').substring(0, 20);
                },

                getMermaidNodeClass(thought) {
                    const content = thought.content.toLowerCase();
                    
                    if (content.includes('decision') || content.includes('choose')) {
                        return 'decision';
                    } else if (content.includes('conclusion') || content.includes('result')) {
                        return 'conclusion';
                    } else if (thought.isBranch) {
                        return 'branch';
                    }
                    
                    return 'default';
                },

                async renderMermaidDiagram() {
                    if (!this.mermaidDiagram || !this.$refs.mermaidContainer) return;
                    
                    try {
                        // Clear previous diagram
                        this.$refs.mermaidContainer.innerHTML = '';
                        
                        // Generate unique ID for this diagram
                        const diagramId = `mermaid-${Date.now()}`;
                        
                        // Render the diagram
                        const { svg } = await mermaid.render(diagramId, this.mermaidDiagram);
                        this.$refs.mermaidContainer.innerHTML = svg;
                        
                        // Add event listeners to nodes
                        this.addMermaidNodeInteractions();
                        
                        // Highlight current thought
                        this.updateDiagramHighlight();
                        
                    } catch (error) {
                        console.error('Error rendering Mermaid diagram:', error);
                        this.showToast('Error rendering thought chain diagram', 'error');
                    }
                },

                addMermaidNodeInteractions() {
                    const nodes = this.$refs.mermaidContainer.querySelectorAll('.node');
                    
                    nodes.forEach((node, index) => {
                        if (index < this.thoughtsInCurrentChain.length) {
                            node.style.cursor = 'pointer';
                            node.addEventListener('click', () => {
                                this.jumpToThought(index);
                            });
                        }
                    });
                },

                updateDiagramHighlight() {
                    if (!this.$refs.mermaidContainer) return;
                    
                    const nodes = this.$refs.mermaidContainer.querySelectorAll('.node');
                    
                    nodes.forEach((node, index) => {
                        node.classList.remove('active');
                        if (index === this.currentThoughtIndex) {
                            node.classList.add('active');
                        }
                        
                        // Dim nodes that haven't been reached yet
                        if (index > this.currentThoughtIndex) {
                            node.style.opacity = '0.3';
                        } else {
                            node.style.opacity = '1';
                        }
                    });
                },

                // Playback control methods
                togglePlayback() {
                    if (this.isPlaybackActive) {
                        this.stopPlayback();
                    } else {
                        this.startPlayback();
                    }
                },

                startPlayback() {
                    if (!this.currentChain || this.currentThoughtIndex >= this.thoughtsInCurrentChain.length - 1) {
                        return;
                    }
                    
                    this.isPlaybackActive = true;
                    const interval = 2000 / this.playbackSpeed; // Base interval of 2 seconds
                    
                    this.playbackInterval = setInterval(() => {
                        if (this.currentThoughtIndex < this.thoughtsInCurrentChain.length - 1) {
                            this.stepForward();
                        } else {
                            this.stopPlayback();
                        }
                    }, interval);
                },

                stopPlayback() {
                    this.isPlaybackActive = false;
                    if (this.playbackInterval) {
                        clearInterval(this.playbackInterval);
                        this.playbackInterval = null;
                    }
                },

                stepForward() {
                    if (this.currentThoughtIndex < this.thoughtsInCurrentChain.length - 1) {
                        this.currentThoughtIndex++;
                        this.thoughtTimelinePosition = this.currentThoughtIndex;
                        this.updateDiagramHighlight();
                        this.updateSelectedThought();
                    }
                },

                stepBackward() {
                    if (this.currentThoughtIndex > 0) {
                        this.currentThoughtIndex--;
                        this.thoughtTimelinePosition = this.currentThoughtIndex;
                        this.updateDiagramHighlight();
                        this.updateSelectedThought();
                    }
                },

                setPlaybackSpeed(speed) {
                    this.playbackSpeed = speed;
                    
                    // Restart playback with new speed if currently playing
                    if (this.isPlaybackActive) {
                        this.stopPlayback();
                        this.startPlayback();
                    }
                },

                jumpToThought(index) {
                    if (index >= 0 && index < this.thoughtsInCurrentChain.length) {
                        this.currentThoughtIndex = index;
                        this.thoughtTimelinePosition = index;
                        this.updateDiagramHighlight();
                        this.updateSelectedThought();
                    }
                },

                seekToPosition(position) {
                    this.jumpToThought(parseInt(position));
                },

                updateSelectedThought() {
                    if (this.thoughtsInCurrentChain[this.currentThoughtIndex]) {
                        this.selectedThought = this.thoughtsInCurrentChain[this.currentThoughtIndex];
                    }
                },

                // Navigation helpers
                jumpToFirstBranch() {
                    const branchIndex = this.thoughtsInCurrentChain.findIndex(thought => thought.isBranch);
                    if (branchIndex !== -1) {
                        this.jumpToThought(branchIndex);
                    }
                },

                jumpToLastThought() {
                    this.jumpToThought(this.thoughtsInCurrentChain.length - 1);
                },

                jumpToKeyDecision() {
                    const decisionIndex = this.thoughtsInCurrentChain.findIndex(thought => 
                        thought.content.toLowerCase().includes('decision') || 
                        thought.content.toLowerCase().includes('choose')
                    );
                    if (decisionIndex !== -1) {
                        this.jumpToThought(decisionIndex);
                    }
                },

                jumpToConclusion() {
                    const conclusionIndex = this.thoughtsInCurrentChain.findIndex(thought => 
                        thought.content.toLowerCase().includes('conclusion') || 
                        thought.content.toLowerCase().includes('result')
                    );
                    if (conclusionIndex !== -1) {
                        this.jumpToThought(conclusionIndex);
                    } else {
                        this.jumpToLastThought();
                    }
                },

                // Modal navigation
                navigateToPreviousThought() {
                    this.stepBackward();
                },

                navigateToNextThought() {
                    this.stepForward();
                },

                selectThought(thought) {
                    this.selectedThought = thought;
                },

                // Chain management
                filterThoughtChains() {
                    // Implementation for filtering chains based on this.chainFilter
                    // This would filter this.thoughtChains based on the selected filter
                },

                resetThoughtChainView() {
                    this.currentChain = null;
                    this.thoughtsInCurrentChain = [];
                    this.currentThoughtIndex = 0;
                    this.thoughtTimelinePosition = 0;
                    this.stopPlayback();
                    this.selectedThought = null;
                    this.chainFilter = '';
                },

                exportThoughtChain() {
                    if (!this.currentChain) {
                        this.showToast('Please select a thought chain to export', 'warning');
                        return;
                    }
                    
                    const exportData = {
                        chain: this.currentChain,
                        diagram: this.mermaidDiagram,
                        timestamp: new Date().toISOString()
                    };
                    
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `thought-chain-${this.currentChain.id}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    this.showToast('Thought chain exported successfully! 📁', 'success');
                },

                calculateChainDuration(chain) {
                    if (!chain || chain.thoughts.length < 2) return 'N/A';
                    
                    const start = chain.thoughts[0].created_at;
                    const end = chain.thoughts[chain.thoughts.length - 1].created_at;
                    const duration = end - start;
                    
                    if (duration < 60) return `${duration}s`;
                    if (duration < 3600) return `${Math.round(duration / 60)}m`;
                    return `${Math.round(duration / 3600)}h`;
                },

                // =================== GOAL HIERARCHY METHODS ===================

                async loadGoalTreeData() {
                    if (!this.dbLoaded) {
                        console.log('Database not loaded, skipping goal tree data');
                        return;
                    }
                    
                    try {
                        // If no goals table exists, create mock data for demonstration
                        let goals = this.goals;
                        
                        if (goals.length === 0) {
                            console.log('No goals found, creating sample data for demonstration');
                            goals = this.createSampleGoals();
                        }
                        
                        // Build tree structure
                        this.goalTreeData = this.buildGoalTree(goals);
                        
                        // Calculate goal statistics
                        this.calculateGoalStats(goals);
                        
                        console.log(`Goal tree loaded: ${goals.length} goals`);
                        
                    } catch (error) {
                        console.error('Error loading goal tree data:', error);
                        // Create sample data if there's an error
                        const sampleGoals = this.createSampleGoals();
                        this.goalTreeData = this.buildGoalTree(sampleGoals);
                        this.calculateGoalStats(sampleGoals);
                        console.log('Using sample goal data for demonstration');
                    }
                },

                createSampleGoals() {
                    const now = Date.now() / 1000;
                    return [
                        {
                            goal_id: 'g1',
                            title: 'Improve AI Agent Capabilities',
                            description: 'Enhance the overall performance and capabilities of the AI agent system',
                            priority: 'high',
                            status: 'in_progress',
                            progress: 65,
                            due_date: now + (30 * 24 * 60 * 60), // 30 days from now
                            parent_goal_id: null,
                            created_at: now - (10 * 24 * 60 * 60),
                            updated_at: now - (2 * 60 * 60),
                            owner: 'AI Team'
                        },
                        {
                            goal_id: 'g2',
                            title: 'Optimize Memory System',
                            description: 'Improve memory retrieval speed and accuracy',
                            priority: 'high',
                            status: 'active',
                            progress: 40,
                            due_date: now + (15 * 24 * 60 * 60),
                            parent_goal_id: 'g1',
                            created_at: now - (8 * 24 * 60 * 60),
                            updated_at: now - (1 * 60 * 60),
                            owner: 'Memory Team'
                        },
                        {
                            goal_id: 'g3',
                            title: 'Implement Hierarchical Memory',
                            description: 'Add support for different memory levels and priorities',
                            priority: 'medium',
                            status: 'completed',
                            progress: 100,
                            due_date: now - (5 * 24 * 60 * 60),
                            parent_goal_id: 'g2',
                            created_at: now - (15 * 24 * 60 * 60),
                            updated_at: now - (5 * 24 * 60 * 60),
                            owner: 'Memory Team'
                        },
                        {
                            goal_id: 'g4',
                            title: 'Enhance Reasoning Chains',
                            description: 'Improve the logical flow and coherence of reasoning processes',
                            priority: 'medium',
                            status: 'in_progress',
                            progress: 30,
                            due_date: now + (20 * 24 * 60 * 60),
                            parent_goal_id: 'g1',
                            created_at: now - (6 * 24 * 60 * 60),
                            updated_at: now - (6 * 60 * 60),
                            owner: 'Reasoning Team'
                        },
                        {
                            goal_id: 'g5',
                            title: 'Build Goal Management System',
                            description: 'Create an interactive interface for managing AI goals and dependencies',
                            priority: 'medium',
                            status: 'active',
                            progress: 85,
                            due_date: now + (7 * 24 * 60 * 60),
                            parent_goal_id: null,
                            created_at: now - (4 * 24 * 60 * 60),
                            updated_at: now - (30 * 60),
                            owner: 'UI Team'
                        },
                        {
                            goal_id: 'g6',
                            title: 'Performance Optimization',
                            description: 'Optimize database queries and reduce response times',
                            priority: 'high',
                            status: 'pending',
                            progress: 0,
                            due_date: now + (45 * 24 * 60 * 60),
                            parent_goal_id: null,
                            created_at: now - (1 * 24 * 60 * 60),
                            updated_at: now - (1 * 24 * 60 * 60),
                            owner: 'Performance Team'
                        }
                    ];
                },

                buildGoalTree(goals) {
                    // Create a map for quick lookup
                    const goalMap = new Map();
                    goals.forEach(goal => {
                        goalMap.set(goal.goal_id, {
                            ...goal,
                            children: [],
                            subgoals: [],
                            dependencies: [],
                            x: 0,
                            y: 0,
                            expanded: true
                        });
                    });
                    
                    // Build parent-child relationships
                    const rootGoals = [];
                    goals.forEach(goal => {
                        const goalNode = goalMap.get(goal.goal_id);
                        if (goal.parent_goal_id && goalMap.has(goal.parent_goal_id)) {
                            const parent = goalMap.get(goal.parent_goal_id);
                            parent.children.push(goalNode);
                            parent.subgoals.push(goalNode);
                        } else {
                            rootGoals.push(goalNode);
                        }
                    });
                    
                    return { children: rootGoals, name: 'Goals' };
                },

                calculateGoalStats(goals) {
                    if (!goals || goals.length === 0) {
                        this.goalStats = {
                            total: 0,
                            completed: 0,
                            inProgress: 0,
                            pending: 0,
                            overdue: 0,
                            completionRate: 0
                        };
                        return;
                    }
                    
                    const now = Date.now() / 1000;
                    const stats = {
                        total: goals.length,
                        completed: 0,
                        inProgress: 0,
                        pending: 0,
                        overdue: 0,
                        completionRate: 0
                    };
                    
                    goals.forEach(goal => {
                        switch (goal.status) {
                            case 'completed':
                                stats.completed++;
                                break;
                            case 'in_progress':
                            case 'active':
                                stats.inProgress++;
                                if (goal.due_date && goal.due_date < now) {
                                    stats.overdue++;
                                }
                                break;
                            case 'pending':
                                stats.pending++;
                                if (goal.due_date && goal.due_date < now) {
                                    stats.overdue++;
                                }
                                break;
                        }
                    });
                    
                    stats.completionRate = Math.round((stats.completed / stats.total) * 100);
                    this.goalStats = stats;
                },

                async initializeGoalTree() {
                    if (!window.d3 || !this.goalTreeData.children.length) {
                        console.log('D3 not available or no goal data');
                        return;
                    }
                    
                    try {
                        await this.renderGoalTree();
                        console.log('✅ Goal tree initialized successfully');
                    } catch (error) {
                        console.error('❌ Error initializing goal tree:', error);
                        this.showToast('Error initializing goal tree', 'error');
                    }
                },

                async renderGoalTree() {
                    const svg = d3.select(this.$refs.goalTreeSvg);
                    const container = this.$refs.goalTreeSvg.parentElement;
                    const rect = container.getBoundingClientRect();
                    
                    const width = rect.width;
                    const height = rect.height;
                    
                    // Clear previous content
                    svg.selectAll("*").remove();
                    
                    // Set dimensions
                    svg.attr("width", width).attr("height", height);
                    
                    // Create tree layout
                    const treeLayout = d3.tree()
                        .size([height - 100, width - 200])
                        .separation((a, b) => a.parent === b.parent ? 1 : 2);
                    
                    // Create hierarchy
                    const root = d3.hierarchy(this.goalTreeData);
                    const treeData = treeLayout(root);
                    
                    // Create main group for all content
                    const g = svg.append("g")
                        .attr("class", "goal-tree-content")
                        .attr("transform", "translate(100, 50)");
                    
                    // Add zoom behavior
                    const zoom = d3.zoom()
                        .scaleExtent([0.3, 3])
                        .on("zoom", (event) => {
                            g.attr("transform", `translate(100, 50) ${event.transform}`);
                        });
                    
                    svg.call(zoom);
                    
                    // Draw links
                    const links = g.selectAll(".goal-link")
                        .data(treeData.links())
                        .enter().append("path")
                        .attr("class", "goal-link")
                        .attr("fill", "none")
                        .attr("stroke", "#4b5563")
                        .attr("stroke-width", 2)
                        .attr("d", d3.linkHorizontal()
                            .x(d => d.y)
                            .y(d => d.x));
                    
                    // Draw nodes
                    const nodes = g.selectAll(".goal-node")
                        .data(treeData.descendants())
                        .enter().append("g")
                        .attr("class", "goal-node")
                        .attr("transform", d => `translate(${d.y}, ${d.x})`)
                        .style("cursor", "pointer");
                    
                    // Node backgrounds
                    nodes.append("rect")
                        .attr("class", "goal-node-bg")
                        .attr("x", -80)
                        .attr("y", -25)
                        .attr("width", 160)
                        .attr("height", 50)
                        .attr("rx", 8)
                        .attr("fill", d => this.getGoalNodeColor(d.data))
                        .attr("stroke", d => this.getGoalBorderColor(d.data))
                        .attr("stroke-width", 2)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))")
                        .on("click", (event, d) => this.selectGoal(d.data))
                        .on("mouseover", (event, d) => this.showGoalTooltip(event, d.data))
                        .on("mouseout", () => this.hideGoalTooltip());
                    
                    // Node titles
                    nodes.append("text")
                        .attr("class", "goal-node-title")
                        .attr("dy", "-5")
                        .attr("text-anchor", "middle")
                        .style("fill", "#ffffff")
                        .style("font-size", "12px")
                        .style("font-weight", "600")
                        .style("pointer-events", "none")
                        .text(d => this.truncateText(d.data.title || d.data.name, 20));
                    
                    // Progress bars (if enabled)
                    if (this.goalTreeSettings.showProgress) {
                        nodes.filter(d => d.data.progress !== undefined)
                            .append("rect")
                            .attr("class", "goal-progress-bg")
                            .attr("x", -70)
                            .attr("y", 8)
                            .attr("width", 140)
                            .attr("height", 4)
                            .attr("rx", 2)
                            .attr("fill", "rgba(255,255,255,0.2)");
                        
                        nodes.filter(d => d.data.progress !== undefined)
                            .append("rect")
                            .attr("class", "goal-progress-bar")
                            .attr("x", -70)
                            .attr("y", 8)
                            .attr("width", d => (d.data.progress / 100) * 140)
                            .attr("height", 4)
                            .attr("rx", 2)
                            .attr("fill", "#fbbf24");
                    }
                    
                    // Priority indicators
                    nodes.filter(d => d.data.priority)
                        .append("circle")
                        .attr("class", "goal-priority")
                        .attr("cx", 65)
                        .attr("cy", -15)
                        .attr("r", 4)
                        .attr("fill", d => this.getGoalPriorityColor(d.data.priority));
                    
                    // Status text
                    nodes.append("text")
                        .attr("class", "goal-node-status")
                        .attr("dy", "8")
                        .attr("text-anchor", "middle")
                        .style("fill", "#d1d5db")
                        .style("font-size", "10px")
                        .style("pointer-events", "none")
                        .text(d => d.data.status || '');
                    
                    // Add drag behavior
                    nodes.call(this.createGoalDrag());
                    
                    // Store references
                    this.goalTreeSvg = svg;
                    this.goalTreeNodes = nodes;
                    this.goalTreeLinks = links;
                },

                createGoalDrag() {
                    return d3.drag()
                        .on("start", (event, d) => {
                            this.isDragging = true;
                            this.draggedGoal = d.data;
                            event.sourceEvent.stopPropagation();
                        })
                        .on("drag", (event, d) => {
                            d3.select(event.sourceEvent.target.parentNode)
                                .attr("transform", `translate(${event.x}, ${event.y})`);
                        })
                        .on("end", (event, d) => {
                            this.isDragging = false;
                            this.draggedGoal = null;
                            // Reset position for now - in a real implementation, 
                            // you'd update the tree structure here
                            this.renderGoalTree();
                        });
                },

                getGoalNodeColor(goal) {
                    if (!goal.status) return '#6b7280';
                    
                    const colors = {
                        completed: '#10b981',
                        in_progress: '#3b82f6',
                        active: '#3b82f6',
                        pending: '#6b7280',
                        cancelled: '#ef4444',
                        overdue: '#ef4444'
                    };
                    
                    // Check if overdue
                    if (goal.due_date && goal.due_date < (Date.now() / 1000) && goal.status !== 'completed') {
                        return colors.overdue;
                    }
                    
                    return colors[goal.status] || colors.pending;
                },

                getGoalBorderColor(goal) {
                    return d3.color(this.getGoalNodeColor(goal)).darker(0.5);
                },

                getGoalPriorityColor(priority) {
                    const colors = {
                        high: '#ef4444',
                        medium: '#f59e0b',
                        low: '#3b82f6'
                    };
                    return colors[priority] || colors.medium;
                },

                getGoalStatusClass(status) {
                    const classes = {
                        completed: 'bg-green-500/20 text-green-400',
                        in_progress: 'bg-blue-500/20 text-blue-400',
                        active: 'bg-blue-500/20 text-blue-400',
                        pending: 'bg-gray-500/20 text-gray-400',
                        cancelled: 'bg-red-500/20 text-red-400',
                        overdue: 'bg-red-500/20 text-red-400'
                    };
                    return classes[status] || classes.pending;
                },

                getGoalPriorityClass(priority) {
                    const classes = {
                        high: 'bg-red-500/20 text-red-400',
                        medium: 'bg-yellow-500/20 text-yellow-400',
                        low: 'bg-blue-500/20 text-blue-400'
                    };
                    return classes[priority] || classes.medium;
                },

                selectGoal(goal) {
                    this.selectedGoal = goal;
                    
                    // Highlight selected node
                    if (this.goalTreeNodes) {
                        this.goalTreeNodes.selectAll('.goal-node-bg')
                            .attr('stroke-width', d => d.data === goal ? 4 : 2)
                            .attr('stroke', d => d.data === goal ? '#fbbf24' : this.getGoalBorderColor(d.data));
                    }
                },

                showGoalTooltip(event, goal) {
                    // Implementation for goal tooltip
                    // Similar to graph tooltip but with goal-specific content
                },

                hideGoalTooltip() {
                    // Hide tooltip
                },

                truncateText(text, maxLength) {
                    if (!text) return '';
                    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
                },

                // Goal management methods
                showNewGoalModal() {
                    this.editingGoal = null;
                    this.goalForm = {
                        title: '',
                        description: '',
                        priority: 'medium',
                        status: 'pending',
                        progress: 0,
                        due_date: '',
                        parent_goal_id: this.selectedGoal?.goal_id || '',
                        notes: ''
                    };
                    this.showGoalModal = true;
                },

                editGoal(goal) {
                    this.editingGoal = goal;
                    this.goalForm = {
                        title: goal.title || '',
                        description: goal.description || '',
                        priority: goal.priority || 'medium',
                        status: goal.status || 'pending',
                        progress: goal.progress || 0,
                        due_date: goal.due_date ? new Date(goal.due_date * 1000).toISOString().split('T')[0] : '',
                        parent_goal_id: goal.parent_goal_id || '',
                        notes: goal.notes || ''
                    };
                    this.showGoalModal = true;
                },

                async saveGoal() {
                    try {
                        const goalData = {
                            ...this.goalForm,
                            due_date: this.goalForm.due_date ? new Date(this.goalForm.due_date).getTime() / 1000 : null,
                            updated_at: Date.now() / 1000
                        };
                        
                        if (this.editingGoal) {
                            // Update existing goal
                            goalData.goal_id = this.editingGoal.goal_id;
                            const index = this.goals.findIndex(g => g.goal_id === this.editingGoal.goal_id);
                            if (index !== -1) {
                                this.goals[index] = { ...this.goals[index], ...goalData };
                            }
                            this.showToast('Goal updated successfully! ✅', 'success');
                        } else {
                            // Create new goal
                            goalData.goal_id = 'g' + Date.now();
                            goalData.created_at = Date.now() / 1000;
                            this.goals.push(goalData);
                            this.showToast('Goal created successfully! 🎯', 'success');
                        }
                        
                        // Rebuild tree
                        await this.loadGoalTreeData();
                        if (this.currentView === 'goals') {
                            await this.renderGoalTree();
                        }
                        
                        // Close modal
                        this.showGoalModal = false;
                        this.editingGoal = null;
                        
                    } catch (error) {
                        console.error('Error saving goal:', error);
                        this.showToast('Error saving goal', 'error');
                    }
                },

                addSubgoal(parentGoal) {
                    this.selectedGoal = parentGoal;
                    this.showNewGoalModal();
                },

                async markGoalComplete(goal) {
                    try {
                        goal.status = 'completed';
                        goal.progress = 100;
                        goal.updated_at = Date.now() / 1000;
                        
                        await this.loadGoalTreeData();
                        if (this.currentView === 'goals') {
                            await this.renderGoalTree();
                        }
                        
                        this.showToast(`Goal "${goal.title}" marked as complete! 🎉`, 'success');
                        
                    } catch (error) {
                        console.error('Error completing goal:', error);
                        this.showToast('Error updating goal status', 'error');
                    }
                },

                async deleteGoal(goal) {
                    if (!confirm(`Are you sure you want to delete "${goal.title}"? This will also delete all subgoals.`)) {
                        return;
                    }
                    
                    try {
                        // Remove from goals array
                        this.goals = this.goals.filter(g => g.goal_id !== goal.goal_id && g.parent_goal_id !== goal.goal_id);
                        
                        await this.loadGoalTreeData();
                        if (this.currentView === 'goals') {
                            await this.renderGoalTree();
                        }
                        
                        this.selectedGoal = null;
                        this.showToast('Goal deleted successfully', 'success');
                        
                    } catch (error) {
                        console.error('Error deleting goal:', error);
                        this.showToast('Error deleting goal', 'error');
                    }
                },

                filterGoals() {
                    // Filter logic would update the tree display
                    this.rebuildGoalTree();
                },

                rebuildGoalTree() {
                    if (this.goals.length > 0) {
                        this.goalTreeData = this.buildGoalTree(this.goals);
                        if (this.currentView === 'goals') {
                            this.renderGoalTree();
                        }
                    }
                },

                expandAllGoals() {
                    // Expand all nodes in the tree
                    this.goalTreeSettings.expandLevel = 999;
                    this.rebuildGoalTree();
                    this.showToast('All goals expanded', 'info');
                },

                collapseAllGoals() {
                    // Collapse all nodes except root level
                    this.goalTreeSettings.expandLevel = 1;
                    this.rebuildGoalTree();
                    this.showToast('All goals collapsed', 'info');
                },

                resetGoalTreeView() {
                    this.selectedGoal = null;
                    this.goalFilter = '';
                    this.goalSearch = '';
                    this.goalTreeSettings.groupBy = 'none';
                    this.goalTreeSettings.sortBy = 'created';
                    this.goalTreeSettings.expandLevel = 2;
                    this.rebuildGoalTree();
                    this.showToast('Goal tree view reset', 'info');
                },

                importGoalsFromMemories() {
                    // Extract goal-like memories and create goals
                    const goalMemories = this.memories.filter(m => 
                        m.memory_type === 'goal' || 
                        m.content.toLowerCase().includes('goal') ||
                        m.content.toLowerCase().includes('objective') ||
                        m.content.toLowerCase().includes('task')
                    );
                    
                    let importedCount = 0;
                    goalMemories.forEach(memory => {
                        const goal = {
                            goal_id: 'g_import_' + memory.memory_id,
                            title: memory.content.substring(0, 50) + (memory.content.length > 50 ? '...' : ''),
                            description: memory.content,
                            priority: memory.importance > 7 ? 'high' : memory.importance > 4 ? 'medium' : 'low',
                            status: 'pending',
                            progress: 0,
                            created_at: memory.created_at,
                            updated_at: memory.created_at,
                            parent_goal_id: null,
                            workflow_id: memory.workflow_id
                        };
                        
                        // Check if already exists
                        if (!this.goals.find(g => g.title === goal.title)) {
                            this.goals.push(goal);
                            importedCount++;
                        }
                    });
                    
                    if (importedCount > 0) {
                        this.loadGoalTreeData();
                        this.showToast(`Imported ${importedCount} goals from memories! 📥`, 'success');
                    } else {
                        this.showToast('No new goals found to import', 'info');
                    }
                },

                // Drag and drop handlers
                handleGoalDrop(event, target) {
                    if (!this.draggedGoal) return;
                    
                    if (target === 'root') {
                        this.draggedGoal.parent_goal_id = null;
                    } else {
                        this.draggedGoal.parent_goal_id = target.goal_id;
                    }
                    
                    this.rebuildGoalTree();
                    this.showToast('Goal hierarchy updated', 'success');
                },

                highlightDropZone(event, zone) {
                    event.currentTarget.style.opacity = '1';
                    event.currentTarget.style.transform = 'scale(1.05)';
                },

                unhighlightDropZone(event) {
                    event.currentTarget.style.opacity = '0.7';
                    event.currentTarget.style.transform = 'scale(1)';
                },

                // =================== SEMANTIC SEARCH METHODS ===================

                debounceSemanticSearch() {
                    if (this.searchDebounceTimer) {
                        clearTimeout(this.searchDebounceTimer);
                    }
                    this.searchDebounceTimer = setTimeout(() => {
                        if (this.semanticQuery.length >= 3) {
                            // Auto-search for queries > 3 characters after a pause
                            // this.performSemanticSearch();
                        }
                    }, 1000);
                },

                async performSemanticSearch() {
                    if (!this.semanticQuery.trim() || this.isSearching) {
                        return;
                    }

                    this.isSearching = true;
                    this.searchStatusMessage = 'Initializing search...';
                    this.searchResults = [];
                    this.searchClusters = [];

                    const startTime = performance.now();

                    try {
                        // Add to search history
                        this.addToSearchHistory();

                        // Perform the appropriate search based on mode
                        let results = [];
                        
                        if (this.searchMode === 'hybrid') {
                            this.searchStatusMessage = 'Performing hybrid semantic + keyword search...';
                            results = await this.performHybridSearch();
                        } else if (this.searchMode === 'semantic') {
                            this.searchStatusMessage = 'Performing pure semantic search...';
                            results = await this.performPureSemanticSearch();
                        } else if (this.searchMode === 'structured') {
                            this.searchStatusMessage = 'Performing structured query...';
                            results = await this.performStructuredQuery();
                        }

                        this.searchResults = results;
                        
                        // Generate clusters if we have enough results
                        if (results.length >= 3) {
                            this.searchStatusMessage = 'Generating clusters...';
                            await this.generateSearchClusters();
                        }

                        const endTime = performance.now();
                        this.searchStats.totalTime = Math.round(endTime - startTime);
                        this.searchStatusMessage = '';

                        this.showToast(`Found ${results.length} results in ${this.searchStats.totalTime}ms`, 'success');

                    } catch (error) {
                        console.error('Search error:', error);
                        this.showToast(`Search failed: ${error.message}`, 'error');
                        this.searchStatusMessage = '';
                    } finally {
                        this.isSearching = false;
                    }
                },

                async performHybridSearch() {
                    try {
                        // Use the UMS hybrid_search_memories tool via the executeQuery method
                        // Since we don't have direct tool access, we'll simulate calling the UMS
                        
                        // For now, use the existing database and do a hybrid search simulation
                        const query = `
                            SELECT DISTINCT m.*, 
                                   m.importance / 10.0 as hybrid_score,
                                   (CASE WHEN m.content LIKE ? THEN 0.8 ELSE 0.3 END) as similarity
                            FROM memories m
                            WHERE 1=1
                            ${this.searchFilters.memoryLevel ? 'AND m.memory_level = ?' : ''}
                            ${this.searchFilters.memoryType ? 'AND m.memory_type = ?' : ''}
                            AND (m.content LIKE ? OR m.memory_type LIKE ? OR m.description LIKE ?)
                            ORDER BY hybrid_score DESC, similarity DESC
                            LIMIT 50
                        `;
                        
                        const params = [];
                        const searchPattern = `%${this.semanticQuery}%`;
                        params.push(searchPattern); // for similarity calculation
                        
                        if (this.searchFilters.memoryLevel) params.push(this.searchFilters.memoryLevel);
                        if (this.searchFilters.memoryType) params.push(this.searchFilters.memoryType);
                        
                        params.push(searchPattern, searchPattern, searchPattern); // for WHERE clause

                        const results = this.executeQuery(query, params);
                        
                        this.searchStats.semanticMatches = results.length;
                        this.searchStats.keywordMatches = results.filter(r => 
                            r.content.toLowerCase().includes(this.semanticQuery.toLowerCase())
                        ).length;

                        return results;
                        
                    } catch (error) {
                        console.error('Hybrid search error:', error);
                        // Fallback to simple search
                        return this.performFallbackSearch();
                    }
                },

                async performPureSemanticSearch() {
                    try {
                        // Simulate semantic search by looking for conceptually related content
                        // In a real implementation, this would use embeddings
                        
                        const query = `
                            SELECT m.*, 
                                   0.85 as similarity
                            FROM memories m
                            WHERE m.content LIKE ? OR m.memory_type LIKE ?
                            ${this.searchFilters.memoryLevel ? 'AND m.memory_level = ?' : ''}
                            ${this.searchFilters.memoryType ? 'AND m.memory_type = ?' : ''}
                            ORDER BY m.importance DESC, m.created_at DESC
                            LIMIT 30
                        `;

                        const params = [`%${this.semanticQuery}%`, `%${this.semanticQuery}%`];
                        if (this.searchFilters.memoryLevel) params.push(this.searchFilters.memoryLevel);
                        if (this.searchFilters.memoryType) params.push(this.searchFilters.memoryType);

                        const results = this.executeQuery(query, params);
                        this.searchStats.semanticMatches = results.length;
                        
                        return results;
                        
                    } catch (error) {
                        console.error('Semantic search error:', error);
                        return this.performFallbackSearch();
                    }
                },

                async performStructuredQuery() {
                    try {
                        let whereConditions = ['1=1'];
                        let params = [];

                        if (this.semanticQuery) {
                            whereConditions.push('(m.content LIKE ? OR m.memory_type LIKE ? OR m.description LIKE ?)');
                            const pattern = `%${this.semanticQuery}%`;
                            params.push(pattern, pattern, pattern);
                        }

                        if (this.searchFilters.memoryLevel) {
                            whereConditions.push('m.memory_level = ?');
                            params.push(this.searchFilters.memoryLevel);
                        }

                        if (this.searchFilters.memoryType) {
                            whereConditions.push('m.memory_type = ?');
                            params.push(this.searchFilters.memoryType);
                        }

                        if (this.searchFilters.minImportance !== null) {
                            whereConditions.push('m.importance >= ?');
                            params.push(this.searchFilters.minImportance);
                        }

                        const query = `
                            SELECT m.*, 
                                   1.0 as similarity
                            FROM memories m
                            WHERE ${whereConditions.join(' AND ')}
                            ORDER BY m.importance DESC, m.created_at DESC
                            LIMIT 100
                        `;

                        const results = this.executeQuery(query, params);
                        return results;
                        
                    } catch (error) {
                        console.error('Structured query error:', error);
                        return this.performFallbackSearch();
                    }
                },

                performFallbackSearch() {
                    // Simple fallback search using existing memories
                    const query = this.semanticQuery.toLowerCase();
                    return this.memories.filter(memory => {
                        const matchesQuery = memory.content?.toLowerCase().includes(query) ||
                                           memory.memory_type?.toLowerCase().includes(query) ||
                                           memory.description?.toLowerCase().includes(query);
                        
                        const matchesLevel = !this.searchFilters.memoryLevel || 
                                           memory.memory_level === this.searchFilters.memoryLevel;
                        
                        const matchesType = !this.searchFilters.memoryType || 
                                          memory.memory_type === this.searchFilters.memoryType;
                        
                        return matchesQuery && matchesLevel && matchesType;
                    }).slice(0, 50).map(memory => ({
                        ...memory,
                        similarity: 0.7,
                        hybrid_score: memory.importance / 10
                    }));
                },

                async generateSearchClusters() {
                    if (this.searchResults.length < 3) return;

                    try {
                        // Simple clustering by memory type and level
                        const clusters = new Map();
                        
                        this.searchResults.forEach(result => {
                            const key = `${result.memory_level}-${result.memory_type}`;
                            if (!clusters.has(key)) {
                                clusters.set(key, {
                                    id: key,
                                    label: `${result.memory_level} ${result.memory_type}`,
                                    results: [],
                                    expanded: false
                                });
                            }
                            clusters.get(key).results.push(result);
                        });

                        // Only keep clusters with 2+ results
                        this.searchClusters = Array.from(clusters.values())
                            .filter(cluster => cluster.results.length >= 2)
                            .sort((a, b) => b.results.length - a.results.length);

                    } catch (error) {
                        console.error('Clustering error:', error);
                        this.searchClusters = [];
                    }
                },

                addToSearchHistory() {
                    const historyItem = {
                        id: Date.now(),
                        query: this.semanticQuery,
                        mode: this.searchMode,
                        filters: { ...this.searchFilters },
                        timestamp: Date.now()
                    };

                    // Remove duplicate queries
                    this.searchHistory = this.searchHistory.filter(item => item.query !== this.semanticQuery);
                    
                    // Add to beginning
                    this.searchHistory.unshift(historyItem);
                    
                    // Keep only last 20
                    this.searchHistory = this.searchHistory.slice(0, 20);
                    
                    // Save to localStorage
                    try {
                        localStorage.setItem('ums-search-history', JSON.stringify(this.searchHistory));
                    } catch (e) {
                        console.warn('Failed to save search history:', e);
                    }
                },

                loadSearchFromHistory(historyItem) {
                    this.semanticQuery = historyItem.query;
                    this.searchMode = historyItem.mode;
                    this.searchFilters = { ...this.searchFilters, ...historyItem.filters };
                    this.performSemanticSearch();
                },

                saveCurrentSearch() {
                    if (!this.semanticQuery.trim()) {
                        this.showToast('Enter a search query first', 'warning');
                        return;
                    }

                    const name = prompt('Enter a name for this saved search:', this.semanticQuery.substring(0, 50));
                    if (!name) return;

                    const savedSearch = {
                        id: Date.now(),
                        name: name,
                        query: this.semanticQuery,
                        mode: this.searchMode,
                        filters: { ...this.searchFilters },
                        resultCount: this.searchResults.length,
                        createdAt: Date.now()
                    };

                    this.savedSearches.unshift(savedSearch);
                    this.savedSearches = this.savedSearches.slice(0, 10); // Keep only 10

                    try {
                        localStorage.setItem('ums-saved-searches', JSON.stringify(this.savedSearches));
                        this.showToast(`Search saved as "${name}"`, 'success');
                    } catch (e) {
                        console.warn('Failed to save search:', e);
                        this.showToast('Failed to save search', 'error');
                    }
                },

                loadSavedSearch(savedSearch) {
                    this.semanticQuery = savedSearch.query;
                    this.searchMode = savedSearch.mode;
                    this.searchFilters = { ...this.searchFilters, ...savedSearch.filters };
                    this.performSemanticSearch();
                },

                deleteSavedSearch(searchId) {
                    this.savedSearches = this.savedSearches.filter(s => s.id !== searchId);
                    try {
                        localStorage.setItem('ums-saved-searches', JSON.stringify(this.savedSearches));
                        this.showToast('Saved search deleted', 'info');
                    } catch (e) {
                        console.warn('Failed to update saved searches:', e);
                    }
                },

                clearSemanticSearch() {
                    this.semanticQuery = '';
                    this.searchResults = [];
                    this.searchClusters = [];
                    this.searchStats = {
                        totalTime: 0,
                        semanticMatches: 0,
                        keywordMatches: 0,
                        totalConsidered: 0
                    };
                    this.resultsView = 'list';
                    this.sortBy = 'similarity';
                },

                selectSearchResult(result) {
                    this.selectedMemory = result;
                    this.showMemoryModal = true;
                },

                sortSearchResults() {
                    // Results are sorted via the computed property
                },

                applyQuickFilter(filterType) {
                    switch (filterType) {
                        case 'high-importance':
                            this.searchFilters.minImportance = 8;
                            this.semanticQuery = 'high importance insights';
                            break;
                        case 'recent':
                            const weekAgo = Date.now() / 1000 - (7 * 24 * 60 * 60);
                            this.searchFilters.dateRange = weekAgo;
                            this.semanticQuery = 'recent memories';
                            break;
                        case 'insights':
                            this.searchFilters.memoryType = 'insight';
                            this.semanticQuery = 'insights and discoveries';
                            break;
                        case 'procedures':
                            this.searchFilters.memoryLevel = 'procedural';
                            this.semanticQuery = 'how to procedures';
                            break;
                    }
                    
                    this.performSemanticSearch();
                },

                getMemoryDistribution() {
                    const distribution = {};
                    this.searchResults.forEach(result => {
                        distribution[result.memory_level] = (distribution[result.memory_level] || 0) + 1;
                    });
                    return distribution;
                },

                getSearchInsights() {
                    const insights = [];
                    
                    if (this.searchResults.length === 0) return insights;

                    const avgImportance = this.searchResults.reduce((sum, r) => sum + r.importance, 0) / this.searchResults.length;
                    if (avgImportance > 7) {
                        insights.push({
                            type: 'high-importance',
                            icon: 'star',
                            message: `High average importance (${avgImportance.toFixed(1)}/10)`
                        });
                    }

                    const memoryTypes = new Set(this.searchResults.map(r => r.memory_type));
                    if (memoryTypes.size > 3) {
                        insights.push({
                            type: 'diverse',
                            icon: 'shuffle',
                            message: `Diverse results across ${memoryTypes.size} memory types`
                        });
                    }

                    const recentCount = this.searchResults.filter(r => {
                        const dayAgo = Date.now() / 1000 - (24 * 60 * 60);
                        return r.created_at > dayAgo;
                    }).length;
                    
                    if (recentCount > this.searchResults.length * 0.3) {
                        insights.push({
                            type: 'recent',
                            icon: 'clock',
                            message: `${recentCount} recent memories (last 24h)`
                        });
                    }

                    return insights;
                },

                // Load saved searches and history on init
                loadSemanticSearchState() {
                    try {
                        const savedHistory = localStorage.getItem('ums-search-history');
                        if (savedHistory) {
                            this.searchHistory = JSON.parse(savedHistory);
                        }

                        const savedSearches = localStorage.getItem('ums-saved-searches');
                        if (savedSearches) {
                            this.savedSearches = JSON.parse(savedSearches);
                        }
                    } catch (e) {
                        console.warn('Failed to load semantic search state:', e);
                    }
                },

                // =================== WORKING MEMORY METHODS ===================

                async initializeWorkingMemory() {
                    console.log('🧠 Initializing Working Memory Dashboard...');
                    
                    try {
                        // Initialize working memory data
                        await this.loadWorkingMemoryData();
                        
                        // Start real-time updates
                        this.startWorkingMemoryUpdates();
                        
                        // Initialize charts
                        await this.$nextTick();
                        this.renderWorkingMemoryCharts();
                        
                        // Initialize memory pool
                        this.initializeMemoryPool();
                        
                        // Generate initial optimization suggestions
                        this.generateOptimizationSuggestions();
                        
                        console.log('✅ Working Memory Dashboard initialized successfully');
                        
                    } catch (error) {
                        console.error('❌ Error initializing working memory dashboard:', error);
                        this.showToast('Error initializing working memory dashboard', 'error');
                    }
                },

                async loadWorkingMemoryData() {
                    this.isRefreshingWorkingMemory = true;
                    
                    try {
                        // Simulate working memory by finding recent high-importance memories
                        const workingMemories = this.memories
                            .filter(m => m.memory_level === 'working' || m.importance >= 8)
                            .sort((a, b) => b.created_at - a.created_at)
                            .slice(0, this.workingMemoryStats.capacity)
                            .map(memory => ({
                                ...memory,
                                temperature: this.calculateMemoryTemperature(memory),
                                priority: this.calculateMemoryPriority(memory),
                                access_frequency: this.calculateAccessFrequency(memory),
                                retention_score: this.calculateRetentionScore(memory)
                            }));

                        this.activeWorkingMemories = workingMemories;
                        
                        // Update stats
                        this.updateWorkingMemoryStats();
                        
                        // Update heatmap data
                        this.updateMemoryHeatmapData();
                        
                        this.workingMemoryStatus.lastUpdate = Date.now();
                        this.workingMemoryStatus.connected = true;
                        
                    } catch (error) {
                        console.error('Error loading working memory data:', error);
                        this.workingMemoryStatus.connected = false;
                        throw error;
                    } finally {
                        this.isRefreshingWorkingMemory = false;
                    }
                },

                calculateMemoryTemperature(memory) {
                    // Calculate temperature based on recent access patterns
                    const now = Date.now() / 1000;
                    const timeSinceAccess = now - (memory.last_accessed_at || memory.created_at);
                    const accessCount = memory.access_count || 0;
                    
                    // Hot: recently accessed and frequently used
                    // Cold: old and rarely accessed
                    const recencyScore = Math.max(0, 100 - (timeSinceAccess / 3600) * 10); // Decreases over hours
                    const frequencyScore = Math.min(100, accessCount * 10);
                    
                    return Math.round((recencyScore * 0.7 + frequencyScore * 0.3));
                },

                calculateMemoryPriority(memory) {
                    if (memory.importance >= 9) return 'critical';
                    if (memory.importance >= 7) return 'high';
                    if (memory.importance >= 5) return 'medium';
                    return 'low';
                },

                calculateAccessFrequency(memory) {
                    const accessCount = memory.access_count || 0;
                    return Math.min(10, accessCount / 5); // Normalized to 0-10 scale
                },

                calculateRetentionScore(memory) {
                    const importance = memory.importance || 1;
                    const confidence = memory.confidence || 0.5;
                    const accessCount = memory.access_count || 0;
                    
                    return (importance * 0.4 + confidence * 100 * 0.3 + Math.min(accessCount * 10, 100) * 0.3) / 10;
                },

                updateWorkingMemoryStats() {
                    const active = this.activeWorkingMemories;
                    
                    this.workingMemoryStats = {
                        activeCount: active.length,
                        capacity: this.focusSettings.maxWorkingMemory || 7,
                        pressure: Math.round((active.length / (this.focusSettings.maxWorkingMemory || 7)) * 100),
                        temperature: active.length > 0 ? Math.round(active.reduce((sum, m) => sum + m.temperature, 0) / active.length) : 0,
                        focusScore: this.calculateFocusScore(),
                        efficiency: this.calculateEfficiency(),
                        avgRetentionTime: active.length > 0 ? Math.round(active.reduce((sum, m) => sum + m.retention_score, 0) / active.length) : 0,
                        totalAccesses: active.reduce((sum, m) => sum + (m.access_count || 0), 0)
                    };
                },

                calculateFocusScore() {
                    const active = this.activeWorkingMemories;
                    if (active.length === 0) return 100;
                    
                    // Focus is higher when memories are more related and coherent
                    const avgImportance = active.reduce((sum, m) => sum + m.importance, 0) / active.length;
                    const typeVariety = new Set(active.map(m => m.memory_type)).size;
                    const levelVariety = new Set(active.map(m => m.memory_level)).size;
                    
                    // Lower variety = higher focus
                    const varietyPenalty = (typeVariety + levelVariety) * 5;
                    const importanceBonus = avgImportance * 10;
                    
                    return Math.max(0, Math.min(100, importanceBonus - varietyPenalty + 20));
                },

                calculateEfficiency() {
                    const active = this.activeWorkingMemories;
                    if (active.length === 0) return 100;
                    
                    const avgTemperature = active.reduce((sum, m) => sum + m.temperature, 0) / active.length;
                    const utilizationRate = (active.length / this.workingMemoryStats.capacity) * 100;
                    
                    // Efficient when memories are hot (actively used) and utilization is optimal (not too full, not too empty)
                    const optimalUtilization = Math.abs(utilizationRate - 70) < 20 ? 100 : Math.max(0, 100 - Math.abs(utilizationRate - 70));
                    
                    return Math.round((avgTemperature * 0.6 + optimalUtilization * 0.4));
                },

                updateMemoryHeatmapData() {
                    // Generate heatmap data for memory activity
                    const timeframe = this.heatmapSettings.timeframe;
                    const now = Date.now() / 1000;
                    const intervals = [];
                    
                    let intervalSeconds, intervalCount;
                    switch (timeframe) {
                        case '1h':
                            intervalSeconds = 300; // 5 minutes
                            intervalCount = 12;
                            break;
                        case '6h':
                            intervalSeconds = 1800; // 30 minutes
                            intervalCount = 12;
                            break;
                        case '24h':
                            intervalSeconds = 3600; // 1 hour
                            intervalCount = 24;
                            break;
                        case '7d':
                            intervalSeconds = 86400; // 1 day
                            intervalCount = 7;
                            break;
                        default:
                            intervalSeconds = 3600;
                            intervalCount = 24;
                    }
                    
                    for (let i = 0; i < intervalCount; i++) {
                        const intervalStart = now - (intervalCount - i) * intervalSeconds;
                        const intervalEnd = intervalStart + intervalSeconds;
                        
                        // Count memory activities in this interval
                        const activityCount = this.memories.filter(m => 
                            m.created_at >= intervalStart && m.created_at <= intervalEnd
                        ).length;
                        
                        intervals.push({
                            time: intervalStart,
                            activity: activityCount,
                            intensity: Math.min(1, activityCount / 10) // Normalize to 0-1
                        });
                    }
                    
                    this.memoryHeatmapData = intervals;
                },

                startWorkingMemoryUpdates() {
                    if (this.workingMemoryInterval) {
                        clearInterval(this.workingMemoryInterval);
                    }
                    
                    if (this.workingMemorySettings.autoRefresh) {
                        this.workingMemoryInterval = setInterval(() => {
                            this.refreshWorkingMemory();
                        }, this.workingMemoryStatus.updateFrequency);
                    }
                },

                stopWorkingMemoryUpdates() {
                    if (this.workingMemoryInterval) {
                        clearInterval(this.workingMemoryInterval);
                        this.workingMemoryInterval = null;
                    }
                },

                async refreshWorkingMemory() {
                    if (this.isRefreshingWorkingMemory) return;
                    
                    try {
                        await this.loadWorkingMemoryData();
                        this.generateOptimizationSuggestions();
                        this.updateWorkingMemoryCharts();
                        this.updateHeatmap();
                    } catch (error) {
                        console.error('Error refreshing working memory:', error);
                    }
                },

                async optimizeWorkingMemory() {
                    if (this.isOptimizing) return;
                    
                    this.isOptimizing = true;
                    
                    try {
                        // Auto-apply low-risk optimizations
                        const autoOptimizations = this.optimizationSuggestions.filter(s => 
                            s.priority === 'medium' || s.priority === 'low'
                        );
                        
                        for (const suggestion of autoOptimizations) {
                            await this.applyOptimization(suggestion);
                        }
                        
                        await this.refreshWorkingMemory();
                        this.showToast('Working memory optimized successfully! 🚀', 'success');
                        
                    } catch (error) {
                        console.error('Error optimizing working memory:', error);
                        this.showToast('Error during optimization', 'error');
                    } finally {
                        this.isOptimizing = false;
                    }
                },

                generateOptimizationSuggestions() {
                    const suggestions = [];
                    const stats = this.workingMemoryStats;
                    const active = this.activeWorkingMemories;
                    
                    // High pressure suggestion
                    if (stats.pressure > 80) {
                        suggestions.push({
                            id: 'reduce-pressure',
                            title: 'Reduce Memory Pressure',
                            description: 'Working memory is near capacity. Consider removing lower priority items.',
                            priority: 'high',
                            impact: 'High',
                            icon: 'alert-triangle',
                            action: 'Auto-Remove',
                            applying: false,
                            handler: () => this.removeLowPriorityMemories()
                        });
                    }
                    
                    // Low temperature (stale memories) suggestion
                    const coldMemories = active.filter(m => m.temperature < 30);
                    if (coldMemories.length > 0) {
                        suggestions.push({
                            id: 'remove-cold',
                            title: 'Remove Stale Memories',
                            description: `${coldMemories.length} memories haven't been accessed recently.`,
                            priority: 'medium',
                            impact: 'Medium',
                            icon: 'snowflake',
                            action: 'Clear Stale',
                            applying: false,
                            handler: () => this.removeColdMemories()
                        });
                    }
                    
                    // Low focus suggestion
                    if (stats.focusScore < 50) {
                        suggestions.push({
                            id: 'improve-focus',
                            title: 'Improve Focus',
                            description: 'Working memory contains diverse, unrelated items. Consider focusing on a single task.',
                            priority: 'medium',
                            impact: 'High',
                            icon: 'target',
                            action: 'Focus Mode',
                            applying: false,
                            handler: () => this.enterDeepFocus()
                        });
                    }
                    
                    // Empty slots suggestion
                    if (stats.activeCount < stats.capacity / 2) {
                        suggestions.push({
                            id: 'add-related',
                            title: 'Add Related Memories',
                            description: 'Working memory has capacity for more relevant items.',
                            priority: 'low',
                            impact: 'Medium',
                            icon: 'plus-circle',
                            action: 'Add Related',
                            applying: false,
                            handler: () => this.addRelatedMemories()
                        });
                    }
                    
                    this.optimizationSuggestions = suggestions;
                },

                async applyOptimization(suggestion) {
                    if (suggestion.applying) return;
                    
                    suggestion.applying = true;
                    
                    try {
                        await suggestion.handler();
                        this.showToast(`Applied: ${suggestion.title}`, 'success');
                        
                        // Remove the suggestion after applying
                        this.optimizationSuggestions = this.optimizationSuggestions.filter(s => s.id !== suggestion.id);
                        
                    } catch (error) {
                        console.error('Error applying optimization:', error);
                        this.showToast(`Error applying ${suggestion.title}`, 'error');
                    } finally {
                        suggestion.applying = false;
                    }
                },

                removeLowPriorityMemories() {
                    const toRemove = this.activeWorkingMemories
                        .filter(m => m.priority === 'low')
                        .slice(0, 2); // Remove up to 2 low priority items
                    
                    toRemove.forEach(memory => this.removeFromWorkingMemory(memory));
                },

                removeColdMemories() {
                    const toRemove = this.activeWorkingMemories
                        .filter(m => m.temperature < 30)
                        .slice(0, 3); // Remove up to 3 cold items
                    
                    toRemove.forEach(memory => this.removeFromWorkingMemory(memory));
                },

                addRelatedMemories() {
                    if (this.activeWorkingMemories.length === 0) return;
                    
                    // Find memories related to current working memory
                    const currentTypes = new Set(this.activeWorkingMemories.map(m => m.memory_type));
                    const currentWorkflowIds = new Set(this.activeWorkingMemories.map(m => m.workflow_id).filter(Boolean));
                    
                    const candidates = this.memories
                        .filter(m => !this.activeWorkingMemories.find(a => a.memory_id === m.memory_id))
                        .filter(m => currentTypes.has(m.memory_type) || currentWorkflowIds.has(m.workflow_id))
                        .filter(m => m.importance >= 6)
                        .sort((a, b) => b.importance - a.importance)
                        .slice(0, 2);
                    
                    candidates.forEach(memory => this.addToWorkingMemory(memory));
                },

                initializeMemoryPool() {
                    // Initialize with high-priority memories not in working memory
                    this.filteredMemoryPool = this.memories
                        .filter(m => !this.activeWorkingMemories.find(a => a.memory_id === m.memory_id))
                        .filter(m => m.importance >= 5)
                        .sort((a, b) => b.importance - a.importance)
                        .slice(0, 50)
                        .map(memory => ({
                            ...memory,
                            access_frequency: this.calculateAccessFrequency(memory)
                        }));
                },

                filterMemoryPool() {
                    let filtered = this.memories.filter(m => 
                        !this.activeWorkingMemories.find(a => a.memory_id === m.memory_id)
                    );
                    
                    // Apply search filter
                    if (this.memoryPoolSearch) {
                        const search = this.memoryPoolSearch.toLowerCase();
                        filtered = filtered.filter(m => 
                            m.content?.toLowerCase().includes(search) ||
                            m.memory_type?.toLowerCase().includes(search)
                        );
                    }
                    
                    // Apply category filter
                    switch (this.memoryPoolFilter) {
                        case 'high':
                            filtered = filtered.filter(m => m.importance >= 8);
                            break;
                        case 'recent':
                            const dayAgo = Date.now() / 1000 - 86400;
                            filtered = filtered.filter(m => m.created_at > dayAgo);
                            break;
                        case 'related':
                            if (this.activeWorkingMemories.length > 0) {
                                const workflowIds = new Set(this.activeWorkingMemories.map(m => m.workflow_id).filter(Boolean));
                                const types = new Set(this.activeWorkingMemories.map(m => m.memory_type));
                                filtered = filtered.filter(m => 
                                    workflowIds.has(m.workflow_id) || types.has(m.memory_type)
                                );
                            }
                            break;
                    }
                    
                    this.filteredMemoryPool = filtered
                        .sort((a, b) => b.importance - a.importance)
                        .slice(0, 50)
                        .map(memory => ({
                            ...memory,
                            access_frequency: this.calculateAccessFrequency(memory)
                        }));
                },

                // Memory management operations
                addToWorkingMemory(memory) {
                    if (this.activeWorkingMemories.length >= this.workingMemoryStats.capacity) {
                        this.showToast('Working memory is at capacity', 'warning');
                        return;
                    }
                    
                    if (this.activeWorkingMemories.find(m => m.memory_id === memory.memory_id)) {
                        this.showToast('Memory already in working memory', 'info');
                        return;
                    }
                    
                    const enhancedMemory = {
                        ...memory,
                        temperature: this.calculateMemoryTemperature(memory),
                        priority: this.calculateMemoryPriority(memory),
                        access_frequency: this.calculateAccessFrequency(memory),
                        retention_score: this.calculateRetentionScore(memory),
                        added_at: Date.now() / 1000
                    };
                    
                    this.activeWorkingMemories.push(enhancedMemory);
                    this.updateWorkingMemoryStats();
                    this.filterMemoryPool();
                    this.generateOptimizationSuggestions();
                    
                    this.showToast(`Added to working memory: ${memory.memory_type}`, 'success');
                },

                removeFromWorkingMemory(memory) {
                    this.activeWorkingMemories = this.activeWorkingMemories.filter(m => m.memory_id !== memory.memory_id);
                    this.updateWorkingMemoryStats();
                    this.filterMemoryPool();
                    this.generateOptimizationSuggestions();
                    
                    this.showToast(`Removed from working memory`, 'info');
                },

                clearWorkingMemory() {
                    if (!confirm('Clear all working memory? This will remove all active memories.')) {
                        return;
                    }
                    
                    this.activeWorkingMemories = [];
                    this.updateWorkingMemoryStats();
                    this.filterMemoryPool();
                    this.generateOptimizationSuggestions();
                    
                    this.showToast('Working memory cleared', 'info');
                },

                selectWorkingMemory(memory) {
                    this.selectedMemory = memory;
                    this.showMemoryModal = true;
                },

                // Drag and drop handlers
                handleMemoryDragStart(event, memory) {
                    this.draggedMemory = memory;
                    event.dataTransfer.setData('text/plain', memory.memory_id);
                    event.dataTransfer.effectAllowed = 'move';
                },

                handleMemoryDrop(event) {
                    event.preventDefault();
                    if (this.draggedMemory && !this.activeWorkingMemories.find(m => m.memory_id === this.draggedMemory.memory_id)) {
                        this.addToWorkingMemory(this.draggedMemory);
                    }
                    this.draggedMemory = null;
                },

                handleMemoryDragOver(event) {
                    event.preventDefault();
                    event.dataTransfer.dropEffect = 'move';
                },

                handleEmptySlotDrop(event, slotIndex) {
                    event.preventDefault();
                    if (this.draggedMemory && !this.activeWorkingMemories.find(m => m.memory_id === this.draggedMemory.memory_id)) {
                        this.addToWorkingMemory(this.draggedMemory);
                    }
                    this.draggedMemory = null;
                },

                // Focus management
                applyFocusMode() {
                    const mode = this.focusSettings.mode;
                    
                    switch (mode) {
                        case 'deep':
                            this.focusSettings.maxWorkingMemory = 5;
                            this.focusSettings.retentionTime = 60;
                            break;
                        case 'creative':
                            this.focusSettings.maxWorkingMemory = 9;
                            this.focusSettings.retentionTime = 45;
                            break;
                        case 'analytical':
                            this.focusSettings.maxWorkingMemory = 6;
                            this.focusSettings.retentionTime = 90;
                            break;
                        case 'maintenance':
                            this.focusSettings.maxWorkingMemory = 3;
                            this.focusSettings.retentionTime = 20;
                            break;
                        default: // normal
                            this.focusSettings.maxWorkingMemory = 7;
                            this.focusSettings.retentionTime = 30;
                    }
                    
                    this.workingMemoryStats.capacity = this.focusSettings.maxWorkingMemory;
                    this.updateWorkingMemoryStats();
                    this.generateOptimizationSuggestions();
                    
                    this.showToast(`Applied ${mode} focus mode`, 'success');
                },

                enterDeepFocus() {
                    this.focusSettings.mode = 'deep';
                    this.applyFocusMode();
                    
                    // Keep only highest priority memories
                    const highPriority = this.activeWorkingMemories
                        .sort((a, b) => b.importance - a.importance)
                        .slice(0, 5);
                    
                    this.activeWorkingMemories = highPriority;
                    this.updateWorkingMemoryStats();
                    
                    this.showToast('Entered deep focus mode 🎯', 'success');
                },

                updateRetentionTime() {
                    // In a real implementation, this would update the backend retention policy
                    this.showToast(`Memory retention set to ${this.focusSettings.retentionTime} minutes`, 'info');
                },

                // Visualization and charts
                async renderWorkingMemoryCharts() {
                    if (!window.Chart) return;
                    
                    await this.$nextTick();
                    
                    try {
                        await this.renderMemoryPressureGauge();
                        await this.renderFocusScoreChart();
                        await this.renderMemoryHeatmap();
                    } catch (error) {
                        console.error('Error rendering working memory charts:', error);
                    }
                },

                async renderMemoryPressureGauge() {
                    const canvas = this.$refs.memoryPressureGauge;
                    if (!canvas) return;
                    
                    // Clear any existing chart first
                    if (this.workingMemoryCharts.pressureGauge) {
                        this.workingMemoryCharts.pressureGauge.destroy();
                        this.workingMemoryCharts.pressureGauge = null;
                    }
                    
                    // Reset canvas dimensions
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 264;
                    canvas.style.width = '';
                    canvas.style.height = '264px';
                    
                    const pressure = this.workingMemoryStats.pressure;
                    const temperature = this.workingMemoryStats.temperature;
                    
                    this.workingMemoryCharts.pressureGauge = new Chart(canvas, {
                        type: 'doughnut',
                        data: {
                            datasets: [{
                                data: [pressure, 100 - pressure],
                                backgroundColor: [
                                    pressure > 80 ? '#ef4444' : pressure > 60 ? '#f59e0b' : '#10b981',
                                    'rgba(75, 85, 99, 0.2)'
                                ],
                                borderWidth: 0,
                                cutout: '70%'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false },
                                tooltip: { enabled: false }
                            }
                        },
                        plugins: [{
                            afterDraw: function(chart) {
                                const { ctx, width, height } = chart;
                                ctx.save();
                                
                                // Draw pressure percentage
                                ctx.font = 'bold 24px Inter';
                                ctx.fillStyle = pressure > 80 ? '#ef4444' : pressure > 60 ? '#f59e0b' : '#10b981';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText(`${pressure}%`, width / 2, height / 2 - 10);
                                
                                // Draw label
                                ctx.font = '12px Inter';
                                ctx.fillStyle = '#9ca3af';
                                ctx.fillText('Pressure', width / 2, height / 2 + 15);
                                
                                // Draw temperature
                                ctx.font = '14px Inter';
                                ctx.fillStyle = temperature > 70 ? '#ef4444' : temperature > 40 ? '#f59e0b' : '#3b82f6';
                                ctx.fillText(`${temperature}° temp`, width / 2, height / 2 + 35);
                                
                                ctx.restore();
                            }
                        }]
                    });
                },

                async renderFocusScoreChart() {
                    const canvas = this.$refs.focusScoreChart;
                    if (!canvas) return;
                    
                    // Clear any existing chart first
                    if (this.workingMemoryCharts.focusScore) {
                        this.workingMemoryCharts.focusScore.destroy();
                        this.workingMemoryCharts.focusScore = null;
                    }
                    
                    // Reset canvas dimensions
                    canvas.width = canvas.offsetWidth || 400;
                    canvas.height = 128;
                    canvas.style.width = '';
                    canvas.style.height = '128px';
                    
                    // Generate sample focus history
                    const focusHistory = [];
                    const now = Date.now();
                    for (let i = 9; i >= 0; i--) {
                        focusHistory.push({
                            time: new Date(now - i * 300000), // 5 minutes intervals
                            score: this.workingMemoryStats.focusScore + (Math.random() - 0.5) * 20
                        });
                    }
                    
                    this.workingMemoryCharts.focusScore = new Chart(canvas, {
                        type: 'line',
                        data: {
                            labels: focusHistory.map(f => f.time.toLocaleTimeString('en-US', { 
                                hour: '2-digit', 
                                minute: '2-digit' 
                            })),
                            datasets: [{
                                label: 'Focus Score',
                                data: focusHistory.map(f => Math.max(0, Math.min(100, f.score))),
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                fill: true,
                                tension: 0.4,
                                pointRadius: 3,
                                pointHoverRadius: 6
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    ticks: {
                                        color: '#9ca3af',
                                        callback: value => value + '%'
                                    },
                                    grid: { color: 'rgba(156, 163, 175, 0.1)' }
                                },
                                x: {
                                    ticks: { color: '#9ca3af' },
                                    grid: { display: false }
                                }
                            },
                            plugins: {
                                legend: { display: false }
                            }
                        }
                    });
                },

                async renderMemoryHeatmap() {
                    const container = this.$refs.memoryHeatmap;
                    if (!container || !window.d3) return;
                    
                    // Clear previous heatmap
                    d3.select(container).selectAll("*").remove();
                    
                    const margin = { top: 20, right: 20, bottom: 30, left: 40 };
                    const width = Math.max(200, container.clientWidth - margin.left - margin.right);
                    const height = Math.max(100, container.clientHeight - margin.top - margin.bottom);
                    
                    const svg = d3.select(container)
                        .append("svg")
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.bottom + margin.top)
                        .append("g")
                        .attr("transform", `translate(${margin.left},${margin.top})`);
                    
                    // Create heatmap data
                    const data = this.memoryHeatmapData;
                    if (data.length === 0) return;
                    
                    const xScale = d3.scaleBand()
                        .domain(data.map((d, i) => i))
                        .range([0, width])
                        .padding(0.1);
                    
                    const colorScale = d3.scaleSequential(d3.interpolateRdYlBu)
                        .domain([0, d3.max(data, d => d.intensity) || 1]);
                    
                    // Draw heatmap rectangles
                    svg.selectAll(".heatmap-rect")
                        .data(data)
                        .enter()
                        .append("rect")
                        .attr("class", "heatmap-rect")
                        .attr("x", (d, i) => xScale(i))
                        .attr("y", 10)
                        .attr("width", xScale.bandwidth())
                        .attr("height", Math.max(10, height - 50))
                        .attr("fill", d => colorScale(d.intensity))
                        .attr("rx", 4)
                        .on("mouseover", (event, d) => {
                            const tooltip = d3.select("body")
                                .append("div")
                                .attr("class", "heatmap-tooltip")
                                .style("position", "absolute")
                                .style("background", "rgba(0, 0, 0, 0.8)")
                                .style("color", "white")
                                .style("padding", "8px")
                                .style("border-radius", "4px")
                                .style("font-size", "12px")
                                .style("pointer-events", "none")
                                .style("z-index", "1000");
                            
                            tooltip.html(`Activity: ${d.activity}<br>Time: ${new Date(d.time * 1000).toLocaleString()}`)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 10) + "px");
                        })
                        .on("mouseout", () => {
                            d3.selectAll(".heatmap-tooltip").remove();
                        });
                    
                    // Add time labels
                    svg.selectAll(".time-label")
                        .data(data.filter((d, i) => i % Math.ceil(data.length / 6) === 0))
                        .enter()
                        .append("text")
                        .attr("class", "time-label")
                        .attr("x", (d, i) => xScale(i * Math.ceil(data.length / 6)) + xScale.bandwidth() / 2)
                        .attr("y", height - 10)
                        .attr("text-anchor", "middle")
                        .style("fill", "#9ca3af")
                        .style("font-size", "10px")
                        .text(d => {
                            const date = new Date(d.time * 1000);
                            return this.heatmapSettings.timeframe === '7d' 
                                ? date.toLocaleDateString('en-US', { weekday: 'short' })
                                : date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                        });
                },

                updateHeatmap() {
                    this.updateMemoryHeatmapData();
                    this.renderMemoryHeatmap();
                },

                updateWorkingMemoryCharts() {
                    this.renderMemoryPressureGauge();
                    this.renderFocusScoreChart();
                },

                // Helper methods for styling
                getPressureColor(pressure) {
                    if (pressure > 80) return 'text-red-400';
                    if (pressure > 60) return 'text-yellow-400';
                    return 'text-green-400';
                },

                getPressureGradient(pressure) {
                    if (pressure > 80) return 'bg-red-400';
                    if (pressure > 60) return 'bg-yellow-400';
                    return 'bg-green-400';
                },

                getTemperatureColor(temperature) {
                    if (temperature > 70) return 'text-red-400';
                    if (temperature > 40) return 'text-yellow-400';
                    return 'text-blue-400';
                },

                getTemperatureGradient(temperature) {
                    if (temperature > 70) return 'bg-red-400';
                    if (temperature > 40) return 'bg-yellow-400';
                    return 'bg-blue-400';
                },

                getTemperatureIndicator(temperature) {
                    if (temperature > 70) return 'bg-red-400';
                    if (temperature > 40) return 'bg-yellow-400';
                    return 'bg-blue-400';
                },

                getPriorityColor(priority) {
                    const colors = {
                        critical: 'text-red-400',
                        high: 'text-orange-400',
                        medium: 'text-yellow-400',
                        low: 'text-gray-400'
                    };
                    return colors[priority] || 'text-gray-400';
                },

                getMemoryActivityClass(memory) {
                    if (memory.temperature > 70) return 'border-red-400/50 bg-red-400/5';
                    if (memory.temperature > 40) return 'border-yellow-400/50 bg-yellow-400/5';
                    return 'border-blue-400/50 bg-blue-400/5';
                },

                getMemoryTypeColor(memoryType) {
                    const colors = {
                        thought: 'text-blue-400',
                        goal: 'text-green-400',
                        plan: 'text-purple-400',
                        observation: 'text-yellow-400',
                        insight: 'text-pink-400',
                        decision: 'text-red-400'
                    };
                    return colors[memoryType] || 'text-gray-400';
                },

                getAccessFrequencyColor(accessCount) {
                    if (accessCount > 10) return 'bg-green-400';
                    if (accessCount > 5) return 'bg-yellow-400';
                    if (accessCount > 0) return 'bg-blue-400';
                    return 'bg-gray-400';
                },

                getSuggestionBorderClass(priority) {
                    const classes = {
                        high: 'border-red-400',
                        medium: 'border-yellow-400',
                        low: 'border-blue-400'
                    };
                    return classes[priority] || 'border-gray-400';
                },

                getSuggestionIconClass(priority) {
                    const classes = {
                        high: 'text-red-400',
                        medium: 'text-yellow-400',
                        low: 'text-blue-400'
                    };
                    return classes[priority] || 'text-gray-400';
                },

                getSuggestionPriorityClass(priority) {
                    const classes = {
                        high: 'bg-red-500/20 text-red-400',
                        medium: 'bg-yellow-500/20 text-yellow-400',
                        low: 'bg-blue-500/20 text-blue-400'
                    };
                    return classes[priority] || 'bg-gray-500/20 text-gray-400';
                },

                // =================== WORKFLOW DEPENDENCY GRAPH METHODS ===================

                async initializeWorkflowDependencies() {
                    console.log('📊 Initializing Workflow Dependency Graph...');
                    
                    try {
                        // Load workflow dependency data
                        await this.loadWorkflowDependencyData();
                        
                        // Initialize visualizations
                        await this.$nextTick();
                        this.renderWorkflowDependencyGraph();
                        
                        // Initialize Gantt chart
                        this.initializeGanttChart();
                        
                        console.log('✅ Workflow Dependency Graph initialized successfully');
                        
                    } catch (error) {
                        console.error('❌ Error initializing workflow dependencies:', error);
                        this.showToast('Error initializing workflow dependency graph', 'error');
                    }
                },

                async loadWorkflowDependencyData() {
                    try {
                        // Load workflows with enhanced timing and dependency information
                        this.dependencyWorkflows = this.workflows.map(workflow => {
                            const workflowActions = this.actions.filter(a => a.workflow_id === workflow.workflow_id);
                            
                            // Calculate workflow timeline
                            const startTime = workflowActions.length > 0 ? 
                                Math.min(...workflowActions.map(a => a.started_at || a.created_at)) : 
                                workflow.created_at;
                            const endTime = workflowActions.length > 0 ? 
                                Math.max(...workflowActions.map(a => a.completed_at || a.started_at || a.created_at)) : 
                                workflow.updated_at;
                            
                            return {
                                ...workflow,
                                start_time: startTime,
                                end_time: endTime,
                                duration: endTime - startTime,
                                actions: workflowActions,
                                dependencies: [],
                                dependents: [],
                                resources: this.extractWorkflowResources(workflow, workflowActions),
                                progress: this.calculateWorkflowProgress(workflowActions),
                                critical_path: false,
                                resource_conflicts: [],
                                x: 0,
                                y: 0
                            };
                        });

                        // Analyze workflow dependencies (mock implementation - in real app this would be from API)
                        this.analyzeWorkflowDependencies();
                        
                        // Calculate critical path
                        this.calculateCriticalPath();
                        
                        // Detect resource conflicts
                        this.detectResourceConflicts();
                        
                        // Load action dependencies within workflows
                        this.loadActionDependencies();
                        
                        console.log(`Loaded ${this.dependencyWorkflows.length} workflows with dependencies`);
                        
                    } catch (error) {
                        console.error('Error loading workflow dependency data:', error);
                        throw error;
                    }
                },

                extractWorkflowResources(workflow, actions) {
                    // Extract resources from workflow and actions
                    const resources = new Set();
                    
                    // Add workflow owner as resource
                    if (workflow.owner) resources.add(workflow.owner);
                    
                    // Extract from action tool usage
                    actions.forEach(action => {
                        if (action.tool_name) resources.add(`tool:${action.tool_name}`);
                        if (action.action_type) resources.add(`type:${action.action_type}`);
                    });
                    
                    return Array.from(resources);
                },

                calculateWorkflowProgress(actions) {
                    if (actions.length === 0) return 0;
                    
                    const completedActions = actions.filter(a => a.status === 'completed').length;
                    return Math.round((completedActions / actions.length) * 100);
                },

                analyzeWorkflowDependencies() {
                    // Mock dependency analysis - in real implementation this would use memory links, etc.
                    this.dependencyWorkflows.forEach((workflow, index) => {
                        // Create some sample dependencies based on creation order and shared resources
                        this.dependencyWorkflows.forEach((otherWorkflow, otherIndex) => {
                            if (index !== otherIndex) {
                                // Dependency if workflows share resources and one started after the other
                                const sharedResources = workflow.resources.filter(r => otherWorkflow.resources.includes(r));
                                const timeGap = workflow.start_time - otherWorkflow.start_time;
                                
                                if (sharedResources.length > 0 && timeGap > 0 && timeGap < 86400) { // Within 24 hours
                                    workflow.dependencies.push({
                                        workflow_id: otherWorkflow.workflow_id,
                                        type: 'resource_dependency',
                                        shared_resources: sharedResources,
                                        strength: sharedResources.length / Math.max(workflow.resources.length, 1)
                                    });
                                    
                                    otherWorkflow.dependents.push({
                                        workflow_id: workflow.workflow_id,
                                        type: 'resource_dependency',
                                        shared_resources: sharedResources,
                                        strength: sharedResources.length / Math.max(otherWorkflow.resources.length, 1)
                                    });
                                }
                            }
                        });
                    });
                },

                calculateCriticalPath() {
                    // Implementation of critical path method (CPM)
                    const workflows = [...this.dependencyWorkflows];
                    
                    // Reset critical path flags
                    workflows.forEach(w => {
                        w.critical_path = false;
                        w.earliest_start = 0;
                        w.latest_start = 0;
                        w.slack = 0;
                    });
                    
                    // Forward pass - calculate earliest start times
                    workflows.sort((a, b) => a.start_time - b.start_time);
                    
                    workflows.forEach(workflow => {
                        let maxEarliestFinish = 0;
                        
                        workflow.dependencies.forEach(dep => {
                            const depWorkflow = workflows.find(w => w.workflow_id === dep.workflow_id);
                            if (depWorkflow) {
                                const earliestFinish = depWorkflow.earliest_start + depWorkflow.duration;
                                maxEarliestFinish = Math.max(maxEarliestFinish, earliestFinish);
                            }
                        });
                        
                        workflow.earliest_start = maxEarliestFinish;
                    });
                    
                    // Backward pass - calculate latest start times
                    const projectEnd = Math.max(...workflows.map(w => w.earliest_start + w.duration));
                    
                    workflows.reverse().forEach(workflow => {
                        if (workflow.dependents.length === 0) {
                            workflow.latest_start = workflow.earliest_start;
                        } else {
                            let minLatestStart = projectEnd;
                            
                            workflow.dependents.forEach(dep => {
                                const depWorkflow = workflows.find(w => w.workflow_id === dep.workflow_id);
                                if (depWorkflow) {
                                    minLatestStart = Math.min(minLatestStart, depWorkflow.latest_start);
                                }
                            });
                            
                            workflow.latest_start = minLatestStart - workflow.duration;
                        }
                        
                        workflow.slack = workflow.latest_start - workflow.earliest_start;
                        workflow.critical_path = workflow.slack === 0;
                    });
                    
                    const criticalWorkflows = workflows.filter(w => w.critical_path);
                    this.criticalPathStats = {
                        totalWorkflows: criticalWorkflows.length,
                        totalDuration: projectEnd,
                        bottlenecks: criticalWorkflows.map(w => w.title || w.workflow_id)
                    };
                },

                detectResourceConflicts() {
                    const resourceSchedule = new Map();
                    
                    // Build resource usage timeline
                    this.dependencyWorkflows.forEach(workflow => {
                        workflow.resources.forEach(resource => {
                            if (!resourceSchedule.has(resource)) {
                                resourceSchedule.set(resource, []);
                            }
                            
                            resourceSchedule.get(resource).push({
                                workflow_id: workflow.workflow_id,
                                workflow_title: workflow.title,
                                start_time: workflow.start_time,
                                end_time: workflow.end_time,
                                resource: resource
                            });
                        });
                    });
                    
                    // Detect conflicts
                    this.resourceConflicts = [];
                    
                    resourceSchedule.forEach((usages, resource) => {
                        const sortedUsages = usages.sort((a, b) => a.start_time - b.start_time);
                        
                        for (let i = 0; i < sortedUsages.length - 1; i++) {
                            const current = sortedUsages[i];
                            const next = sortedUsages[i + 1];
                            
                            // Check for overlap
                            if (current.end_time > next.start_time) {
                                const conflict = {
                                    id: `conflict_${this.resourceConflicts.length}`,
                                    resource: resource,
                                    workflows: [
                                        { id: current.workflow_id, title: current.workflow_title },
                                        { id: next.workflow_id, title: next.workflow_title }
                                    ],
                                    overlap_start: next.start_time,
                                    overlap_end: Math.min(current.end_time, next.end_time),
                                    severity: this.calculateConflictSeverity(current, next),
                                    suggestions: this.generateConflictResolution(current, next)
                                };
                                
                                this.resourceConflicts.push(conflict);
                                
                                // Mark workflows with conflicts
                                const workflow1 = this.dependencyWorkflows.find(w => w.workflow_id === current.workflow_id);
                                const workflow2 = this.dependencyWorkflows.find(w => w.workflow_id === next.workflow_id);
                                
                                if (workflow1) workflow1.resource_conflicts.push(conflict.id);
                                if (workflow2) workflow2.resource_conflicts.push(conflict.id);
                            }
                        }
                    });
                },

                calculateConflictSeverity(usage1, usage2) {
                    const overlapDuration = Math.min(usage1.end_time, usage2.end_time) - usage2.start_time;
                    const totalDuration = Math.max(usage1.end_time - usage1.start_time, usage2.end_time - usage2.start_time);
                    const overlapPercentage = (overlapDuration / totalDuration) * 100;
                    
                    if (overlapPercentage > 75) return 'high';
                    if (overlapPercentage > 25) return 'medium';
                    return 'low';
                },

                generateConflictResolution(usage1, usage2) {
                    const suggestions = [];
                    
                    suggestions.push({
                        type: 'delay',
                        description: `Delay "${usage2.workflow_title}" until "${usage1.workflow_title}" completes`,
                        impact: 'schedule_delay'
                    });
                    
                    suggestions.push({
                        type: 'resource_split',
                        description: `Split ${usage1.resource} usage between workflows`,
                        impact: 'reduced_efficiency'
                    });
                    
                    suggestions.push({
                        type: 'parallel_resource',
                        description: `Assign additional ${usage1.resource} instances`,
                        impact: 'increased_cost'
                    });
                    
                    return suggestions;
                },

                loadActionDependencies() {
                    // Load action-level dependencies within workflows
                    this.dependencyWorkflows.forEach(workflow => {
                        const actions = workflow.actions.sort((a, b) => (a.started_at || a.created_at) - (b.started_at || b.created_at));
                        
                        // Create sequential dependencies between actions
                        actions.forEach((action, index) => {
                            action.dependencies = [];
                            action.dependents = [];
                            action.slack = 0;
                            action.critical_path = false;
                            
                            if (index > 0) {
                                action.dependencies.push({
                                    action_id: actions[index - 1].action_id,
                                    type: 'sequential',
                                    strength: 1.0
                                });
                                
                                actions[index - 1].dependents.push({
                                    action_id: action.action_id,
                                    type: 'sequential',
                                    strength: 1.0
                                });
                            }
                        });
                        
                        workflow.actions = actions;
                    });
                },

                renderWorkflowDependencyGraph() {
                    if (!window.d3 || !this.dependencyWorkflows.length) {
                        console.log('D3 not available or no workflow data');
                        return;
                    }
                    
                    try {
                        this.renderNetworkView();
                        this.renderGanttView();
                        
                        console.log('Workflow dependency graph rendered successfully');
                        
                    } catch (error) {
                        console.error('Error rendering workflow dependency graph:', error);
                    }
                },

                renderNetworkView() {
                    const svg = d3.select(this.$refs.dependencyNetworkSvg);
                    const container = this.$refs.dependencyNetworkSvg.parentElement;
                    const rect = container.getBoundingClientRect();
                    
                    const width = rect.width;
                    const height = rect.height;
                    
                    // Clear previous content
                    svg.selectAll("*").remove();
                    svg.attr("width", width).attr("height", height);
                    
                    // Create main group
                    const g = svg.append("g").attr("class", "network-content");
                    
                    // Add zoom behavior
                    const zoom = d3.zoom()
                        .scaleExtent([0.3, 3])
                        .on("zoom", (event) => {
                            g.attr("transform", event.transform);
                        });
                    
                    svg.call(zoom);
                    
                    // Prepare data for network visualization
                    const nodes = this.dependencyWorkflows.map(workflow => ({
                        id: workflow.workflow_id,
                        ...workflow,
                        fx: null,
                        fy: null
                    }));
                    
                    const links = [];
                    this.dependencyWorkflows.forEach(workflow => {
                        workflow.dependencies.forEach(dep => {
                            links.push({
                                source: dep.workflow_id,
                                target: workflow.workflow_id,
                                type: dep.type,
                                strength: dep.strength
                            });
                        });
                    });
                    
                    // Create force simulation
                    const simulation = d3.forceSimulation(nodes)
                        .force("link", d3.forceLink(links).id(d => d.id).distance(120))
                        .force("charge", d3.forceManyBody().strength(-300))
                        .force("center", d3.forceCenter(width / 2, height / 2))
                        .force("collision", d3.forceCollide().radius(40));
                    
                    // Draw links
                    const link = g.append("g")
                        .attr("class", "links")
                        .selectAll("line")
                        .data(links)
                        .enter().append("line")
                        .attr("stroke", d => this.getDependencyLinkColor(d.type))
                        .attr("stroke-width", d => Math.max(1, d.strength * 4))
                        .attr("stroke-opacity", 0.8)
                        .attr("marker-end", "url(#arrowhead)");
                    
                    // Add arrowhead marker
                    svg.append("defs").append("marker")
                        .attr("id", "arrowhead")
                        .attr("viewBox", "0 -5 10 10")
                        .attr("refX", 25)
                        .attr("refY", 0)
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .attr("orient", "auto")
                        .append("path")
                        .attr("d", "M0,-5L10,0L0,5")
                        .attr("fill", "#64748b");
                    
                    // Draw nodes
                    const node = g.append("g")
                        .attr("class", "nodes")
                        .selectAll("g")
                        .data(nodes)
                        .enter().append("g")
                        .attr("class", "workflow-node")
                        .style("cursor", "pointer")
                        .call(this.createWorkflowDrag(simulation));
                    
                    // Node backgrounds
                    node.append("rect")
                        .attr("x", -35)
                        .attr("y", -20)
                        .attr("width", 70)
                        .attr("height", 40)
                        .attr("rx", 8)
                        .attr("fill", d => this.getWorkflowNodeColor(d))
                        .attr("stroke", d => d.critical_path ? "#ef4444" : "#64748b")
                        .attr("stroke-width", d => d.critical_path ? 3 : 1)
                        .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))");
                    
                    // Node titles
                    node.append("text")
                        .attr("dy", "-5")
                        .attr("text-anchor", "middle")
                        .style("fill", "#ffffff")
                        .style("font-size", "10px")
                        .style("font-weight", "600")
                        .style("pointer-events", "none")
                        .text(d => this.truncateText(d.title || d.workflow_id, 12));
                    
                    // Progress indicators
                    node.append("text")
                        .attr("dy", "8")
                        .attr("text-anchor", "middle")
                        .style("fill", "#d1d5db")
                        .style("font-size", "8px")
                        .style("pointer-events", "none")
                        .text(d => `${d.progress}%`);
                    
                    // Conflict indicators
                    node.filter(d => d.resource_conflicts.length > 0)
                        .append("circle")
                        .attr("cx", 25)
                        .attr("cy", -15)
                        .attr("r", 6)
                        .attr("fill", "#ef4444")
                        .style("animation", "pulse 2s infinite");
                    
                    // Add interactions
                    node
                        .on("click", (event, d) => this.selectWorkflowNode(d))
                        .on("mouseover", (event, d) => this.showWorkflowTooltip(event, d))
                        .on("mouseout", () => this.hideWorkflowTooltip());
                    
                    // Update positions on simulation tick
                    simulation.on("tick", () => {
                        link
                            .attr("x1", d => d.source.x)
                            .attr("y1", d => d.source.y)
                            .attr("x2", d => d.target.x)
                            .attr("y2", d => d.target.y);
                        
                        node.attr("transform", d => `translate(${d.x}, ${d.y})`);
                    });
                    
                    this.dependencySimulation = simulation;
                },

                renderGanttView() {
                    const container = this.$refs.ganttContainer;
                    if (!container) return;
                    
                    // Clear previous content
                    d3.select(container).selectAll("*").remove();
                    
                    const margin = { top: 40, right: 40, bottom: 40, left: 200 };
                    const width = container.clientWidth - margin.left - margin.right;
                    const height = Math.max(400, this.dependencyWorkflows.length * 50 + 100);
                    
                    const svg = d3.select(container)
                        .append("svg")
                        .attr("width", container.clientWidth)
                        .attr("height", height + margin.top + margin.bottom);
                    
                    const g = svg.append("g")
                        .attr("transform", `translate(${margin.left}, ${margin.top})`);
                    
                    // Create scales
                    const timeExtent = d3.extent([
                        ...this.dependencyWorkflows.map(d => d.start_time),
                        ...this.dependencyWorkflows.map(d => d.end_time)
                    ]);
                    
                    const xScale = d3.scaleTime()
                        .domain(timeExtent.map(t => new Date(t * 1000)))
                        .range([0, width]);
                    
                    const yScale = d3.scaleBand()
                        .domain(this.dependencyWorkflows.map(d => d.workflow_id))
                        .range([0, this.dependencyWorkflows.length * 50])
                        .padding(0.2);
                    
                    // Add time axis
                    g.append("g")
                        .attr("class", "x-axis")
                        .call(d3.axisTop(xScale).tickFormat(d3.timeFormat("%m/%d %H:%M")))
                        .style("color", "#9ca3af");
                    
                    // Add grid lines
                    g.append("g")
                        .attr("class", "grid")
                        .call(d3.axisTop(xScale)
                            .tickSize(-this.dependencyWorkflows.length * 50)
                            .tickFormat("")
                        )
                        .style("stroke-dasharray", "3,3")
                        .style("opacity", 0.3);
                    
                    // Draw workflow bars
                    const workflows = g.append("g")
                        .attr("class", "workflows")
                        .selectAll(".workflow-bar")
                        .data(this.dependencyWorkflows)
                        .enter().append("g")
                        .attr("class", "workflow-bar")
                        .attr("transform", d => `translate(0, ${yScale(d.workflow_id)})`);
                    
                    // Workflow labels
                    workflows.append("text")
                        .attr("x", -10)
                        .attr("y", yScale.bandwidth() / 2)
                        .attr("dy", "0.35em")
                        .attr("text-anchor", "end")
                        .style("fill", "#e5e7eb")
                        .style("font-size", "12px")
                        .style("font-weight", "500")
                        .text(d => this.truncateText(d.title || d.workflow_id, 25));
                    
                    // Workflow bars
                    workflows.append("rect")
                        .attr("x", d => xScale(new Date(d.start_time * 1000)))
                        .attr("width", d => Math.max(2, xScale(new Date(d.end_time * 1000)) - xScale(new Date(d.start_time * 1000))))
                        .attr("height", yScale.bandwidth())
                        .attr("fill", d => this.getWorkflowBarColor(d))
                        .attr("stroke", d => d.critical_path ? "#ef4444" : "transparent")
                        .attr("stroke-width", 2)
                        .style("cursor", "ew-resize")
                        .call(this.createGanttDrag(xScale, yScale));
                    
                    // Progress bars
                    workflows.append("rect")
                        .attr("x", d => xScale(new Date(d.start_time * 1000)))
                        .attr("width", d => Math.max(0, (xScale(new Date(d.end_time * 1000)) - xScale(new Date(d.start_time * 1000))) * (d.progress / 100)))
                        .attr("height", yScale.bandwidth() / 3)
                        .attr("y", yScale.bandwidth() / 3)
                        .attr("fill", "#22c55e")
                        .style("pointer-events", "none");
                    
                    // Dependency arrows
                    const dependencies = [];
                    this.dependencyWorkflows.forEach(workflow => {
                        workflow.dependencies.forEach(dep => {
                            const sourceWorkflow = this.dependencyWorkflows.find(w => w.workflow_id === dep.workflow_id);
                            if (sourceWorkflow) {
                                dependencies.push({
                                    source: sourceWorkflow,
                                    target: workflow,
                                    ...dep
                                });
                            }
                        });
                    });
                    
                    g.append("g")
                        .attr("class", "dependencies")
                        .selectAll(".dependency-line")
                        .data(dependencies)
                        .enter().append("line")
                        .attr("class", "dependency-line")
                        .attr("x1", d => xScale(new Date(d.source.end_time * 1000)))
                        .attr("y1", d => yScale(d.source.workflow_id) + yScale.bandwidth() / 2)
                        .attr("x2", d => xScale(new Date(d.target.start_time * 1000)))
                        .attr("y2", d => yScale(d.target.workflow_id) + yScale.bandwidth() / 2)
                        .attr("stroke", "#64748b")
                        .attr("stroke-width", 2)
                        .attr("marker-end", "url(#gantt-arrowhead)");
                    
                    // Add arrowhead marker for Gantt
                    svg.append("defs").append("marker")
                        .attr("id", "gantt-arrowhead")
                        .attr("viewBox", "0 -5 10 10")
                        .attr("refX", 10)
                        .attr("refY", 0)
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .attr("orient", "auto")
                        .append("path")
                        .attr("d", "M0,-5L10,0L0,5")
                        .attr("fill", "#64748b");
                    
                    this.ganttSvg = svg;
                    this.ganttXScale = xScale;
                    this.ganttYScale = yScale;
                },

                createWorkflowDrag(simulation) {
                    return d3.drag()
                        .on("start", (event, d) => {
                            if (!event.active) simulation.alphaTarget(0.3).restart();
                            d.fx = d.x;
                            d.fy = d.y;
                        })
                        .on("drag", (event, d) => {
                            d.fx = event.x;
                            d.fy = event.y;
                        })
                        .on("end", (event, d) => {
                            if (!event.active) simulation.alphaTarget(0);
                            d.fx = null;
                            d.fy = null;
                        });
                },

                createGanttDrag(xScale, yScale) {
                    return d3.drag()
                        .on("start", (event, d) => {
                            this.isDraggingWorkflow = true;
                            this.originalWorkflowTiming = {
                                workflow_id: d.workflow_id,
                                start_time: d.start_time,
                                end_time: d.end_time
                            };
                        })
                        .on("drag", (event, d) => {
                            const newStartTime = Math.round(xScale.invert(event.x).getTime() / 1000);
                            const duration = d.end_time - d.start_time;
                            
                            d.start_time = newStartTime;
                            d.end_time = newStartTime + duration;
                            
                            // Update the visual position
                            d3.select(event.sourceEvent.target)
                                .attr("x", xScale(new Date(d.start_time * 1000)));
                            
                            // Check for conflicts during drag
                            this.highlightScheduleConflicts(d);
                        })
                        .on("end", (event, d) => {
                            this.isDraggingWorkflow = false;
                            
                            // Validate the new schedule
                            const conflicts = this.validateScheduleChange(d);
                            
                            if (conflicts.length > 0 && !this.simulationMode) {
                                // Revert if conflicts exist and not in simulation mode
                                const original = this.originalWorkflowTiming;
                                d.start_time = original.start_time;
                                d.end_time = original.end_time;
                                
                                this.showToast(`Schedule conflict detected. Changes reverted.`, 'warning');
                                this.renderGanttView(); // Re-render to show original positions
                            } else {
                                // Apply the changes
                                this.applyScheduleChange(d);
                                
                                // Recalculate dependencies and conflicts
                                this.calculateCriticalPath();
                                this.detectResourceConflicts();
                                
                                if (conflicts.length > 0) {
                                    this.showToast(`Schedule updated with ${conflicts.length} conflicts`, 'warning');
                                } else {
                                    this.showToast('Schedule updated successfully', 'success');
                                }
                            }
                        });
                },

                highlightScheduleConflicts(workflow) {
                    // Temporarily highlight potential conflicts during drag
                    const conflicts = this.validateScheduleChange(workflow);
                    
                    if (this.ganttSvg) {
                        this.ganttSvg.selectAll(".workflow-bar rect")
                            .attr("stroke", d => {
                                if (d.workflow_id === workflow.workflow_id) return "#3b82f6";
                                return conflicts.some(c => c.workflows.includes(d.workflow_id)) ? "#ef4444" : "transparent";
                            })
                            .attr("stroke-width", d => {
                                if (d.workflow_id === workflow.workflow_id) return 3;
                                return conflicts.some(c => c.workflows.includes(d.workflow_id)) ? 2 : 1;
                            });
                    }
                },

                validateScheduleChange(workflow) {
                    const conflicts = [];
                    
                    // Check resource conflicts
                    this.dependencyWorkflows.forEach(otherWorkflow => {
                        if (otherWorkflow.workflow_id === workflow.workflow_id) return;
                        
                        const sharedResources = workflow.resources.filter(r => otherWorkflow.resources.includes(r));
                        if (sharedResources.length === 0) return;
                        
                        // Check for time overlap
                        const overlap = !(workflow.end_time <= otherWorkflow.start_time || workflow.start_time >= otherWorkflow.end_time);
                        
                        if (overlap) {
                            conflicts.push({
                                type: 'resource_conflict',
                                workflows: [workflow.workflow_id, otherWorkflow.workflow_id],
                                resources: sharedResources,
                                severity: this.calculateOverlapSeverity(workflow, otherWorkflow)
                            });
                        }
                    });
                    
                    // Check dependency violations
                    workflow.dependencies.forEach(dep => {
                        const depWorkflow = this.dependencyWorkflows.find(w => w.workflow_id === dep.workflow_id);
                        if (depWorkflow && workflow.start_time < depWorkflow.end_time) {
                            conflicts.push({
                                type: 'dependency_violation',
                                workflows: [workflow.workflow_id, depWorkflow.workflow_id],
                                violation: 'workflow_starts_before_dependency_completes'
                            });
                        }
                    });
                    
                    return conflicts;
                },

                calculateOverlapSeverity(workflow1, workflow2) {
                    const overlapStart = Math.max(workflow1.start_time, workflow2.start_time);
                    const overlapEnd = Math.min(workflow1.end_time, workflow2.end_time);
                    const overlapDuration = overlapEnd - overlapStart;
                    
                    const totalDuration = Math.min(workflow1.duration, workflow2.duration);
                    const overlapPercentage = (overlapDuration / totalDuration) * 100;
                    
                    if (overlapPercentage > 75) return 'high';
                    if (overlapPercentage > 25) return 'medium';
                    return 'low';
                },

                async applyScheduleChange(workflow) {
                    try {
                        // In a real implementation, this would call the backend API
                        const response = await fetch(`/api/workflows/${workflow.workflow_id}/schedule`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                start_time: workflow.start_time,
                                end_time: workflow.end_time,
                                simulation_mode: this.simulationMode
                            })
                        });
                        
                        if (!response.ok && !this.simulationMode) {
                            throw new Error('Failed to update workflow schedule');
                        }
                        
                        // Update local data
                        const workflowIndex = this.dependencyWorkflows.findIndex(w => w.workflow_id === workflow.workflow_id);
                        if (workflowIndex !== -1) {
                            this.dependencyWorkflows[workflowIndex] = workflow;
                        }
                        
                    } catch (error) {
                        console.error('Error applying schedule change:', error);
                        if (!this.simulationMode) {
                            throw error;
                        }
                    }
                },

                // Visual styling methods
                getWorkflowNodeColor(workflow) {
                    if (workflow.critical_path) return '#dc2626';
                    if (workflow.resource_conflicts.length > 0) return '#f59e0b';
                    
                    switch (workflow.status) {
                        case 'completed': return '#10b981';
                        case 'active': return '#3b82f6';
                        case 'paused': return '#6b7280';
                        case 'failed': return '#ef4444';
                        default: return '#8b5cf6';
                    }
                },

                getWorkflowBarColor(workflow) {
                    const baseColor = this.getWorkflowNodeColor(workflow);
                    return workflow.critical_path ? baseColor : d3.color(baseColor).opacity(0.8);
                },

                getDependencyLinkColor(type) {
                    const colors = {
                        'resource_dependency': '#f59e0b',
                        'sequential': '#3b82f6',
                        'conditional': '#8b5cf6',
                        'causal': '#10b981'
                    };
                    return colors[type] || '#64748b';
                },

                getConflictSeverityColor(severity) {
                    const colors = {
                        'high': '#ef4444',
                        'medium': '#f59e0b',
                        'low': '#3b82f6'
                    };
                    return colors[severity] || '#6b7280';
                },

                // Interaction methods
                selectWorkflowNode(workflow) {
                    this.selectedDependencyWorkflow = workflow;
                    
                    // Highlight connected workflows
                    if (this.dependencySimulation) {
                        const svg = d3.select(this.$refs.dependencyNetworkSvg);
                        
                        svg.selectAll(".workflow-node rect")
                            .attr("stroke-width", d => {
                                if (d.workflow_id === workflow.workflow_id) return 4;
                                if (workflow.dependencies.some(dep => dep.workflow_id === d.workflow_id) ||
                                    workflow.dependents.some(dep => dep.workflow_id === d.workflow_id)) return 2;
                                return 1;
                            })
                            .attr("stroke", d => {
                                if (d.workflow_id === workflow.workflow_id) return "#3b82f6";
                                if (workflow.dependencies.some(dep => dep.workflow_id === d.workflow_id)) return "#10b981";
                                if (workflow.dependents.some(dep => dep.workflow_id === d.workflow_id)) return "#f59e0b";
                                return d.critical_path ? "#ef4444" : "#64748b";
                            });
                    }
                },

                showWorkflowTooltip(event, workflow) {
                    const tooltip = d3.select("body")
                        .append("div")
                        .attr("class", "workflow-dependency-tooltip")
                        .style("position", "absolute")
                        .style("background", "rgba(0, 0, 0, 0.9)")
                        .style("color", "white")
                        .style("padding", "12px")
                        .style("border-radius", "8px")
                        .style("font-size", "12px")
                        .style("pointer-events", "none")
                        .style("z-index", "1000")
                        .style("box-shadow", "0 4px 12px rgba(0,0,0,0.3)");
                    
                    const startDate = new Date(workflow.start_time * 1000);
                    const endDate = new Date(workflow.end_time * 1000);
                    
                    tooltip.html(`
                        <div class="font-semibold mb-2">${workflow.title || workflow.workflow_id}</div>
                        <div class="text-sm space-y-1">
                            <div>Status: <span class="text-blue-400">${workflow.status}</span></div>
                            <div>Progress: <span class="text-green-400">${workflow.progress}%</span></div>
                            <div>Start: ${startDate.toLocaleString()}</div>
                            <div>End: ${endDate.toLocaleString()}</div>
                            <div>Duration: ${this.formatDuration(workflow.start_time, workflow.end_time)}</div>
                            <div>Actions: ${workflow.actions.length}</div>
                            <div>Dependencies: ${workflow.dependencies.length}</div>
                            <div>Resources: ${workflow.resources.length}</div>
                            ${workflow.critical_path ? '<div class="text-red-400 font-semibold">⚠ Critical Path</div>' : ''}
                            ${workflow.resource_conflicts.length > 0 ? '<div class="text-yellow-400 font-semibold">⚠ Resource Conflicts</div>' : ''}
                        </div>
                    `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                },

                hideWorkflowTooltip() {
                    d3.selectAll(".workflow-dependency-tooltip").remove();
                },

                // Simulation and optimization methods
                toggleSimulationMode() {
                    this.simulationMode = !this.simulationMode;
                    
                    if (this.simulationMode) {
                        this.createSimulationSnapshot();
                        this.showToast('Simulation mode enabled - changes are temporary', 'info');
                    } else {
                        this.showToast('Simulation mode disabled - changes will be permanent', 'warning');
                    }
                },

                createSimulationSnapshot() {
                    this.simulationSnapshot = {
                        workflows: JSON.parse(JSON.stringify(this.dependencyWorkflows)),
                        conflicts: JSON.parse(JSON.stringify(this.resourceConflicts)),
                        criticalPath: JSON.parse(JSON.stringify(this.criticalPathStats)),
                        timestamp: Date.now()
                    };
                },

                restoreFromSnapshot() {
                    if (!this.simulationSnapshot) {
                        this.showToast('No snapshot available to restore', 'warning');
                        return;
                    }
                    
                    this.dependencyWorkflows = this.simulationSnapshot.workflows;
                    this.resourceConflicts = this.simulationSnapshot.conflicts;
                    this.criticalPathStats = this.simulationSnapshot.criticalPath;
                    
                    this.renderWorkflowDependencyGraph();
                    this.showToast('Restored from simulation snapshot', 'success');
                },

                async optimizeSchedule() {
                    if (this.isOptimizingSchedule) return;
                    
                    this.isOptimizingSchedule = true;
                    
                    try {
                        // Implement schedule optimization algorithm
                        const optimizedSchedule = await this.runScheduleOptimization();
                        
                        if (optimizedSchedule) {
                            // Apply optimized schedule
                            this.dependencyWorkflows = optimizedSchedule.workflows;
                            this.resourceConflicts = optimizedSchedule.conflicts;
                            this.criticalPathStats = optimizedSchedule.criticalPath;
                            
                            this.renderWorkflowDependencyGraph();
                            this.showToast(`Schedule optimized! Reduced conflicts by ${optimizedSchedule.improvement}%`, 'success');
                        }
                        
                    } catch (error) {
                        console.error('Error optimizing schedule:', error);
                        this.showToast('Error during schedule optimization', 'error');
                    } finally {
                        this.isOptimizingSchedule = false;
                    }
                },

                async runScheduleOptimization() {
                    // Simple optimization algorithm - in practice this would be more sophisticated
                    const workflows = [...this.dependencyWorkflows];
                    let totalImprovements = 0;
                    
                    // Sort by critical path and dependencies
                    const sortedWorkflows = workflows.sort((a, b) => {
                        if (a.critical_path && !b.critical_path) return -1;
                        if (!a.critical_path && b.critical_path) return 1;
                        return a.dependencies.length - b.dependencies.length;
                    });
                    
                    // Try to resolve conflicts by shifting non-critical workflows
                    for (const workflow of sortedWorkflows) {
                        if (workflow.critical_path) continue;
                        
                        const originalConflicts = this.validateScheduleChange(workflow).length;
                        
                        // Try shifting later
                        const shiftAmount = 3600; // 1 hour
                        workflow.start_time += shiftAmount;
                        workflow.end_time += shiftAmount;
                        
                        const newConflicts = this.validateScheduleChange(workflow).length;
                        
                        if (newConflicts < originalConflicts) {
                            totalImprovements += originalConflicts - newConflicts;
                        } else {
                            // Revert if no improvement
                            workflow.start_time -= shiftAmount;
                            workflow.end_time -= shiftAmount;
                        }
                    }
                    
                    // Recalculate everything
                    this.dependencyWorkflows = workflows;
                    this.calculateCriticalPath();
                    this.detectResourceConflicts();
                    
                    return {
                        workflows: this.dependencyWorkflows,
                        conflicts: this.resourceConflicts,
                        criticalPath: this.criticalPathStats,
                        improvement: Math.round((totalImprovements / Math.max(1, workflows.length)) * 100)
                    };
                },

                exportSchedule() {
                    const exportData = {
                        workflows: this.dependencyWorkflows,
                        dependencies: this.dependencyWorkflows.flatMap(w => 
                            w.dependencies.map(d => ({
                                source: d.workflow_id,
                                target: w.workflow_id,
                                type: d.type,
                                strength: d.strength
                            }))
                        ),
                        conflicts: this.resourceConflicts,
                        criticalPath: this.criticalPathStats,
                        simulation: this.simulationMode,
                        exported_at: new Date().toISOString()
                    };
                    
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `workflow-dependencies-${Date.now()}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    this.showToast('Schedule exported successfully! 📁', 'success');
                },

                resetDependencyView() {
                    this.selectedDependencyWorkflow = null;
                    this.dependencyViewMode = 'combined';
                    this.simulationMode = false;
                    this.simulationSnapshot = null;
                    this.dependencyFilter = '';
                    
                    if (this.dependencySimulation) {
                        this.dependencySimulation.restart();
                    }
                    
                    this.showToast('Dependency view reset', 'info');
                },

                initializeGanttChart() {
                    // This method is called during initialization to set up Gantt chart specific features
                    // Most of the Gantt functionality is handled in renderGanttView()
                    console.log('Gantt chart features initialized');
                },

                // =================== COGNITIVE STATE TIMELINE METHODS ===================

                async initializeCognitiveTimeline() {
                    console.log('🧠 Initializing Cognitive State Timeline...');
                    
                    try {
                        // Load initial timeline data
                        await this.loadCognitiveTimeline();
                        
                        // Initialize timeline visualization
                        await this.$nextTick();
                        this.renderTimelineVisualization();
                        
                        console.log('✅ Cognitive State Timeline initialized successfully');
                        
                    } catch (error) {
                        console.error('❌ Error initializing cognitive timeline:', error);
                        this.showToast('Error initializing cognitive timeline', 'error');
                    }
                },

                async loadCognitiveTimeline() {
                    if (this.isLoadingTimeline) return;
                    
                    this.isLoadingTimeline = true;
                    
                    try {
                        const response = await fetch(`/api/cognitive-states/timeline?hours=${this.cognitiveTimelineSettings.timeRange}&granularity=${this.cognitiveTimelineSettings.granularity}`);
                        
                        if (!response.ok) {
                            throw new Error(`Failed to load timeline: ${response.statusText}`);
                        }
                        
                        const data = await response.json();
                        
                        this.cognitiveTimelineData = data.timeline_data || [];
                        this.timelineStats = data.summary_stats || {};
                        
                        // Set initial position
                        if (this.cognitiveTimelineData.length > 0) {
                            this.currentTimelineIndex = this.cognitiveTimelineData.length - 1; // Start at latest
                            this.selectedTimelineState = this.cognitiveTimelineData[this.currentTimelineIndex];
                        }
                        
                        // Update visualization if already rendered
                        if (this.currentView === 'cognitive-timeline') {
                            await this.$nextTick();
                            this.renderTimelineVisualization();
                        }
                        
                        this.showToast(`Loaded ${this.cognitiveTimelineData.length} cognitive states`, 'success');
                        
                    } catch (error) {
                        console.error('Error loading cognitive timeline:', error);
                        this.showToast('Error loading cognitive timeline data', 'error');
                        
                        // Generate sample data for demonstration
                        this.generateSampleTimelineData();
                    } finally {
                        this.isLoadingTimeline = false;
                    }
                },

                generateSampleTimelineData() {
                    console.log('Generating sample cognitive timeline data for demonstration');
                    
                    const now = Date.now() / 1000;
                    const sampleStates = [];
                    
                    const stateTypes = ['planning', 'execution', 'reflection', 'learning', 'decision'];
                    const complexityRange = [10, 90];
                    
                    for (let i = 0; i < 20; i++) {
                        const timestamp = now - (i * 300); // Every 5 minutes
                        const stateType = stateTypes[Math.floor(Math.random() * stateTypes.length)];
                        const complexity = Math.random() * (complexityRange[1] - complexityRange[0]) + complexityRange[0];
                        
                        sampleStates.push({
                            state_id: `sample_${i}`,
                            timestamp: timestamp,
                            formatted_time: new Date(timestamp * 1000).toISOString(),
                            state_type: stateType,
                            workflow_id: `workflow_${Math.floor(i / 5)}`,
                            description: `Sample ${stateType} state`,
                            sequence_number: i + 1,
                            complexity_score: complexity,
                            change_magnitude: i > 0 ? Math.random() * 50 : 0,
                            key_components: [
                                { name: 'working_memory', type: 'dict', summary: 'Active memory items' },
                                { name: 'goals', type: 'list', summary: 'Current objectives' },
                                { name: 'context', type: 'dict', summary: 'Environmental context' }
                            ],
                            tags: [stateType, 'sample', Math.random() > 0.5 ? 'high-importance' : 'normal']
                        });
                    }
                    
                    this.cognitiveTimelineData = sampleStates.reverse(); // Chronological order
                    this.timelineStats = {
                        total_states: sampleStates.length,
                        avg_complexity: sampleStates.reduce((sum, s) => sum + s.complexity_score, 0) / sampleStates.length,
                        max_complexity: Math.max(...sampleStates.map(s => s.complexity_score)),
                        avg_change_magnitude: sampleStates.reduce((sum, s) => sum + s.change_magnitude, 0) / sampleStates.length,
                        max_change_magnitude: Math.max(...sampleStates.map(s => s.change_magnitude)),
                        most_common_type: 'planning',
                        total_duration_hours: (sampleStates.length * 5) / 60 // 5 minutes per state
                    };
                    
                    this.currentTimelineIndex = sampleStates.length - 1;
                    this.selectedTimelineState = sampleStates[this.currentTimelineIndex];
                    
                    // Generate sample patterns
                    this.patternAnalysis = {
                        patterns: [
                            {
                                type: 'repeating_planning',
                                length: 3,
                                similarity: 0.85,
                                occurrences: 2,
                                first_occurrence: now - 1800,
                                pattern_description: 'Repeating planning sequence of 3 states'
                            }
                        ],
                        transitions: [
                            { transition: 'planning → execution', count: 8, percentage: 40 },
                            { transition: 'execution → reflection', count: 6, percentage: 30 },
                            { transition: 'reflection → learning', count: 4, percentage: 20 }
                        ],
                        anomalies: [
                            {
                                state_id: 'sample_5',
                                timestamp: now - 1500,
                                anomaly_type: 'complexity_outlier',
                                z_score: 2.5,
                                description: 'Unusual complexity: 85.2 (avg: 45.1)',
                                severity: 'medium'
                            }
                        ],
                        summary: {
                            pattern_count: 1,
                            most_common_transition: { transition: 'planning → execution', count: 8, percentage: 40 },
                            anomaly_count: 1
                        }
                    };
                },

                async refreshCognitiveTimeline() {
                    await this.loadCognitiveTimeline();
                    if (this.timelineViewMode === 'timeline') {
                        this.renderTimelineVisualization();
                    } else if (this.timelineViewMode === 'heatmap') {
                        this.renderTimelineHeatmap();
                    } else if (this.timelineViewMode === 'network') {
                        this.renderTimelineNetwork();
                    }
                },

                async analyzePatterns() {
                    if (this.isAnalyzingPatterns) return;
                    
                    this.isAnalyzingPatterns = true;
                    
                    try {
                        const response = await fetch(`/api/cognitive-states/patterns?lookback_hours=${this.cognitiveTimelineSettings.timeRange}`);
                        
                        if (response.ok) {
                            this.patternAnalysis = await response.json();
                            this.showToast(`Found ${this.patternAnalysis.summary.pattern_count} patterns`, 'success');
                        } else {
                            throw new Error('Failed to analyze patterns');
                        }
                        
                    } catch (error) {
                        console.error('Error analyzing patterns:', error);
                        this.showToast('Error analyzing patterns', 'error');
                    } finally {
                        this.isAnalyzingPatterns = false;
                    }
                },

                renderTimelineVisualization() {
                    if (!window.d3 || !this.cognitiveTimelineData.length) {
                        console.log('D3 not available or no timeline data');
                        return;
                    }
                    
                    try {
                        const svg = d3.select(this.$refs.cognitiveTimelineSvg);
                        const container = this.$refs.cognitiveTimelineSvg.parentElement;
                        const rect = container.getBoundingClientRect();
                        
                        const margin = { top: 40, right: 40, bottom: 80, left: 80 };
                        const width = rect.width - margin.left - margin.right;
                        const height = rect.height - margin.top - margin.bottom;
                        
                        // Clear previous content
                        svg.selectAll("*").remove();
                        
                        // Set dimensions
                        svg.attr("width", rect.width).attr("height", rect.height);
                        
                        // Create main group
                        const g = svg.append("g")
                            .attr("transform", `translate(${margin.left}, ${margin.top})`);
                        
                        // Create scales
                        const xScale = d3.scaleTime()
                            .domain(d3.extent(this.cognitiveTimelineData, d => new Date(d.timestamp * 1000)))
                            .range([0, width]);
                        
                        const yScale = d3.scaleLinear()
                            .domain([0, 100])
                            .range([height, 0]);
                        
                        const radiusScale = d3.scaleSqrt()
                            .domain([0, d3.max(this.cognitiveTimelineData, d => d.change_magnitude)])
                            .range([3, 15]);
                        
                        // Color scale for state types
                        const colorScale = d3.scaleOrdinal()
                            .domain([...new Set(this.cognitiveTimelineData.map(d => d.state_type))])
                            .range(['#10b981', '#3b82f6', '#8b5cf6', '#f59e0b', '#ef4444', '#06b6d4']);
                        
                        // Add grid lines
                        g.append("g")
                            .attr("class", "grid")
                            .attr("transform", `translate(0, ${height})`)
                            .call(d3.axisBottom(xScale)
                                .tickSize(-height)
                                .tickFormat("")
                            )
                            .style("stroke-dasharray", "3,3")
                            .style("opacity", 0.3);
                        
                        g.append("g")
                            .attr("class", "grid")
                            .call(d3.axisLeft(yScale)
                                .tickSize(-width)
                                .tickFormat("")
                            )
                            .style("stroke-dasharray", "3,3")
                            .style("opacity", 0.3);
                        
                        // Add complexity line
                        const line = d3.line()
                            .x(d => xScale(new Date(d.timestamp * 1000)))
                            .y(d => yScale(d.complexity_score))
                            .curve(d3.curveMonotoneX);
                        
                        g.append("path")
                            .datum(this.cognitiveTimelineData)
                            .attr("fill", "none")
                            .attr("stroke", "#3b82f6")
                            .attr("stroke-width", 2)
                            .attr("opacity", 0.7)
                            .attr("d", line);
                        
                        // Add state points
                        const statePoints = g.selectAll(".state-point")
                            .data(this.cognitiveTimelineData)
                            .enter().append("circle")
                            .attr("class", "state-point")
                            .attr("cx", d => xScale(new Date(d.timestamp * 1000)))
                            .attr("cy", d => yScale(d.complexity_score))
                            .attr("r", d => radiusScale(d.change_magnitude))
                            .attr("fill", d => colorScale(d.state_type))
                            .attr("stroke", "#fff")
                            .attr("stroke-width", 2)
                            .style("cursor", "pointer")
                            .style("filter", "drop-shadow(0 2px 4px rgba(0,0,0,0.3))")
                            .on("mouseover", (event, d) => this.showTimelineTooltip(event, d))
                            .on("mouseout", () => this.hideTimelineTooltip())
                            .on("click", (event, d) => this.selectTimelineState(d));
                        
                        // Add axes
                        g.append("g")
                            .attr("transform", `translate(0, ${height})`)
                            .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat("%H:%M")))
                            .style("color", "#9ca3af");
                        
                        g.append("g")
                            .call(d3.axisLeft(yScale))
                            .style("color", "#9ca3af");
                        
                        // Add axis labels
                        g.append("text")
                            .attr("transform", "rotate(-90)")
                            .attr("y", 0 - margin.left)
                            .attr("x", 0 - (height / 2))
                            .attr("dy", "1em")
                            .style("text-anchor", "middle")
                            .style("fill", "#9ca3af")
                            .style("font-size", "12px")
                            .text("Complexity Score");
                        
                        g.append("text")
                            .attr("transform", `translate(${width / 2}, ${height + margin.bottom - 10})`)
                            .style("text-anchor", "middle")
                            .style("fill", "#9ca3af")
                            .style("font-size", "12px")
                            .text("Timeline");
                        
                        // Add legend
                        const legend = g.append("g")
                            .attr("class", "legend")
                            .attr("transform", `translate(${width - 120}, 20)`);
                        
                        const stateTypes = [...new Set(this.cognitiveTimelineData.map(d => d.state_type))];
                        
                        legend.selectAll(".legend-item")
                            .data(stateTypes)
                            .enter().append("g")
                            .attr("class", "legend-item")
                            .attr("transform", (d, i) => `translate(0, ${i * 20})`)
                            .each(function(d) {
                                const item = d3.select(this);
                                item.append("circle")
                                    .attr("r", 6)
                                    .attr("fill", colorScale(d));
                                item.append("text")
                                    .attr("x", 12)
                                    .attr("y", 4)
                                    .style("font-size", "11px")
                                    .style("fill", "#e5e7eb")
                                    .text(d);
                            });
                        
                        // Highlight current state
                        this.updateTimelineHighlight();
                        
                        console.log('Timeline visualization rendered successfully');
                        
                    } catch (error) {
                        console.error('Error rendering timeline visualization:', error);
                    }
                },

                showTimelineTooltip(event, state) {
                    // Create tooltip content
                    const tooltip = d3.select("body")
                        .append("div")
                        .attr("class", "timeline-tooltip")
                        .style("position", "absolute")
                        .style("background", "rgba(0, 0, 0, 0.9)")
                        .style("color", "white")
                        .style("padding", "12px")
                        .style("border-radius", "8px")
                        .style("font-size", "12px")
                        .style("pointer-events", "none")
                        .style("z-index", "1000")
                        .style("box-shadow", "0 4px 12px rgba(0,0,0,0.3)");
                    
                    tooltip.html(`
                        <div class="font-semibold mb-1">${state.state_type}</div>
                        <div class="text-gray-300 mb-2">#${state.sequence_number}</div>
                        <div class="text-sm">
                            <div>Complexity: ${state.complexity_score.toFixed(1)}</div>
                            <div>Change: ${state.change_magnitude.toFixed(1)}%</div>
                            <div>Time: ${new Date(state.timestamp * 1000).toLocaleTimeString()}</div>
                        </div>
                    `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                },

                hideTimelineTooltip() {
                    d3.selectAll(".timeline-tooltip").remove();
                },

                selectTimelineState(state) {
                    this.selectedTimelineState = state;
                    this.currentTimelineIndex = this.cognitiveTimelineData.findIndex(s => s.state_id === state.state_id);
                    this.updateTimelineHighlight();
                },

                updateTimelineHighlight() {
                    if (!this.$refs.cognitiveTimelineSvg) return;
                    
                    const svg = d3.select(this.$refs.cognitiveTimelineSvg);
                    
                    // Reset all points
                    svg.selectAll(".state-point")
                        .attr("stroke-width", 2)
                        .style("opacity", 0.7);
                    
                    // Highlight current state
                    if (this.selectedTimelineState) {
                        svg.selectAll(".state-point")
                            .filter(d => d.state_id === this.selectedTimelineState.state_id)
                            .attr("stroke-width", 4)
                            .style("opacity", 1);
                    }
                },

                // Timeline animation controls
                playTimelineAnimation() {
                    if (this.isTimelineAnimating) {
                        this.stopTimelineAnimation();
                    } else {
                        this.startTimelineAnimation();
                    }
                },

                startTimelineAnimation() {
                    if (!this.cognitiveTimelineData.length) return;
                    
                    this.isTimelineAnimating = true;
                    const interval = 1000 / this.timelineAnimationSpeed;
                    
                    this.timelineInterval = setInterval(() => {
                        if (this.currentTimelineIndex < this.cognitiveTimelineData.length - 1) {
                            this.stepTimelineForward();
                        } else {
                            this.stopTimelineAnimation();
                        }
                    }, interval);
                },

                stopTimelineAnimation() {
                    this.isTimelineAnimating = false;
                    if (this.timelineInterval) {
                        clearInterval(this.timelineInterval);
                        this.timelineInterval = null;
                    }
                },

                toggleTimelinePlayback() {
                    if (this.isTimelineAnimating) {
                        this.stopTimelineAnimation();
                    } else {
                        this.startTimelineAnimation();
                    }
                },

                stepTimelineForward() {
                    if (this.currentTimelineIndex < this.cognitiveTimelineData.length - 1) {
                        this.currentTimelineIndex++;
                        this.selectedTimelineState = this.cognitiveTimelineData[this.currentTimelineIndex];
                        this.updateTimelineHighlight();
                    }
                },

                stepTimelineBackward() {
                    if (this.currentTimelineIndex > 0) {
                        this.currentTimelineIndex--;
                        this.selectedTimelineState = this.cognitiveTimelineData[this.currentTimelineIndex];
                        this.updateTimelineHighlight();
                    }
                },

                seekToTimelinePosition(index) {
                    const targetIndex = parseInt(index);
                    if (targetIndex >= 0 && targetIndex < this.cognitiveTimelineData.length) {
                        this.currentTimelineIndex = targetIndex;
                        this.selectedTimelineState = this.cognitiveTimelineData[this.currentTimelineIndex];
                        this.updateTimelineHighlight();
                    }
                },

                resetTimelineView() {
                    this.stopTimelineAnimation();
                    this.currentTimelineIndex = 0;
                    this.selectedTimelineState = this.cognitiveTimelineData[0];
                    this.updateTimelineHighlight();
                },

                // State comparison and restoration
                canCompareWithPrevious() {
                    return this.currentTimelineIndex > 0;
                },

                async compareWithPreviousState() {
                    if (!this.canCompareWithPrevious()) return;
                    
                    const currentState = this.cognitiveTimelineData[this.currentTimelineIndex];
                    const previousState = this.cognitiveTimelineData[this.currentTimelineIndex - 1];
                    
                    try {
                        const response = await fetch('/api/cognitive-states/compare', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                state_id_1: previousState.state_id,
                                state_id_2: currentState.state_id
                            })
                        });
                        
                        if (response.ok) {
                            this.stateComparison = await response.json();
                            this.showComparisonModal = true;
                        } else {
                            throw new Error('Failed to compare states');
                        }
                        
                    } catch (error) {
                        console.error('Error comparing states:', error);
                        this.showToast('Error comparing states', 'error');
                    }
                },

                async restoreToState(state) {
                    if (!state) return;
                    
                    const confirmed = confirm(`Are you sure you want to restore to state "${state.state_type}" from ${new Date(state.timestamp * 1000).toLocaleString()}?\n\nThis will create a backup of the current state.`);
                    
                    if (!confirmed) return;
                    
                    try {
                        const response = await fetch(`/api/cognitive-states/${state.state_id}/restore`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ confirm: true })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            this.showToast(`State restored successfully! Backup: ${result.backup_state_id}`, 'success');
                            
                            // Refresh timeline to show new backup state
                            await this.loadCognitiveTimeline();
                        } else {
                            const error = await response.json();
                            throw new Error(error.detail || 'Failed to restore state');
                        }
                        
                    } catch (error) {
                        console.error('Error restoring state:', error);
                        this.showToast(`Error restoring state: ${error.message}`, 'error');
                    }
                },

                jumpToTimelineState(stateId) {
                    const index = this.cognitiveTimelineData.findIndex(s => s.state_id === stateId);
                    if (index !== -1) {
                        this.seekToTimelinePosition(index);
                    }
                },

                // Heatmap and network visualization placeholders
                renderTimelineHeatmap() {
                    if (!this.$refs.cognitiveHeatmap) return;
                    
                    const container = this.$refs.cognitiveHeatmap;
                    container.innerHTML = '<div class="flex items-center justify-center h-full text-gray-400"><div><i data-lucide="calendar" class="w-12 h-12 mx-auto mb-4 opacity-50"></i><p>Heatmap visualization coming soon</p></div></div>';
                    
                    // Re-initialize icons for the new content
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                },

                renderTimelineNetwork() {
                    if (!this.$refs.cognitiveNetworkSvg) return;
                    
                    const svg = d3.select(this.$refs.cognitiveNetworkSvg);
                    svg.selectAll("*").remove();
                    
                    const width = this.$refs.cognitiveNetworkSvg.clientWidth;
                    const height = this.$refs.cognitiveNetworkSvg.clientHeight;
                    
                    svg.append("text")
                        .attr("x", width / 2)
                        .attr("y", height / 2)
                        .attr("text-anchor", "middle")
                        .style("fill", "#9ca3af")
                        .style("font-size", "16px")
                        .text("Network visualization coming soon");
                }
            }
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Load theme
            const savedTheme = localStorage.getItem('ums-explorer-theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
        });

        // Initialize icons when Alpine is ready
        document.addEventListener('alpine:initialized', () => {
            if (window.lucide) {
                lucide.createIcons();
            }
        });
    </script>
</body>
</html>